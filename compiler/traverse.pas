{<<<}
{ traverse.pas - Tree building, improving and walking.

  This procedure takes data from the intermediate file generated by
  analys, and builds a full tree representation of each procedure as it is read.
  As the tree is being built, common subexpressions are detected
  and links to them inserted in place of later occurrences.

  Also, dead code that is recognized during the building process is deleted
  by simply not linking it into the tree.

  During the building operation, values that are assigned to simple variables are recorded and any further
  references to such variables are replaced by references to constants.

  This also allows more folding of expresssions to be detected and computed.

  During the building process, once a loop is entered, special operations are performed for the duration of the loop.
  Each entry point to a loop (a basic block) maintains a linked list of the var's read and written in the loop.

  This allows the improve phase to determine which expressions are invariant and may be hoisted.

  Also during the building process references to local variables are
  monitored to determine their suitability for register allocation.

  Doing this in travrs instead of analys has several advantages.
  First, references to var's within deadcode don't pollute the reference counts of the var.
  Second, lifetime analysis is done, which allows multiple var's to be assigned to a single register.
  Once the tree is built, local var's are assigned to registers, loops are examined, and invariant hoisting is performed.

  Finally, the tree is walked and "pseudocode" is generated for the code generation pass to use.
  Along with the actual operations, that portion of the tree which is currently active is passed to the code
  generator for its use.

  This provides the code generator with all of the data it might need,
  while conserving space in the code generation process.

  Since the tree can become quite large, most of it is built in a virtual storage area which is paged to a file.
  The tree consists of three hierarchical structures:  basic blocks, statements, and expressions.

  Each basic block consists of a group of statements, with one entry point and one or more exits.

  Each statement can consist of several expressions.

  The basic block structure, because it is generally small, and traversed often, is kept in the heap.
  Statements and expressions are implemented in the virtual store.
}
{>>>}
{<<<}
{ NOTICE OF COPYRIGHT AND OWNERSHIP OF SOFTWARE:

  Copyright (C) 1986, 1987, 1988, 1989, 1990 Oregon Software, Inc.
  All Rights Reserved.

  This program is the property of Oregon Software.  The program or
  parts of it may be copied and used only as provided under a signed
  license agreement with Oregon Software.  Any support purchased from
  Oregon Software does not apply to user-modified programs.  All copies
  of this program must display this notice and all copyright notices.

  Pascal-2 Compiler Tree Builder

  Last modified by KRIS on 21-Nov-1990 15:23:35
  Purpose:
  Update release version for PC-VV0-GS0 at 2.3.0.1
}
{>>>}
{<<<}
{ Intermediate File Handling -

  Both the Intermediate file generated by analys and the pseudo-code
  file written for the code generator are implemented as files of arrays of the basic file type.

  There are global variables "nextpseudofile" and "nextintcode" which serve as indices into these arrays.

  For instance, the current intermediate file element is referenced as intfile^[nextintcode].

  Embedded switches are kept in a table ("switches") and are synchronized
  with the intermediate file by a count of elements.

  As the intermediate file is read, the count is compared to that of
  the next switch in the table and the switchcounters set accordingly.
  At the same time, the element count in "switches" is updated to the output element count.
  Note that in this pass this will effectively group all switches at the start of the procedure in which they
  occur, as the pseudocode is not generated until the entire procedure has been read in.
}
{>>>}
{$nomain,nopointercheck}
{<<<  includes}
%include 'common.def';
%include 'inter.def';
%include 'pseudo.def';

%include 'main.def';
%include 'code.def';
%include 'debug.def';

%include 'traverse.def';
{>>>}

const { convert back to commandLine quals }
  dumpPseudo = true;
  dumpFiles = true;
  dumpDetails = true;

{<<<}
const
  pts = proctablespan; {shorter local name}

  maxloopdepth = 10;
  maxexprstack = 100;

  nodesperblock = travrsmaxnodeinblock; {nodes per physical file block - 1}
  maxblockslow = lowtravrsblocks; { min blocks for node file buffers, allocated statically
                                    to use some otherwise unused space in the global area}
{>>>}
{<<<}
type
  actions = (visit, copy, revisit, recopy); { Possible node states }

  { Define all possible Pascal statement header/trailer which exist in tree }
  {<<<}
  stmthdrtype = (blkhdr, gotohdr, labelhdr, whilehdr, rpthdr, ifhdr, foruphdr,
                 fordnhdr, withhdr, casehdr, caselabhdr, casegroup, simplehdr,
                 syscallhdr, untilhdr, forbothdr, whilebothdr, cforhdr,
                 cforbothdr, returnhdr, loopbrkhdr, loopconthdr, swbrkhdr,
                 cswbrkhdr, loopbothdr, loophdr, caseerrhdr, nohdr);
  {>>>}

  nodeptr = ^node; { Pointer to tree element }
  nodeindex = 0..tnodetablesize; {index to tree element}

  basicblockptr = ^basicblock;
  linkptr = ^links;
  {<<<}
  links =
    record
      pre: basicblockptr; { ptr to blocks predeccessor }
      pnext: linkptr; { ptr to next in predecessor chain }
      suc: basicblockptr; { ptr to blocks successor }
      snext: linkptr; { ptr to next in successor chain }
    end;
  {>>>}

  oprndindex = 1..3;
  operandarray = array [oprndindex] of integer;
  nodeoperandarray = packed array [oprndindex] of boolean;
  levelarray = packed array [levelindex] of boolean;

  stackindex = 0..maxexprstack; {index to operand stack}
  contextindex = 0..contextdepth; {index to context stack}
  maphashindex = 0..nodehashsize; {index to node hash table}
  reghashindex = 0..regtablelimit; {index to var hash table}

  nodeformtype = (stmtnode, exprnode);
  fonrange = shortint; {range for fon's}
  refcountrange = 0..maxrefcount; {range for refcounts}
  {<<<}
  node = packed record {describes a node in the expression tree}
           case nodeform: nodeformtype of
             exprnode:
               (refcount: refcountrange; {number of active references to this node}
                copycount: refcountrange; {number of copies mode of this node}
                valid: boolean; {set if node is valid for cse search}
                mustinvalidate: boolean; {invalidate node after next statement}
                join: boolean; {invalidate node at next join}
                target: boolean; {this node is an assignment target}
                relation: boolean; {subnodes contain a relational operator}
                local: boolean; {local to a conditional expression}
                nodeoprnd: nodeoperandarray; {set if oprnds[i] is a link}
                looplink: nodeindex; { link to other vars in this loop/ read or
                                      writes}
                cost: 0..maxcost; {cost of computing this node}
                prelink: nodeindex; { link of nodes that must be hoisted }
                hoistedby: basicblockptr; { this node is hoisted by this block }
                case action: actions of
                  visit, revisit:
                    (op: operator; { Operator from Analys }
                     form: types; {type of operands}
                     hasvalue: boolean; { true if we know the value of expression }
                     invariant: boolean; { true if expression is invariant }
                     ownvar: boolean; {true if expression is own variable}
                     regcandidate: boolean; {true if var is a register candidate}
                     deepestvalid: contextindex; {deepest level where node is valid}
                     slink: nodeindex; { Search link -- next node on hash chain }
                     len: addressrange; {length of operation result}
                     case {isrealnode:} boolean of
                       true: (realvalue: realarray);
                       false:
                         (oprnds: operandarray; {tree nodes or literal integers}
                          value: integer; { value propogated here } ); );
                  copy, recopy:
                    (oldlink: nodeindex; {link to next outer node being copied}
                     directlink: nodeindex {link to parent node being copied} ));
             stmtnode:
               (nextstmt: nodeindex; { Next statement in this basic block }
                textline: integer; { Textline where this statement starts }
                stmtno: integer; { statement counter value when encountered }
                srcfileindx: integer; { codegen access to file name }
                case stmtkind: stmthdrtype of

                  blkhdr:
                    (procref: proctableindex; { Reference into global proc table }
                     bs, ps: addressrange; { Local storage and parameter storage }
                     blkbody: nodeindex; { Point to first statement in block }
                     blkexit: basicblockptr; {exit block for return}
                     fileline: integer {line in actual file where block starts} );

                  casehdr:
                    (selector: nodeindex; { selector expression }
                     elements: nodeindex; { index to caselabhdrs in numeric order}
                     joinblock: basicblockptr; {ptr to stmtblock that defines tail}
                     firstgroup: nodeindex; {first case group produced by split}
                     groupcount: shortint; {number of groups produced by split}
                     casedefptr: basicblockptr; {default statement blk, if any} );

                  caselabhdr:
                    (caselabellow, caselabelhigh: integer; {label values}
                     stmtblock: basicblockptr; { ptr to stmt block for this label }
                     stmtlabel: labelrange; { label of stmt block }
                     orderedlink: nodeindex; {used to link case label table} );

                  casegroup:
                    (highestlabel, lowestlabel: nodeindex; {limiting entries}
                     ordered: boolean; {this is a contiguous ordered group}
                     groupno: shortint; {which group this is} );

                  forbothdr, whilebothdr, loopbothdr, whilehdr, rpthdr, ifhdr,
                  foruphdr, fordnhdr, withhdr, simplehdr, syscallhdr, untilhdr,
                  cforbothdr, returnhdr, nohdr:
                    (looptop: basicblockptr; { top of for/while }
                     expr1, expr2: nodeindex; {Expressions used by statement}
                     has_break: boolean; {loop body contains a break}
                     trueblock, falseblock: basicblockptr; {blocks for statement}
                     forstepsize: integer; { for step for Modula-2 } );

                  loopbrkhdr, loopconthdr, swbrkhdr, cswbrkhdr:
                    (targblock: basicblockptr; {target block for this statement} );

                  gotohdr, labelhdr:
                    (labelno: labelrange; {label value or internal label number}
                     nonlocalref: boolean; {true if label ref'd by non-local goto}
                     labellevel: levelindex; {For non-local gotos} ); );
         end;
  {>>>}

  {<<<}
  { Note about has_break: when the loop has a break statement, travrs does
    a clear context at the end of the loop, but does not say anything to
    the back-end; the back end assumes that the loop keeps the active keys
    'alive' which is done by inserting load at the bottom (or top) of the loop.
    The break gives the loop an exit which does not go through the load
    operations. The current fix if to issue a dummy pascal label at the end
    of such a loop. This leads to poor code... We only need to know if the loop
    has a break statement at the bottom of the loop.
  }
  basicblock = packed record
                 { basic block description }
                 dfolist: basicblockptr; { ptr to next block in depth first order }
                 rdfolist: basicblockptr; { ptr to next block in reverse dfo }
                 successor: linkptr; { direct successor of this block }
                 predeccessor: linkptr; { direct predeccessor of this block }
                 precode: nodeindex; { copy nodes and hoisted code for this block}
                 beginstmt: nodeindex; { link to first statement of this block }
                 defmin: fonrange; { lowest definition number in this block}
                 blocklabel: labelrange; { internal label number for this block }
                 isdead: boolean; { true if block is unreachable }
                 visited: boolean; { true if block visited }
                 clearop: boolean; { true if clear needed here }
                 joinop: boolean; { true if join op needed here }
                 saveop: boolean; { true if save op needed here }
                 restoreop: boolean; { true if restore op need here }
                 dominates: boolean; { true if block dominates loop exit }
                 loophdr: boolean; { true if 1st block of a loop }
                 forcelabel: boolean; { true if forced to use this label even if empty }
                     { NOTE: bigblock is true if at the time of block allocation
                       we thought that this block would be a loophdr. Since we may
                       later decide that construct is not a loop loophdr can be
                       false while bigblock is true we use bigblock to remember
                       what size block we must dispose.}
                 case bigblock: boolean of
                   true:
                     (looplabel: labelrange; { label of code below any hoisted }
                      reads: nodeindex; { chain of invariant for this loop }
                      writes: nodeindex; { chain of non-invariant for this loop }
                      lastwrite: nodeindex; { tail of chain of non-invariant for this loop
                                             }
                      deadlevels: levelarray; { the dead levels }
                      deadloop: boolean; {true if loop so deeply nested that we gave up}
                      willexecute: boolean; { true if loop will execute if flow reaches}
                     );
                   false: ();
               end;
  {>>>}

  {<<<}
  nodeblock = record {Kluge to use the same file for all virtual memories}
                case boolean of
                  false: (physical: doublediskblock {physical disk block} );
                  true:
                    (logical: array [0..nodesperblock] of node {local use of file} );
              end;
  {>>>}
  nodeblockptr = ^nodeblock; {used to access disk block buffers}
  blockindex = - 1..tmaxblocksin;

  {<<<}
  blockmap = record {maps incore buffers to virtual nodes on disk}
               blkno: blockindex; {virtual block number}
               written: boolean; {set if block is modified since read}
               lowblock: boolean; {true if in global core, not disposed of}
               buffer: nodeblockptr; {actual data buffer}
             end;
  {>>>}
  {<<<}
  stackrecord = record {holds operands as the stack is being built}
                  context_mark: nodeindex; {last node in this expression}
                  relation: boolean; { Node contains a relational op ('=') }
                  uniqueoprnd: boolean; { At least one operand is unique -- can't be CSE }
                  case litflag: boolean of {literal value?}
                    true: (i: integer {actual value} );
                    false:
                      (p: integer; {operand node}
                       l: contextindex {operand context level} )
                end;
  {>>>}
  {<<<}
  workingnode = record {Holds data on node being built}
                  op: operator; {operator for node}
                  form: types; {operator type}
                  ownvar: boolean; {true sez own variable}
                  len: addressrange; {length of operands}
                  cost: shortint; {cost of this node}
                  {up to three operands per node}
                  case {isrealnode:} boolean of
                    true: (rval: realarray; );
                    false: (oprndlist: array [oprndindex] of stackrecord; );
                end;
  {>>>}
  {<<<}
  contextrecord = record {context stack element, defines current statement context}
                    searchlevel: contextindex; { Lowest level with valid node }
                    joinflag: boolean; {must kill the tree at the next join point}
                    dominates: boolean; { true if this context dominates exit }
                    origlow: keyindex; {dead code kluge to reset low, shouldn't be needed
                                         now!}
                    firstblock: basicblockptr; { Point to basic block header for this level}
                    opmap: array [maphashindex] of nodeindex; {for searching nodes}
                    low, high: keyindex; {used to assign keys during walk}
                  end;
  {>>>}

  {<<<}
  region =
    record
      lonmin: nodeindex; { minimum node that refs var }
      lonmax: nodeindex; { maximum node that refs var }
      fonmin: fonrange; { flow order minimum value }
      fonmax: fonrange; { flow order maximum value }
    end;
  {>>>}
  regalloctype = (genreg, ptrreg, realreg, bytereg); { register allocation type }

  {<<<}
  simplevars = record
                 offset: addressrange; { offset of local var }
                 size: addressrange; {size of variable}
                 regkind: regalloctype; { register allocation type }
                 regid: 0..255; { register number assigned }
                 registercandidate: boolean; { true if not object of pushaddr or ref }
                 parameter: boolean; {true if this is a parameter}
                 debugrecord: integer; { for fixing debug symbol file }
                 varlife: region; { lifetime region }
                 worth: shortint; { value of this var }
               end;
  {>>>}
  {<<<}
  { used to dump the tree if necessary }
  dumpFileType = file of
    record
      case bblock: boolean of
        true:
          (id: integer; { integer should be same size as pointer!}
           basic: basicblock; { copy of the block }
          );
        false:
          (nodelab: nodeindex; {used to label the record}
           nodeent: node {a node copy} ; );
    end;
  {>>>}
{>>>}
{<<<}
var
  sharedPtr: sharedPtrType;
  interSharedPtr: interSharedPtrType;
  pseudoSharedPtr: pseudoSharedPtrType;

  truelabel, falselabel: labelrange; { for short circuit boolean evaluaton}
  trueused, falseused: boolean; { set if truelabel, falselabel used in eval}

  lasttravrslabel: labelrange; { last label used }

  emitpseudo : boolean; { 1-op delay due to pseudobuff/pseudoinst interface}

  root: basicblockptr; { root block for the current procedure}
  tail: basicblockptr; { tail block for the current procedure}

  regtemps: shortint;  { number of int vars actually reg allocated}
  ptrtemps: shortint;  { number of ptr vars actually reg allocated}
  realtemps: shortint; { number of real vars actually reg allocated}

  level: levelindex; { Lexical level of current procedure being worked over }

  intlevelrefs: boolean; { set if proc makes intermediate level references}

  lastnode: - 1..tnodetablesize; { last node allocated}
  laststmtnode: - 1..tnodetablesize; { last node for stmt}

  stack: array [stackindex] of stackrecord; { expression stack for building}
  sp: stackindex; { top of expression stack}
  cond_depth: stackindex; {count of nested conditional operators}

  newvarcount: shortint; {number of newvarop's in this tree.}

  {<<<}
  forstack: array [0..fordepth] of
      record {describes for loop controlled variable}
        { build side }
        forref: nodeindex; {node with variable}
        forlevel: contextindex; {context level of this loop}
        literalvalue: integer; { value of induction var for 1 trip loop }
        { walk side }
        forkey1: keyindex; { key for expr1 }
        forkey2: keyindex; { key for expr1 }
        improved: boolean; { true if test at bottom }
        downloop: boolean; { true if downto loop }
        {onetrip: boolean;} { true if a one trip only loop }
      end;
  {>>>}
  forsp: 0..fordepth; {top of forstack}

  {<<<}
  withstack: array [1..maxwithdepth] of
      record {describes with variables}
        withref: nodeindex; {node for withed variable}
        withlevel: contextindex; {context for this with level}
        withfonmin: fonrange;  {for extending lifetime of with expr vars}
        withfoncount: fonrange; {ditto}
      end;
  {>>>}
  withsp: 0..maxwithdepth; {top of with stack}

  keytable: array [keyindex] of nodeindex; {keys for active nodes in walk}

  context: array [contextindex] of contextrecord; {statement context stack}
  contextsp: contextindex; {top of context stack}
  overflowdepth: shortint; {counter for nesting > contextdepth}

  shorteval: boolean; {set if short-circuit eval of and/or/not wanted}
  inverted: boolean; {true if odd number of "nots" in short circuit eval}
  nowdebugging: boolean; {true if this block should generate debugging code}
  nowwalking: boolean; {true if this block should generate walkback code}
  killinput: boolean; {if true, read/readln without file name occured}
  irreducible: boolean; {this function has irreducible code}

  symbolrecord: integer; {symbol file record for this block (debugging)}

  nextintcode: 0..diskbufsize; {next entry in int file block}
  nextpseudofile: 0..diskbufsize; {next entry in pseudo file block}

  final_block_size: addressrange; {size of block as known at end of proc}

  laststmt: integer; {statement number of last statement generated(debugging)}
  controlstmt: boolean; {statement is control point (debugging)}
  branchstmt: boolean; {statement is non-local goto (debugging)}
  targetstmt: boolean; {statement is target of non-local goto (debugging)}

  fewestblocks, mostblocks: 0..tmaxblocksin; {monitor virtual buffers}

  map: packed array [operator, types] of pseudoop; {maps analys operators onto pseudoops}
  castmap: packed array [types, types] of pseudoop; {casts from form to form}

  dumpFile: dumpFileType; {used to dump the tree, if needed}
  walkdepth: shortint; {depth of progress into tree}

  visitstate: boolean; { state of "visited" blocks on current search }
  regvars: array [0..regtablelimit] of simplevars; { register var hash table}
  foncount: fonrange; { flow order number }

  loopfactor: shortint; { value assigned to localworth of variables }
  loopdepth: 0..maxloopdepth; { current loop depth }
  loopoverflow: shortint; { loopoverflow value }
  {<<<}
  loopstack: array [0..maxloopdepth] of
      record
        reads: nodeindex; { linked chain of vars only read in this loop }
        writes: nodeindex; { linked chain of vars modified in this loop }
        lastwrite: nodeindex; { tail of chain of vars modified in this loop }
        loopblock: basicblockptr; { index of loop header }
        deadlevels: levelarray; { the dead levels }
        fonmin: fonrange; { foncount at start }
      end;
  {>>>}

  blockblocks: shortint; { temp for debug }
  hoistone: shortint; { count of 1st level hoists }
  hoisttwo: shortint; { count of 2nd level hoists }
  ptr: nodeptr; { for access to basic block node }
  needjump: boolean; { true if this block needs a jump to it's successor }
  oktolabel: boolean; { true if current basic block can be labelled }
  oktoclear: boolean; {ok to clear keys (used in walk)}
  labelnext: boolean; { true if next basic block can be labelled }
  lnk, lnk2: linkptr; { for disposing succ/pred links }
  currentblock: basicblockptr; { basic block we are walking }
  maxnodes: integer;

  localparamnode: nodeindex; {points to node describing local param levop}
  thrashing: boolean; {set true when virt mem overflows onto disk}
  lastblocksin: 1..tmaxblocksin; {actual number of node blocks}
  blocksin: array [1..tmaxblocksin] of blockmap; {map of node blocks in memory}
  blockslow: array [1..maxblockslow] of nodeblock; {fixed blocks in store}
  bignodetable: array [0..bigtnodetablesize] of node;
  exitStmtno: integer; {save stmtno of the exit fake statement (VMS)}

  { the following are only a convenience when using pdb (setting watch point on a heap based variable, ...) }
  dbgbasicblockptr: basicblockptr;
  dbgbasicblockptr1: basicblockptr;
  dbgnodeptr: nodeptr;
  dbgnodeptr1: nodeptr;
  dbglinkptr: linkptr;
  dbglinkptr1: linkptr;
{>>>}

{<<<  utils}
{<<<}
function newlabel: labelrange;
{ Create a new pseudo-code label.  Labels created in travrs are assigned
  from the low numbers, while those created later in codegen are
  assigned from the high end (maxint) down.  This helps avoid conflict.
  The label is not defined by this routine, it simply generates unique
  labels for later definition.
}
begin
  lasttravrslabel := lasttravrslabel + 1;
  newlabel := lasttravrslabel
end;
{>>>}
{<<<}
procedure checkconst (node: nodeindex; var constflag: boolean; var i: integer);
{ Check node "node" to see if it is constant, and set "constflag" and
  "i" if it is.  This is used in dead code elimination.
}
var
  ptr: nodeptr; {used to access node}

begin
  ptr := ref(bignodetable[node]);
  with ptr^ do
    if (action in [visit, revisit]) and (op = intop) then
      begin
      constflag := true;
      i := oprnds[1];
      end
    else
      constflag := false;
end;
{>>>}
{<<<}
procedure estimateloop (stmt: nodeindex; var fixed: boolean; var overflow: boolean; var runcount: unsignedint);
{ Figure out if possible how many iterations a for loop will execute.
  Note : assumes that unsigned arithmetic works properly.
}
var
  ptr: nodeptr; {used to access index node}
  initialvalue, finalvalue: integer; {initial and final values}
  uinitialvalue, ufinalvalue: unsignedint; {initial and final values unsigned}
  currentstmt: node; { copy of the stmt node }
  constfinal: boolean; { true if to/downto is constant }

begin
  fixed := false;
  overflow := false;
  runcount := 0; {temp }
  ptr := ref(bignodetable[stmt]);
  currentstmt := ptr^;
  with currentstmt do
    begin

    ptr := ref(bignodetable[expr1]);
    if ptr^.op in [forupchkop, fordnchkop, forerrchkop] then
      checkconst(ptr^.oprnds[1], constfinal, finalvalue)
    else checkconst(expr1, constfinal, finalvalue);

    ptr := ref(bignodetable[expr2]);
    if constfinal and ((ptr^.op = defforlitindexop) or
       (ptr^.op = defunsforlitindexop)) then
      begin
      fixed := true;
      initialvalue := ptr^.oprnds[3];
      uinitialvalue := initialvalue;
      ufinalvalue := finalvalue;

      if stmtkind = foruphdr then
        begin
        if ptr^.op = defunsforlitindexop then
          begin
          if (uinitialvalue = 0) and (ufinalvalue = maxusint) then
            begin
            overflow := true;
            runcount := maxusint; { at least! }
            end
          else
            begin
            if ufinalvalue >= uinitialvalue then
              runcount := ufinalvalue - uinitialvalue + 1
            else runcount := 0;
            end;
          end
        else
          begin
          { assumes two's complement representation }
          if (initialvalue < - maxint) and (finalvalue = maxint) then
            begin
            overflow := true;
            runcount := maxusint; { at least! }
            end
          else
            begin
            if initialvalue <= finalvalue then
              begin
              if initialvalue >= 0 then
                runcount := finalvalue - initialvalue + 1
              else
                begin
                if finalvalue < 0 then
                  runcount := finalvalue - initialvalue + 1
                else
                  begin
                  runcount := - initialvalue;
                  runcount := runcount + finalvalue + 1;
                  end;
                end;
              end
            else runcount := 0;
            end;
          end;
        end
      else
        begin
        { down loop }
        if ptr^.op = defunsforlitindexop then
          begin
          if (uinitialvalue = maxusint) and (ufinalvalue = 0) then
            begin
            overflow := true;
            runcount := maxusint; { at least! }
            end
          else
            begin
            if ufinalvalue <= uinitialvalue then
              runcount := uinitialvalue - ufinalvalue + 1
            else runcount := 0;
            end;
          end
        else
          begin
          { assumes two's complement representation }
          if (initialvalue = maxint) and (finalvalue < - maxint) then
            begin
            overflow := true;
            runcount := maxusint; { at least! }
            end
          else
            begin
            if initialvalue >= finalvalue then
              begin
              if finalvalue >= 0 then
                runcount := initialvalue - finalvalue + 1
              else
                begin
                if initialvalue < 0 then
                  runcount := initialvalue - finalvalue + 1
                else
                  begin
                  runcount := - finalvalue;
                  runcount := runcount + initialvalue + 1;
                  end;
                end;
              end
            else runcount := 0;
            end;
          end;
        end; { down loop }
      end;
    end; {with}
end;
{>>>}

{<<<}
procedure putpseudofile;
{ Do the equivalent of a "put" on the pseudofile.
  It is assumed that the next pseudocode element has been stored in pseudofile^[nextpseudofile].
  If the buffer is full, it is actually written, otherwise the global index "nextpseudofile" is incremented.
}
begin
  if nextpseudofile = diskbufsize then
    begin
    nextpseudofile := 0;
    put (pseudoSharedPtr^.pseudoFile);
    end
  else
    nextpseudofile := nextpseudofile + 1;
end;
{>>>}
{<<<}
procedure genpseudo (o: pseudoop; l: addressrange; n: keyindex;
                     r: refcountrange; c: refcountrange; i, j, k: integer);
{ Generate a pseudocode output to the pseudofile.  Logically,
  this file consists of fixed length records, with unused fields
  filled with zeros.  The fields have the following use.
  op              Operator
  len             Length of operand (if needed)
  key             Key for this node, labels the node.
  refcount        Current ref count (decremented as copies made)
  copycount       Total copies made of this node
  oprnds          Operands, uses depend on op.
  In actual practice, many of the fields are zero for any particular
  operator, and a considerable reduction in I/O may be achieved by
  writing only the fields which are used.
}
  {<<<}
  procedure putint (i: integer);
  {<<<}
  { Put an integer to the pseudofile in a compressed format.  If the
    integer will fit into a single byte, it is so written, otherwise the
    largest value which will fit is used as an escape and the integer
    follows in full format.
  }
  {>>>}

    var
      { This fudges an integer into bytes.  The constant "32" is }
      { simply a large enough number to include all probable systems. }
      fudge:
        record
          case boolean of
            true: (int: integer);
            false: (byte: packed array [1..32] of hostfilebyte);
        end;
      j: 1..32; {induction var}

    begin
      if (i >= 0) and (i < hostfilelim) then
        pseudoSharedPtr^.pseudoFile^.block[nextpseudofile].byte := i
      else
        begin
        pseudoSharedPtr^.pseudoFile^.block[nextpseudofile].byte := hostfilelim;
        fudge.int := i;
        for j := 1 to hostintsize * hostfileunits do
          begin
          putpseudofile;
          pseudoSharedPtr^.pseudoFile^.block[nextpseudofile].byte := fudge.byte[j];
          end;
        end;
      putpseudofile;
    end;
  {>>>}

begin
  if travcode then
    begin
    pseudoSharedPtr^.pseudoinst := pseudoSharedPtr^.pseudobuff;
    with pseudoSharedPtr^.pseudobuff do
      begin
      len := l;
      op := o;
      key := n;
      refcount := r;
      copycount := c;
      oprnds[1] := i;
      oprnds[2] := j;
      oprnds[3] := k;
      if emitpseudo then
        codeone;
      emitpseudo := true;
      end;
    end;

  if not travcode or dumpPseudo then
    begin
    if sharedPtr^.putlow = maxint then
      begin
      sharedPtr^.putlow := 0;
      sharedPtr^.puthi := sharedPtr^.puthi + 1;
      end
    else
      sharedPtr^.putlow := sharedPtr^.putlow + 1;

    pseudoSharedPtr^.pseudoFile^.block[nextpseudofile].op := o;
    putpseudofile;

    { No key data}
    if not (o in [endpseudocode, bad, blockentry, blockexit, jumpf, jumpt, jump,
            pascallabel, savelabel, clearlabel, joinlabel, restorelabel,
            sysroutine, caseelt, setfile, closerange, restoreloop, saveactkeys]) then
      begin
      putint (l);
      putint (n);
      putint (r);
      putint (c);
      end;
    putint (i);

    { only one operand }
    if not (o in [endpseudocode, bad, blockexit, dovar, dounsvar, doint, doorigin,
                  pseudolabel, savelabel, clearlabel, joinlabel, restorelabel,
                  copyaccess, flt, pshaddr, pshstraddr, pshint, pshptr, pshreal, pshstr,
                  pshstruct, pshset, pshlitint, pshlitptr, pshlitreal, copystack, fmt,
                  wrint, wrreal, wrchar, wrst, wrbool, wrbin, wrxstr, rdbin, rdint,
                  rdchar, rdreal, rdst, rdxstr, stacktarget, ptrchk, chrstr, arraystr,
                  definelazy, setbinfile, setfile, closerange, restoreloop]) then
      begin
      putint(j);
      putint(k);
      end;
    end;
end;
{>>>}
{<<<}
procedure genrealop (o: pseudoop; l: addressrange; n: keyindex; r: refcountrange; c: refcountrange; val: realarray);
{ Generate a pseudo instruction with a real value as an operand }

var
  rsize: integer;
  i: 1..30;
  kludge: {for converting to ints}
    packed record
      case boolean of
        true: (r: realarray; );
        false: (i: array [1..30] of integer; );
    end;

begin
  rsize := size(realarray);
  kludge.r := val;
  i := 1;
  while rsize > 0 do
    begin
    genpseudo(o, l, n, r, c, kludge.i[i], kludge.i[i + 1], kludge.i[i + 2]);
    i := i + 3;
    rsize := rsize - 3 * size(integer);
    end;
end;
{>>>}

{<<<}
procedure increfcount (n: nodeindex; deadcode: boolean; inc: shortint);
{ Change the effective reference count for a node by "inc".
  This may have to chain down a sequence of nodes to get the actual most recent node which should be changed
}
var
  p: nodeptr;

begin
  if not (deadcode and (removedeadcode in sharedPtr^.genset)) and
     (n <> 0) {or (inc < 0)} then
    begin
    p := ref(bignodetable[n]);
    if p^.action = visit then
      if (p^.op < intop) and (p^.op > newunsvarop) then
        while p^.slink <> 0 do
          begin
          n := p^.slink;
          p := ref(bignodetable[n]);
          end;
    p := ref(bignodetable[n]);
    p^.refcount := p^.refcount + inc;
    if p^.action = visit then
      if p^.op = commaop then increfcount(p^.oprnds[2], deadcode, inc);
    end;
end;
{>>>}

{ foldcom }
{<<<}
procedure add (left, right: integer;  var result: integer; var overflow: boolean);
{ Add two target integers.  If the operation overflows, "overflow" will
  be set, and "result" will be set to the max value possible.
  ****Self hosted version
  This will have to be changed if the target integers are not the same
  size as the host integers;
}


  begin {add}
    overflow := ((left >= 0) = (right >= 0)) and ((left >= 0) and
                (sharedPtr^.targetmaxint - right < left) or (left < 0) and
                ( - sharedPtr^.targetmaxint - 1 - right > left));
    if overflow then
      if left >= 0 then result := sharedPtr^.targetmaxint
      else result := - sharedPtr^.targetmaxint - 1 {two's complement}
    else result := left + right;
  end {add} ;
{>>>}
{<<<}
procedure usadd (left, right: integer;  var result: integer; var overflow: boolean);
{ Unsigned add of two target integers.  If the operation overflows,
  "overflow"  is set, and "result" will be set to the max value possible.
  ****Self hosted version
  This will have to be changed if the target integers are not the same
  size as the host integers;
}

  var
    usleft, usright: unsignedint;


  begin {usadd}
    usleft := left;
    usright := right;
    overflow := maxusint - usleft < usright;
    if overflow then result := maxusint
    else result := usleft + usright;
  end {usadd} ;
{>>>}

{<<<}
procedure negate (operand: integer; var result: integer; var overflow: boolean);
{ Negate a target integer.  If it overflows, the result will be set to
  the limit at the appropriate sign.
  ****Self hosted version
}


  begin {negate}
    overflow := operand = ( - sharedPtr^.targetmaxint - 1);
    if overflow then result := sharedPtr^.targetmaxint
    else result := - operand;
  end {negate} ;
{>>>}
{<<<}
procedure subtract (left, right: integer; var result: integer; var overflow: boolean);
{ Subtract two target integers.  If the operation overflows, "overflow" will
  be set, and "result" will be set to the max value possible.
  ****Self hosted version
 }


  begin {subtract}
    overflow := ((left >= 0) <> (right >= 0)) and ((left >= 0) and
                (sharedPtr^.targetmaxint + right < left) or (left < 0) and
                ( - sharedPtr^.targetmaxint - 1 + right > left));
    if overflow then
      if left >= 0 then result := sharedPtr^.targetmaxint
      else result := - sharedPtr^.targetmaxint - 1 {two's complement}
    else result := left - right;
  end {subtract} ;
{>>>}
{<<<}
procedure ussubtract (left, right: integer; var result: integer; var overflow: boolean);
{ Unsigned subtract.  The result is required to be unsigned as well
  or overflow will be set.
  ****Self hosted version
}

  var
    usleft, usright: unsignedint;


  begin {ussubtract}
    usleft := left;
    usright := right;
    overflow := usleft < usright;
    if overflow then result := 0
    else result := usleft - usright;
  end {ussubtract} ;
{>>>}

{<<<}
procedure multiply (left, right: integer;  var result: integer; var overflow: boolean);
{ Multiply two target integers.  If the operation overflows, "overflow"
  will be set and "result" will be set to the max signed value possible.
  ****Self hosted version
  This will have to be changed if the target integers are not the same
  size as the host integers;
}


  begin {multiply}
    if left = -1 then overflow := right = (- sharedPtr^.targetmaxint - 1)
    else if right = -1 then overflow := left = (- sharedPtr^.targetmaxint - 1)
    else if (left <> 0) and (right <> 0) then
      overflow := ((left > 0) = (right > 0)) and ((left > 0) and
                  (sharedPtr^.targetmaxint div left < right) or (left < 0) and
                  (sharedPtr^.targetmaxint div left > right)) or
                  ((left > 0) <> (right > 0)) and ((left > 0) and
                  (( - sharedPtr^.targetmaxint - 1) div left > right) or (left < 0) and
                  (( - sharedPtr^.targetmaxint - 1) div right > left))
    else overflow := false;
    if overflow then
      if (left > 0) = (right > 0) then result := maxint
      else result := - maxint - 1
    else result := left * right;
  end {multiply} ;
{>>>}
{<<<}
procedure usmultiply (left, right: integer; var result: integer; var overflow: boolean);

{ Unsigned equivalent of the multiply routine
  ****self hosted version
}

  var
    usright, usleft: unsignedint;


  begin {usmultiply}
    usright := right;
    usleft := left;
    if (usright = 0) or (usleft = 0) then overflow := false
    else overflow := maxusint div usright < usleft;
    if overflow then result := maxusint
    else result := usleft * usright;
  end {usmultiply} ;
{>>>}

{<<<}
procedure divide (left, right: integer;  var result: integer; var overflow: boolean);
{ Divide two target integers.  If the operation overflows, "overflow"
  will be set and "result" will be set to the max signed value possible.
  ****Self hosted version
  This will have to be changed if the target integers are not the same
  size as the host integers;
}


  begin {divide}
    overflow := (right = 0) or (left = ( - sharedPtr^.targetmaxint - 1)) and
                (right = - 1);
    if overflow then
      if (left > 0) or (right = - 1) then result := sharedPtr^.targetmaxint
      else result := - sharedPtr^.targetmaxint - 1
    else result := left div right;
  end {divide} ;
{>>>}
{<<<}
procedure usdivide (left, right: integer;  var result: integer; var overflow: boolean);
{ Unsigned version of divide.
  *****16 bit 68K on a PDP11.  The PDP11 doesn't really have an unsigned
  divide instruction, so we have to fake it.
}

  var
    usleft, usright: unsignedint;


  begin {usdivide}
    usleft := left;
    usright := right;
    overflow := usright = 0;
    if overflow then result := maxusint
    else if usright > sharedPtr^.targetmaxint then
      if usright > usleft then result := 0
      else result := 1
    else result := usleft div usright;
  end {usdivide} ;
{>>>}

{<<<}
procedure remainder (left, right: integer;  var result: integer; var overflow: boolean);
{ Take the mod for target integers;  If "right" is zero, the result
  will be zero, and "overflow" will be set.
  ****self hosted version
}


  begin {remainder}
    overflow := right = 0;
    if overflow or (left = ( - sharedPtr^.targetmaxint - 1)) and ((right = - 1) or
       (right = ( - sharedPtr^.targetmaxint - 1))) then
      result := 0
    else if (right = ( - sharedPtr^.targetmaxint - 1)) then result := left
    else if left < 0 then
      if right < 0 then result := ( - left) mod ( - right)
      else result := - ( - left) mod right
    else if right < 0 then result := - (left mod ( - right))
    else result := left mod right;
    { Now that we have the arithmetic remainder, we can "correct"
      it to conform to the Pascal definition of "mod". }
    if true {we want the positive modulus} then
      if result < 0 then result := result + abs(right);
  end {remainder} ;
{>>>}
{<<<}
procedure usremainder (left, right: integer;  var result: integer; var overflow: boolean);
{ unsigned version of remainder
  ****self hosted version
}

  var
    usright, usleft: unsignedint;


  begin {usremainder}
    usright := right;
    usleft := left;
    overflow := usright = 0;
    if overflow then result := 0
    else result := usleft mod usright;
  end {usremainder} ;
{>>>}

{<<<}
procedure comparereal (left, right: real; var result: boolean; op: operator);
 { Fold the compare of a pair of real operands. }


  begin {comparereal}
   if realfolding then
    begin
    case op of
      lsslit: result := left < right;
      leqlit: result := left <= right;
      gtrlit: result := left > right;
      geqlit: result := left >= right;
      eqlit: result := left = right;
      neqlit: result := left <> right;
      end;
   end
  end {comparereal} ;
{>>>}
{<<<}
procedure uscompareint (left, right: unsignedint; var result: boolean; op: operator);
 { Fold the compare of a pair of unsigned integer operands. }


  begin
    { NOTE: it seems at first glance that we should take into
    account whether the other operand is signed and compensate
    However if this were done at runtime the code generator
    would generate an unsigned compare which would give different
    results than what we would do here. For consistency give the
    runtime result here. E.G.  -1 < x::0..maxusint-1 but a
    runtime this would be false since -1 = maxusint and we do
    a simple unsigned compare.
    }
    case op of
      lsslit: result := left < right;
      leqlit: result := left <= right;
      gtrlit: result := left > right;
      geqlit: result := left >= right;
      eqlit: result := left = right;
      neqlit: result := left <> right;
      end;
  end; {uscompareint}
{>>>}
{<<<}
procedure compareint (left, right: integer; var result: boolean; op: operator);
{ Fold the compare of a pair of unsigned integer operands. }

  begin
    case op of
      lsslit: result := left < right;
      leqlit: result := left <= right;
      gtrlit: result := left > right;
      geqlit: result := left >= right;
      eqlit: result := left = right;
      neqlit: result := left <> right;
      end;
  end; {compareint}
{>>>}
{>>>}

{<<<  walk}
{<<<}
function getlabel (blk: basicblockptr): labelrange;
{
    Purpose:
      return the blocklabel of basic block pointed to by blk.

    Inputs:
      blk : pointer to block we want label of

    Outputs:
      getlabel : the label of the block.

    Algorithm:
      If jumping to a block that is empty, then search successor lists
      until reaching final destination, then if the block has a blocklabel
      assigned the return it else assign a new label and return it.

    Sideeffects:
      basic block is modified.

    Last Modified: 1/21/86

}


  begin {getlabel}
    { get the final destination of the jump }

    while not blk^.forcelabel and (blk^.beginstmt = 0) and
          (blk^.successor <> nil) do
      blk := blk^.successor^.suc;
    with blk^ do
      begin
      if blocklabel = 0 then blocklabel := newlabel;
      getlabel := blocklabel;
      end;
  end {getlabel} ;
{>>>}
{<<<}
function exitlabel (blk: basicblockptr): labelrange;
{
    Purpose:
      return the blocklabel of basic block pointed to by blk.

    Inputs:
      blk : pointer to block we want label of

    Outputs:
      exitlabel : the label of the block.

    Algorithm:
      NOTE: Used only by for statements because of the "free" labeling done
      by genblk. In genblk fortop labels controlled block for free and
      forbottom labels itself for free, because of this we can't jump
      to final destination without screwing up block labels.  Otherwise
      blocks can be labelled twice or labels never generated.
      If genblk were changed to label code only on "label" pseudoops
      the world would be a better place.

      If the block has a blocklabel assigned the return it else
      assign a new label and return that.

    Sideeffects:
      basic block is modified.

    Last Modified: 1/21/86

}


  begin {exitlabel}
    if blk = nil then exitlabel := 0
    else
      with blk^ do
        begin
        if blocklabel = 0 then blocklabel := newlabel;
        exitlabel := blocklabel;
        end;
  end {exitlabel} ;
{>>>}

{<<<}
procedure clearkeys;

{ Clear all reusable keys.  A key is reusable when it has a reference
  count of zero, and all keys greater than it are reusable.  This allows
  the code generator to keep track of useful keys with a simple pointer
  to the key for the last pseudocode read.
}

  var
    done: boolean; {true when no more keys reusable}
    ptr: nodeptr; {used for access to key nodes}


  begin
    if oktoclear then
      with context[contextsp] do
        begin
        done := high < low;
        while not done do
          begin
          ptr := ref(bignodetable[keytable[high]]);
          if (keytable[high] = 0) or (ptr^.refcount = 0) then high := high - 1
          else done := true;
          done := done or (high < low);
          end;
        end;
  end {clearkeys} ;
{>>>}

{<<<}
procedure definelabel (l: labelrange {label to define} );

{ Generate pseudocode to define a label with number "l".  The label
  will refer to the next pseudocode generated.
}


  begin
    genpseudo(pseudolabel, 0, 0, 0, 0, l, 0, 0);
  end {definelabel} ;
{>>>}
{<<<}
procedure definesavelabel (l: labelrange {label to define} );

{ Begin a new context level, and emit pseudocode which both defines a
  label and informs the code generator that a new context level is
  being entered.  This is the code generator analog of "savecontext",
  and handles context overflow by emitting a pseudolabel rather
  than savelabel to prevent overflow in the code generator.
}


  begin
    clearkeys;
    if contextsp = contextdepth then
      begin
      overflowdepth := overflowdepth + 1;
      definelabel(l);
      end
    else
      begin
      genpseudo(savelabel, 0, 0, 0, 0, l, 0, 0);
      contextsp := contextsp + 1;
      with context[contextsp] do
        begin
        high := context[contextsp - 1].high;
        low := high + 1;
        origlow := low;
        end;
      end;
  end {definesavelabel} ;
{>>>}
{<<<}
procedure definerestorelabel (l: labelrange {label to define} );

{ End a context level, restoring prior keys, and emit pseudocode which
  both defines a label and informs the code generator to restore a
  previously saved context.  If we are in a context overlow situation,
  a pseudolabel operator is emitted and no context operation performed.
}


  begin
    {The following is a dead code elimination kludge}
    {please explain. }
    if overflowdepth <= 0 then
      with context[contextsp] do low := origlow;
    clearkeys;
    if overflowdepth > 0 then
      begin
      overflowdepth := overflowdepth - 1;
      definelabel(l);
      end
    else
      begin
      genpseudo(restorelabel, 0, 0, 0, 0, l, 0, 0);
      contextsp := contextsp - 1;
      end;
  end {definerestorelabel} ;
{>>>}
{<<<}
procedure defineclearlabel (l: labelrange {label to define} );

{ Emit pseudocode which both defines a label and informs the code generator
  that all keys in the current context are invalid and should be cleared.
}


  begin
    genpseudo(clearlabel, 0, 0, 0, 0, l, 0, 0);
    clearkeys;
  end {defineclearlabel} ;
{>>>}
{<<<}
procedure definejoinlabel (l: labelrange {label to define} );

{ Emit pseudocode which both defines a label and informs the code generator
  that contexts just joined, and keys should be updated accordingly.
}


  begin
    genpseudo(joinlabel, 0, 0, 0, 0, l, 0, 0);
    clearkeys;
  end {joinlabel} ;
{>>>}

{ Actual tree walking procedures }
procedure walknode (root: nodeindex; var key: keyindex; targetkey: keyindex; counting: boolean); forward;
procedure walkboolean (root: nodeindex; var key: keyindex; tlabel: labelrange; flabel: labelrange); forward;}
procedure walkvalue (root: nodeindex; var key: keyindex; targetkey: keyindex); forward;}

{<<<}
procedure shortvisit (root: nodeindex; {tree to visit}
                     inpushaddr: boolean {true sez part of a pshaddr} );

{ This procedure visits all nodes in the tree rooted in "root" and
  generates pseudocode for those nodes with ref count > 1.  This is
  used for components of a short-circuit expression to make sure
  that all common subexpressions which are used later get generated
  no matter what portion of the expression is actually executed at
  runtime.
}

  var
    j: 1..3; {induction for operand scan}
    k: keyindex; {dummy argument to walknode}
    ptr: nodeptr; {used for access to root node}
    op: operator; {operator for this node}
    oprndptr: nodeptr; {used for access one level down}
    newroot: nodeindex; {used in rem/quo hack}


  begin
    ptr := ref(bignodetable[root]);
    newroot := root;
    op := ptr^.op;
    if ptr^.action = visit then
      begin
      if (op in [quoop, remop]) and (ptr^.refcount = 1) then
        begin
        newroot := ptr^.oprnds[1];
        ptr := ref(bignodetable[ptr^.oprnds[1]]);
        end;
      if not ptr^.local and ((ptr^.refcount > 1) or (ptr^.op = mulop) and
         (ptr^.form = ints) or
         (op in
         [pushcvalue, divop, quoop, remop, paindxop, chrstrop, arraystrop, commaop]) or
         sharedPtr^.switcheverplus[largemodel] and ((ptr^.op = filebufindrop) or
         (ptr^.op = indrop))) then
        walknode(root, k, 0, false)
      else
        begin
        inpushaddr := inpushaddr or (op = pushaddr) or (op = pushstraddr);
        if inpushaddr then
          for j := 1 to 3 do
            if ptr^.nodeoprnd[j] then
              begin
              oprndptr := ref(bignodetable[ptr^.oprnds[j]]);
              if (oprndptr^.op in
                 [originop, call, callparam, unscall, unscallparam]) or
                 (oprndptr^.form in [sets, strings]) then
                begin
                walknode(ptr^.oprnds[j], k, 0, false);
                ptr := ref(bignodetable[newroot]);
                end;
              end;
        for j := 1 to 3 do
          if ptr^.nodeoprnd[j] then
            begin
            shortvisit(ptr^.oprnds[j], inpushaddr);
            ptr := ref(bignodetable[newroot]);
            end;
        if (ptr^.op < intop) and (ptr^.slink <> 0) then
          shortvisit(ptr^.slink, false);
        end;
      end;
  end {shortvisit} ;
{>>>}
{<<<}
procedure unnestsets (root: nodeindex {tree to visit} );

{ This procedure visits all nodes in the tree rooted in "root" and
  generates pseudocode for any bldset nodes. This is done so that the
  code generator doesn't have to keep track of nested set targets.
  In the rare (!) case that a set element involves another set, we
  walk the nested set here.  Called only by bldsetnode.
}

  var
    j: 1..3; {induction for operand scan}
    k: keyindex; {dummy argument to walknode}
    ptr: nodeptr; {used for access to root node}


  begin {unnestsets}
    ptr := ref(bignodetable[root]);
    if ptr^.action = visit then
      if ptr^.op = bldset then walknode(root, k, 0, false)
      else
        begin
        for j := 1 to 3 do
          if ptr^.nodeoprnd[j] then
            begin
            unnestsets(ptr^.oprnds[j]);
            ptr := ref(bignodetable[root]) ;
            end;
        if (ptr^.op < intop) and (ptr^.slink <> 0) then unnestsets(ptr^.slink);
        end;
  end {unnestsets} ;
{>>>}
{<<<}
function targetpresent (p: nodeindex {node to check} ): boolean;

{ True if the target node is used in the expression represented by "p".
  This simply checks "p" and its operands (or class representative for
  a copy operation) for the target flag.
}

  var
    cnt: 0..3; {induction var for checking operands}
    found: boolean; {set if target found}
    ptr: nodeptr; {used to access nodes}


  begin
    found := false;
    ptr := ref(bignodetable[p]) ;
    if ptr^.action = recopy then found := targetpresent(ptr^.oldlink)
    else
      begin
      found := ptr^.target;
      cnt := 0;
      while (cnt < 3) and not found do
        begin
        cnt := cnt + 1;
        if ptr^.nodeoprnd[cnt] then
          begin
          found := targetpresent(ptr^.oprnds[cnt]);
          end;
        end;
      if not found and (ptr^.op < intop) and (ptr^.slink <> 0) then
        found := targetpresent(ptr^.slink);
      end;
    targetpresent := found;
  end {targetpresent} ;
{>>>}
{<<<}
function newkey : keyindex;

{ Return the next highest key.  If none available, give panic error
  and stop compilation.
}


  begin
    if context[contextsp].high = keysize then abort(manykeys)
    else newkey := context[contextsp].high + 1;
  end {newkey} ;
{>>>}

{<<<}
procedure walkboolean
                       {root: nodeindex; (root of tree to walk)
                        var key: keyindex; (resulting key)
                        tlabel: labelrange; (lab for true result)
                        flabel: labelrange; (lab for false result)} ;

{ Do a shortcircuit evaluation of a boolean expression using "tlabel"
  and "flabel" as truelabel and falselabel.
}


  begin
    inverted := false;
    trueused := false;
    falseused := false;
    truelabel := tlabel;
    falselabel := flabel;
    shortvisit(root, false);
    genpseudo(saveactkeys, 0, 0, 0, 0, 0, 0, 0);
    walknode(root, key, 0, true);
    if inverted then genpseudo(jumpt, 0, 0, 0, 0, flabel, key, 0)
    else genpseudo(jumpf, 0, 0, 0, 0, flabel, key, 0);
    falseused := true;
  end {walkboolean} ;
{>>>}
{<<<}
procedure walkvalue;

{ Walk an expression, returning a value.  If the result is a boolean
  relation, the shortcircuit boolean evaluation is converted into a
  value on the stack.
}

  var
    rootp: nodeptr; {used to access root node}


  procedure convertrelation;

{ Convert relational expression to a value.  Note: booleans are
  assumed to be one unit long here.
}

    var
      oldinv: boolean; {local save for "inverted"}
      oldt, oldf: labelrange; {local saves for "truelabel", "falselabel"}
      oldtused, oldfused: boolean; {local saves for "trueused", "falseused"}
      tlabel, flabel: labelrange; {new labels for converting to value}
      k, k1: keyindex; {new key for false portion of value}
      oldclearok: boolean; {old value of oktoclear}
      valsize: addressrange; {the size of the value, different for diff. lang}


    begin {convertrelation}
      oldclearok := oktoclear;
      oktoclear := false;
      oldinv := inverted;
      oldt := truelabel;
      oldf := falselabel;
      oldtused := trueused;
      oldfused := falseused;
      valsize := unitsize;
      tlabel := newlabel;
      flabel := newlabel;
      if (targetkey <> 0) and targetpresent(root) then targetkey := 0;
      k := newkey;
      context[contextsp].high := k;
      keytable[k] := 0;
      genpseudo(createfalse, valsize, k, 1, 0, 0, 0, targetkey);
      walkboolean(root, k1, tlabel, flabel);
      if trueused then definelabel(tlabel);
      key := newkey;
      context[contextsp].high := key;
      keytable[key] := root;
      if keytable[k1] = root then keytable[k1] := 0; { use value, not relation,
                                                       in future }
      genpseudo(createtrue, valsize, key, 1, 0, k, 0, 0);
      definelabel(flabel);
      inverted := oldinv;
      truelabel := oldt;
      falselabel := oldf;
      trueused := oldtused;
      falseused := oldfused;
      oktoclear := oldclearok;
    end {convertrelation} ;


  begin {walkvalue}
    rootp := ref(bignodetable[root]);
    if rootp^.relation then convertrelation
    else walknode(root, key, targetkey, true);
  end {walkvalue} ;
{>>>}
{<<<}
procedure walknode
                    {root: nodeindex; (root of tree to walk)
                     var key: keyindex; (resulting key)
                     targetkey: keyindex; (target (0 if none))
                     counting: boolean (decr ref counts)} ;

{ Walk the expression tree rooted in "root", generating code as needed.
  The key for the root node is returned in "key".  "targetkey" is
  passed on to the code generator to aid in generating good code.  In
  the case of an assignment, this is the key for the target.
  If "counting" is set, the refcount of the root is decremented.
  This is the normal action unless some common expressions are being
  precomputed, as by "shortvisit".

  If there are multiple nodes linked through "slink", these are walked
  sequentially.

  There are several possible states for a node, and "walknode" takes
  appropriate action for the particular node state.  The states are:

  visit:        The node is an expression, and has not been walked.

  revisit:      As visit, but the node has been walked, just pick up the
                key from the keytable.

  copy:         The node is a copy of a common expression on entering
                a new context, and the copy has not been generated.

  recopy:       Same as copy, but the node has been walked, so just
                pick up the key from the keytable.

  The routines "visitnode" and "copynode" are used to handle nodes which
  must be walked.

  The variables "refcount", "copycount" and "len" are global to
  the internal routines which handle individual nodes, and give
  the parameters of the root node.
}

  var
    rootp: nodeptr; {used to access root}
    nextroot: nodeindex; {next node along slink path}
    refcount: refcountrange; {refcount for root node}
    copycount: refcountrange; {copy count for root node}
    len: addressrange; {length for root node}


  procedure mapkey;

{ Find or create a key for the root node.  The keytable is simply
  a table of node indices, and each context has a high and low index
  into this table.  The table is searched for the index of the root node,
  and if not found it is added to the high end of the table.

  The result is left in the argument (to walknode) "key".
}

    var
      i: keyindex; {induction var for search}


    begin {mapkey}
      with context[contextsp] do
        begin
        i := 0;
        key := newkey;
        keytable[key] := root;
        repeat
          i := i + 1;
        until (keytable[i] = root);
        if i = key then high := i
        else key := i;
        end;
    end {mapkey} ;


  procedure visitnode;

{ Walk a node in the state "visit".  This routine contains many small
  node-specific routines which generate pseudocode for the nodes as
  they are walked.  This is the routine which actually generates the
  majority of the expression code.

  Data on the left and right operands of binary (or unary) operators
  is kept local to this routine to reduce accesses to the tree for
  the internal procedures.
}

    var
      lkey, rkey: keyindex; {keys for left and right operands}
      rootp: nodeptr; {used to access root node}
      l, r: integer; {left and right operand nodes, or literals}


    function cost(p: nodeindex {node to check} ): shortint;

{ Returns the cost of the operation represented by node p.  This is
  the number of temporary locations needed to compute the operation
  and all of its sub-trees.
}

      var
        ptr: nodeptr; {used to access node}


      begin
        ptr := ref(bignodetable[p]);
        cost := ptr^.cost;
      end {cost} ;


    procedure walkboth;

{ Walk both operands, called for binary operations.

  The operand with the largest cost is walked first, as we know that
  the other operand can then be computed with at most one more register
  used (worst case when costs are equal).  If the target is present in
  the second node to be walked, the target key is not passed to the
  first node, since it will not be able to make use of it.  Only the
  final calculation in an expression can change the target.
}

      var
        lefttarget, righttarget: nodeindex; {target to pass to left or right
                                             operand}


      begin {walkboth}
        if (targetkey <> 0) and (l <> r) and targetpresent(l) then
          righttarget := 0
        else righttarget := targetkey;
        if (targetkey <> 0) and (l <> r) and targetpresent(r) then
          lefttarget := 0
        else lefttarget := targetkey;
        if cost(l) >= cost(r) then
          begin
          walkvalue(l, lkey, lefttarget);
          if lefttarget <> 0 then righttarget := 0;
          walkvalue(r, rkey, righttarget);
          end
        else
          begin
          walkvalue(r, rkey, righttarget);
          if righttarget <> 0 then lefttarget := 0;
          walkvalue(l, lkey, lefttarget);
          end;
        mapkey;
      end {walkboth} ;


{ Node-specific walking routines.
  This series of routines take node-specific actions to generate pseudo-
  code for expressions.  They are called from the large case statement
  which makes up the majority of "visitnode".
}


    procedure indxnode(p: pseudoop {operator for root node} );

{ Walk and generate code for "indx" or "pindx" operations.

  These operations compute the address of a variable, and this routine
  checks to see if the variable should be assigned to a register.
  Analys made an estimate of the best local vars to assign to registers,
  and if the operation describes a local var the displacement is
  checked against the list from analys and assigned to the temp register
  if it matches.
}

      var
        lp: nodeptr; {used to access left operand}
        possibletemp: boolean; {true if local var and possible temp loc}
        offset: addressrange; {variable offset if possibletemp}
        j: 0..regtablelimit; { var for temp search }
        third: integer; {third operand, zero or temp number}
        paramflag: boolean; {true if indexing parameter level}


      begin
        lp := ref(bignodetable[l]);
        third := 0;
        offset := rootp^.oprnds[2];
        paramflag := l = localparamnode;
        with lp^ do
          if action = revisit then
            possibletemp := (p = indx) and (op = levop) and (oprnds[1] = level)
          else possibletemp := false;

        walknode(l, lkey, 0, true);

        if possibletemp then
          begin
            { This hashes the var's offset, really should be a function call.
              However it would be called in several high bandwidth places and
              places an unneeded speed penalty on this phase.
              This code is replicated in procedures: doreference, killasreg
              and dodefine in travrs.
            }
          j := (offset div sharedPtr^.targetintsize) mod (regtablelimit + 1);
          while ((regvars[j].offset <> offset) or
                (regvars[j].parameter <> paramflag)) and
                (regvars[j].worth >= 0) do
            j := (j + 1) mod (regtablelimit + 1);
          if regvars[j].regid <> 0 then
            begin
            { assigned to a register }
            third := regvars[j].regid;
            case regvars[j].regkind of
              genreg, bytereg: p := regtemp;
              realreg: p := realtemp;
              ptrreg: p := ptrtemp;
              end;
            end;
          end;

        mapkey;
        genpseudo(p, len, key, refcount, copycount, lkey, offset, third);

      end {indxnode} ;


    procedure vindxnode;

{ Walk and generate code for "vindx" operations.

  This is very similar to "indx" except that it is used for local
  variables in C functions.  Such functions allow variables local to
  inner blocks, so the blocksize is unknown until function exit.
  This routine computes the actual address from that data.
  Also, any variable references with 'vindx" is a register candidate.
  Note that there is an arbitrary "offset" used only to identify the variable,
  and a real offset which is the location in the block.

  These operations compute the address of a variable, and this routine
  checks to see if the variable should be assigned to a register.
  Analys made an estimate of the best local vars to assign to registers,
  and if the operation describes a local var the displacement is
  checked against the list from analys and assigned to the temp register
  if it matches.
}

      var
        lp: nodeptr; {used to access left operand}
        offset: addressrange; {actual variable offset}
        trav_offset: addressrange; {traverse offset for temp check}
        j: 0..regtablelimit; { var for temp search }
        third: integer; {third operand, zero or temp number}
        p: pseudoop; {the operation to generate}


      begin
        lp := ref(bignodetable[l]);
        third := 0;
        offset := final_block_size - rootp^.oprnds[2];
        trav_offset := rootp^.oprnds[3];
        p := indx;

        walknode(l, lkey, 0, true);

        if trav_offset <> 0 then
          begin
          { This hashes the var's offset, really should be a function call.
            However it would be called in several high bandwidth places and
            places an unneeded speed penalty on this phase.
            This code is replicated in procedures: doreference, killasreg
            and dodefine in travrs.
          }
          j := (trav_offset div sharedPtr^.targetintsize) mod (regtablelimit + 1);
          while (regvars[j].offset <> trav_offset) and
                (regvars[j].worth >= 0) do
            j := (j + 1) mod (regtablelimit + 1);
          if regvars[j].regid <> 0 then
            begin
            { assigned to a register }
            third := regvars[j].regid;
            case regvars[j].regkind of
              genreg, bytereg: p := regtemp;
              realreg: p := realtemp;
              ptrreg: p := ptrtemp;
              end;
            end;
          end;

        mapkey;
        genpseudo(p, len, key, refcount, copycount, lkey, offset, third);

      end {vindxnode} ;


    procedure openarraynode;

{ walk and generate code for copying an open array value parameter's value
into newly-opened space in the procedure's stack frame. }


      begin {openarraynode}

        genpseudo(openarray, len, 0, 0 {refcount} , 0 {copycount} ,
                  rootp^.oprnds[1] {offset} , rootp^.oprnds[2], 0);

      end {openarraynode} ;


    procedure orderednode(op: operator; {root operator}
                          form: types {operand form} );

{ Walk and generate code for an operator whose right operand should
be walked first irregardless of which operand has higher cost.
Currently, the only operators which fit into this catagory cannot
make use of targetting information, so the operands are walked
with target = 0.
}


      begin {orderednode}
        walkvalue(r, rkey, 0);
        walkvalue(l, lkey, 0);
        mapkey;
        genpseudo(map[op, form], len, key, refcount, copycount, lkey, rkey,
                  targetkey);
      end {orderednode} ;


    procedure binarynode(op: operator; {root operator}
                         form: types {operand type} );

{ Walk and generate code for a normal binary operation "op" with
  operand type "form".  The array "map" converts the operator and
  type into a pseudocode operator.

  ***PDP11***
  The special targets multarget and divtarget are passed to the
  operand trees to facilitate good code generation if these
  operations require special action or register allocation.
}

      var
        oldtarget: keyindex; {target key for root node}


      begin
        oldtarget := targetkey;
        walkboth;
        genpseudo(map[op, form], len, key, refcount, copycount, lkey, rkey,
                  oldtarget);
      end {binarynode} ;


    procedure incnode(op: operator; {root operator}
                      form: types; {operand type}
                      op3: integer {third operand} );

{ Walk and generate code for a pre or pos increment operation with
  operand type "form".  The array "map" converts the operator and
  type into a pseudocode operator.

  If the third operand is negative, it is passed along in place of the
  target
}


      begin
        if op3 >= 0 then op3 := targetkey;
        walkboth;
        genpseudo(map[op, form], len, key, refcount, copycount, lkey, rkey,
                  op3);
      end {incnode} ;


    procedure reflexivenode(op: operator; {root operator}
                            form: types {operand type} );

{ Walk a reflexive operator.  We fake this as an ordinary operator
  but the left hand side is always the target.  We then fake a binary
  operation followed by a move.  The reference count of the left side
  was incremented when building especially to allow this.
  Some casts may well be necessary to keep things in the proper form.
  These are computed from the type of the operation and the type
  of the lvalue.
}

      var
        target: keyindex; {dummy target operand}
        tkey: keyindex; {temp for result}
        ckey: keyindex; {cast lvalue key}
        lp: nodeptr; {for access to the left side}
        lform: types; {type of lvalue}
        llen: addressrange; {length of lvalue}
        use_casts: boolean; {we have to insert casts}


      begin
        target := 0;
        lp := ref(bignodetable[l]);
        llen := lp^.len;
        lform := loophole(types, rootp^.oprnds[3]);
        walknode(l, lkey, 0, true);
        genpseudo(startreflex, 0, 0, 0, 0, 0, 0, 0);
        use_casts := (lform <> form) or (lform = reals) and (llen <> len);
        if use_casts then
          begin
          ckey := newkey;
          context[contextsp].high := ckey;
          keytable[ckey] := 0;
          genpseudo(castmap[form, lform], len, ckey, 1, 0, lkey, 0, 0);
          end
        else ckey := lkey;
        walkvalue(r, rkey, 0);
        tkey := newkey;
        context[contextsp].high := tkey;
        keytable[tkey] := 0;
        genpseudo(map[op, form], len, tkey, 1, 0, ckey, rkey, ckey);
        if use_casts then
          begin
          ckey := newkey;
          context[contextsp].high := ckey;
          keytable[ckey] := 0;
          genpseudo(castmap[lform, form], llen, ckey, 1, 0, tkey, 0, 0);
          end
        else ckey := tkey;
        mapkey;
        genpseudo(map[moveop, lform], llen, key, refcount, copycount, lkey,
                  ckey, targetkey);
        genpseudo(endreflex, 0, 0, 0, 0, 0, 0, 0);
      end; {reflexivenode}


    procedure reflexdivnodes(op: operator; {root operator}
                             form: types {operand type} );

{ Walk a reflexive divide operator.  This would be the same as any
  other reflexive operator except that integer divide and mod are
  handled specially.
}

      var
        target: keyindex; {dummy target operand}
        tkey, tdkey: keyindex; {temps for results}


      begin
        if form = ints then
          begin
          target := 0;
          walknode(l, lkey, target, true);
          genpseudo(startreflex, 0, 0, 0, 0, 0, 0, 0);
          target := 0;
          walkvalue(r, rkey, target);
          tdkey := newkey;
          context[contextsp].high := tdkey;
          keytable[tdkey] := 0;
          genpseudo(divint, len, tdkey, 1, 0, lkey, rkey, lkey);
          tkey := newkey;
          context[contextsp].high := tkey;
          keytable[tkey] := 0;
          genpseudo(map[op, ints], len, tkey, 1, 0, tdkey, 0, lkey);
          mapkey;
          genpseudo(movint, len, key, refcount, copycount, lkey, tkey,
                    targetkey);
          genpseudo(endreflex, 0, 0, 0, 0, 0, 0, 0);
          end
        else reflexivenode(op, form);
      end; {reflexdivnodes}


    procedure commanode;

{ Walk a comma operator.  This just walks and discards the left
  operand.  The result is the right operand.
}

      var
        target: keyindex; {target, ignored}
        deref: boolean; {set true if we must deref subtree}


      begin
        target := 0;
        deref := rootp^.refcount > 0;
        walknode(l, lkey, target, false);
        if deref then walkvalue(r, rkey, targetkey)
        else walknode(r, rkey, targetkey, false);
        mapkey;
        genpseudo(commafake, len, key, refcount, copycount, rkey, 0, 0);
      end; {commanode}


    procedure litopnode(op: operator; {root operator}
                        form: types {operand form} );

{ Walk and generate code for an operator with one literal operand.
  Only the left operand is an expression, the right is the literal
  value in the right operand location.

  Note: only values which can be represented in a single integer
  value may be used as operands for literal operations.
}


      begin
        walkvalue(l, lkey, targetkey);
        mapkey;
        genpseudo(map[op, form], len, key, refcount, copycount, lkey, r,
                  targetkey);
      end {litopnode} ;


    procedure movelitnode(form: types {operand form} );
    { Walk and generate code for "movelit".  This only differs from
      a normal litopnode in that we always emit zero as the reference
      count when language is Pascal.
    }

      begin
        walkvalue(l, lkey, targetkey);
        mapkey;
          genpseudo(map[movelit, form], len, key, 0, 0, lkey, r, targetkey);
      end {movelitnode} ;


    procedure mulintnode(form: types {operand type} );

{ Walk and generate code for a multiply operation.
}

      var
        oldtarget: keyindex; {target key for root node}


      begin
        oldtarget := targetkey;
        walkboth;
        genpseudo(map[mulop, form], len, key, refcount, copycount, lkey, rkey,
                  oldtarget);
      end {mulintnode} ;


    procedure divintnode(op: operator; {divop or stddivop}
                         form: types {operand type} );

{ Walk and generate code for an integer divide operation.
}

      var
        oldtarget: keyindex; {target key for root node}


      begin
        oldtarget := targetkey;
        walkboth;
        genpseudo(map[op, form], len, key, refcount, copycount, lkey, rkey,
                  oldtarget);
      end {divintnode} ;


    procedure unaryaddrnode(op: operator {root operator} );

{ Walk and generate code for a unary operator which generates an
  At the moment, the only ones are "indrop" and "filebufindrop".  The form
  and length are implicit in the operation.
}


      begin
        walknode(l, lkey, targetkey, true);
        mapkey;
        genpseudo(map[op, ints], len, key, refcount, copycount, lkey, 0,
                  targetkey);
      end {unaryaddrnode} ;


    procedure unarynode(op: operator; {root operation}
                        form: types {operand type} );

{ Walk and generate code for a unary operator.  Only the left operand
  is significant.
}


      begin
        walkvalue(l, lkey, targetkey);
        mapkey;
        genpseudo(map[op, form], len, key, refcount, copycount, lkey, 0,
                  targetkey);
      end {unarynode} ;


    procedure castnode(op: operator; {root operation}
                       form: types {operand type} );

{ Walk and generate code for a cast operator.  The left operand contains
  the value being cast while the right is a flag for an unsigned result.
}


      begin {castnode};
        walkvalue(l, lkey, targetkey);
        mapkey;
        genpseudo(map[op, form], len, key, refcount, copycount, lkey, r,
                  targetkey);
      end {castnode};


    procedure groupnode;

{ This is exactly like a unary node except that it generates no
  code itself.  This is for the unary "+", which is used only to
  group operands.
}


      begin
        walknode(l, lkey, targetkey, true);
        key := lkey;
      end;


    procedure setbinfilenode;

{ Walk and generate code for setbinfile operator.  Only the left operand
  is significant and must be prewalked to pull out odd nested function
  calls, believe it or not!
}


      begin
        shortvisit(l, true);
        walkvalue(l, lkey, targetkey);
        mapkey;
        genpseudo(setbinfile, len, key, refcount, copycount, lkey, 0,
                  targetkey);
      end {unarynode} ;


    procedure unmappedunarynode(op: operator; {root operation}
                                form: types {operand type} );

{ Walk and generate code for a unary operator that does not need its own key.
  Same as unarynode, except no mapkey.  Only the left operand is significant.
}


      begin {unmappedunarynode}
        walkvalue(l, lkey, targetkey);
        genpseudo(map[op, form], len, 0, 0, 0, lkey, 0, targetkey);
      end {unmappedunarynode} ;


    procedure copystacknode;

{ Process special stack copying operator.  Different, in that we walk
  this operator in a prefix rather than postfix fashion, to guarantee
  that the operator is the first thing emitted in the expression stream
  requiring it.  This operator only occurs within I/O parameter lists
  and is used to copy the explicit file parameter, if it exists.
}


      begin
        walkvalue(l, key, targetkey);
        if len <> 0 then genpseudo(makeroom, len, 0, 0, 0, 0, 0, 0);
        genpseudo(copystack, 0, 0, 0, 0, 0, 0, 0);
      end {copystacknode} ;


    procedure checknode(op: operator {root operator} );

{ Walk and generate code for a rangecheck operation.  This is similar
  to a unary operator except two additional range operands are in
  oprnds[2] and oprnds[3].
}

      var
        low, high: integer; {range limits}
        lowkey, highkey: keyindex; {range limits if expressions}
        exprlimit: boolean; {the limits are expresions}


      begin
        exprlimit := rootp^.nodeoprnd[2];
        low := rootp^.oprnds[2];
        high := rootp^.oprnds[3];
        walkvalue(l, lkey, 0);
        if exprlimit then
          begin
          walkvalue(low, lowkey, 0);
          walkvalue(high, highkey, 0);
          low := lowkey;
          high := highkey;
          end;
        mapkey;
        genpseudo(map[op, ints], len, key, refcount, copycount, lkey, low,
                  high);
      end {checknode} ;


    procedure movenode(op: operator; {root operator}
                       form: types {operand type} );

{ Walk and generate code for a "moveop". This is a simple binary operator
  except that the left operand is always walked before the right,
  and the left key is the target for the right operands.
}

      var
        size: nodeindex; {size of this move if cmoveop}
        skey: keyindex; {key for size if cmoveop}


      begin
        size := rootp^.oprnds[3];
        walknode(l, lkey, 0, true);
        walkvalue(r, rkey, lkey);
        if op = cmoveop then walkvalue(size, skey, 0)
        else skey := 0;
        mapkey;
          genpseudo(map[op, form], len, key, 0, 0, lkey, rkey, skey);
      end {movenode} ;


    procedure literalnode(op: operator {root operator} );

{ Generate pseudocode for a literal.  Here all operands are either part
  of the literal or pointers into the string area.
}


      begin
        mapkey;
        with rootp^ do
          begin
          genpseudo(map[op, ints], len, key, refcount, copycount, oprnds[1],
                    oprnds[2], oprnds[3]);
          if op = fptrop then
            if newtravrsinterface then
              sharedPtr^.new_proctable[oprnds[1] div (pts + 1)]^[oprnds[1] mod (pts +
               1)].referenced := true
            else sharedPtr^.proctable[oprnds[1]].referenced := true;
          end;
      end {literalnode} ;


    procedure crealnode;

{ Generate a series of "doreal" pseudoops containing a real number split
  into integers.  The most significant part is put out first, and a piece
  count is transmitted along with the data.  Note that the code generator
  depends on these being in a sequence with no intervening operators.
}


      begin {crealnode}
        mapkey;
        with rootp^ do
          genrealop(doreal, len, key, refcount, copycount, realvalue);
      end; {crealnode}


    procedure realnode;

{ Generate a series of "doreal" pseudoops containing a real number split
  into integers.  The most significant part is put out first, and a piece
  count is transmitted along with the data.  Note that the code generator
  depends on these being in a sequence with no intervening operators.
}

      var
        piece: 0..maxrealwords; {piece count}
        l: addressrange; {length of node}
        refc, copy: refcountrange; {ref and copy counts}
        nextpiece: nodeindex; {next piece being generated}
        nextp: nodeptr; {access to next piece to generate}


      begin
        mapkey;
        with rootp^ do
          begin
          l := len;
          refc := refcount;
          copy := copycount;
          end;
        piece := 1;
        nextp := rootp;
        repeat
          with nextp^ do
            begin
            genpseudo(doreal, l, key, refc, copy, oprnds[1], oprnds[2], piece);
            action := revisit;
            nextpiece := oprnds[3];
            end;
          piece := piece + 1;
          if nextpiece <> 0 then
            nextp := ref(bignodetable[nextpiece]);
        until nextpiece = 0;
      end; {realnode}


    procedure ownnode;

{ Walk and generate code for a "ownop".  This passes globalsize as
  an offset to future indices off level 0.  A first-class, but should-work
  kludge, easier than defining a new magic level.
}


      begin {ownnode}
        mapkey;
        genpseudo(doown, sharedPtr^.ptrsize, key, refcount, copycount, 0, 0, 0);
        if newtravrsinterface then
          sharedPtr^.new_proctable[sharedPtr^.blockref div (pts + 1)]^[sharedPtr^.blockref mod (pts +
           1)].ownused := true
        else sharedPtr^.proctable[sharedPtr^.blockref].ownused := true;
      end {ownnode} ;


    procedure extnode;

{ Generate code for a "extop", which just passes through the index into the
  ext table.  Note: for the 8086 this should probably be split into
  "seg" and "offset" portions.  This is left as an exercise for the
  reader.
}


      begin
        with rootp^ do
          begin
          mapkey;
          genpseudo(doext, sharedPtr^.ptrsize, key, refcount, copycount, oprnds[1], 0, 0);
          end;
      end; {extnode}


    procedure originsegnode(o: pseudoop);

{ Walk and generate code for an "originop" or "segop".  This operation
  establishes addressing for an absolute address.
}


      begin {originsegnode}
        with rootp^ do
          begin
          mapkey;
          genpseudo(o, sharedPtr^.ptrsize, key, refcount, copycount, oprnds[1], 0, 0);
          end;
      end {originsegnode} ;


    procedure levnode;

{ Walk and generate code for a "levop".  This operation establishes
  addressing for a lex level.  It may or may not have an operand tree
  in the third operand.
}


      begin
        with rootp^ do
          begin
          if (oprnds[1] = 0) or (oprnds[1] = level) then rkey := 0
          else walknode(oprnds[3], rkey, 0, true);
          mapkey;
          genpseudo(dolevel, sharedPtr^.ptrsize, key, refcount, copycount, oprnds[1],
                    oprnds[2], rkey);
          end;
      end {levnode} ;


    procedure callnode(op: operator);

{ Walk and generate code for a procedure call.  The right operand is
  the parameter list, and the call pseudocode does not further use them.

  A "shortvisit" is done prior to evaluating the parameters so that any
  temporaries will be left on the stack before the call setup is done.
  This avoids conflicts with the use of the stack for parameters.
}

      var
        p: proctableindex; {temp for proc name}

      begin
        shortvisit(r, false);
        walknode(r, rkey, 0, true);
        mapkey;
        rootp := ref(bignodetable[root]) ;
        if op = unscall then
          genpseudo(unscallroutine, len, key, refcount, copycount,
                    rootp^.oprnds[1], rootp^.oprnds[3], - ord(rootp^.form))
        else
          genpseudo(callroutine, len, key, refcount, copycount,
                    rootp^.oprnds[1], rootp^.oprnds[3], - ord(rootp^.form));
        p := rootp^.oprnds[1];
        if newtravrsinterface then
          sharedPtr^.new_proctable[p div (pts + 1)]^[p mod (pts + 1)].referenced := true
        else sharedPtr^.proctable[p].referenced := true;
        clearkeys;
      end {callnode} ;


    procedure callparamnode(op: operator);

{ Walk and generate code for a call to a parameter procedure.  This
  is similar to "callnode" except that the left operand evaluates to
  the procedure descriptor.
}


      begin {callparamnode}
        walknode(l, lkey, 0, true);
        shortvisit(r, false);
        walknode(r, rkey, 0, true);
        mapkey;
        rootp := ref(bignodetable[root]);
        if op = unscallparam then
          genpseudo(unscallroutine, len, key, refcount, copycount, lkey,
                    rootp^.oprnds[3], ord(rootp^.form))
        else
          genpseudo(callroutine, len, key, refcount, copycount, lkey,
                    rootp^.oprnds[3], ord(rootp^.form));
        clearkeys;
      end {callparamnode} ;


    procedure linkednode(op: operator; {root operator}
                         form: types {operand type} );

{ Process the file variable setup operator for read/write procedure.
  Similar to "stacknode" except no stacktarget is generated.
}


      begin
        walknode(l, lkey, 0, true);
        walknode(r, rkey, key, true);
        mapkey;
        genpseudo(map[op, form], len, key, refcount, copycount, rkey, 0, 0);
      end {linkednode} ;


    procedure pushfinalnode;

{ Walk and generate code for the final value of a for statement.  This
  generates a stack target to hold the value, then generates the expression,
  then the push to save the value.
}


      begin
        mapkey;
        genpseudo(stacktarget, len, key, refcount, copycount, 0, 0, 0);
        walkvalue(l, lkey, key);
        genpseudo(pshint, len, key, refcount, copycount, lkey, 0, 0);
      end {pushfinalnode} ;


    procedure pushprocnode;

{ Push a procedure descriptor on the stack.  This is used to generate
  an actual procedure parameter.
}

      var
        third: proctableindex; {third root operand (procedure number)}


      begin
        third := rootp^.oprnds[3];
        walknode(l, lkey, 0, true);
        mapkey;
        genpseudo(stacktarget, len, key, refcount, copycount, 0, 0, 0);
        walknode(r, rkey, 0, true);
        genpseudo(pshproc, len, key, 0, 0, rkey, third, 0);
        if newtravrsinterface then
          sharedPtr^.new_proctable[third div (pts + 1)]^[third mod (pts +
           1)].referenced := true
        else sharedPtr^.proctable[third].referenced := true;
      end {pushprocnode} ;


    procedure pushcvaluenode(form: types);

{ Push an array value on the stack for a value conformant array parameter.
}


      begin
        walkvalue(l, lkey, targetkey);
        mapkey;
        genpseudo(stacktarget, len, key, refcount, copycount, 0, 0, 0);
        genpseudo(map[pushcvalue, form], len, key, refcount, copycount, lkey, 0,
                  0);
      end; {pushcvaluenode}


    procedure pushretnode;

{ Walk a node which "pushes" the return address of a structure.
}


      begin
        walknode(l, lkey, 0, true);
        mapkey;
        genpseudo(ptrtemp, len, key, refcount, copycount, 0, 0, - 2);
        walkvalue(r, rkey, key);
        genpseudo(map[pushret, ptrs], len, key, 0, 0, rkey, 0, 0);
      end; {pushretnode}


    procedure stacknode(op: operator; {root operator}
                        form: types {operand form} );

{ Walk and generate code for a node which pushes a value on the stack.
  Left operand is the link to other parameters, right operand is the
  value to be pushed.
}


      begin {stacknode}
        walknode(l, lkey, 0, true);
        mapkey;
        genpseudo(stacktarget, len, key, refcount, copycount, 0, 0, 0);
        if op in [pushlitvalue, pushfptr] then
          genpseudo(map[op, form], len, key, 0, 0, r, 0, 0)
        else
          begin
          walkvalue(r, rkey, key);
          genpseudo(map[op, form], len, key, 0, 0, rkey, 0, 0);
          end;

        clearkeys;
      end {stacknode} ;


    procedure pushaddrnode(op: operator;
                           form: types);

{ Walk and generate code for a node which pushes a value on the stack.
  Left operand is the link to other parameters, right operand is the
  address to be pushed.
}

      var
        rptr: nodeptr; {point to right operand}
        walkfirst: boolean; {set true if we must walk operand before emitting
                             stacktarget}


      begin {pushaddrnode}
        walknode(l, lkey, 0, true);
        rptr := ref(bignodetable[r]) ;
        walkfirst := (rptr^.op in
                     [copystackop, call, callparam, unscall, unscallparam]) or
                     (form = strings);
        if walkfirst then walkvalue(r, rkey, key);
        mapkey;
        genpseudo(stacktarget, len, key, refcount, copycount, 0, 0, 0);
        if not walkfirst then walkvalue(r, rkey, key);
        genpseudo(map[op, form], len, key, 0, 0, rkey, 0, 0);
        clearkeys;
      end {pushaddrnode} ;


    procedure dummyargnode(op: operator;
                           form: types);

{ Walk and generate code for a dummy argument node.  Left operand is the link
  to other dummy argument nodes, right operand is the address of the arg.
}


      begin
        walknode(l, lkey, 0, true);
        walkvalue(r, rkey, 0);
        mapkey;
        genpseudo(map[op, form], len, key, 0, 0, rkey, 0, 0);
        clearkeys;
      end {dummyargnode} ;




    procedure seteltnode;

{ Walk and generate code for a single set element. This is not a
  true triple, but sets the value into a previously defined set target.
  This approach is needed because there are an unknown number of
  operators applied to a given target set.  Note that the same pseudo-
  code operator is used for both single and paired set elements.
}


      begin
        walknode(l, lkey, targetkey, true);
        walkvalue(r, rkey, 0);
        genpseudo(setinsert, len, 0, 0, 0, rkey, 0, targetkey);
        clearkeys;
      end {seteltnode} ;


    procedure setpairnode;

{ Walk and generate code for a set pair element.  This is very similar
  to the previous procedure.
}


      begin
        walknode(l, lkey, targetkey, true);
        walkvalue(r, lkey, 0);
        walkvalue(rootp^.oprnds[3], rkey, 0);
        genpseudo(setinsert, len, 0, 0, 0, lkey, rkey, targetkey);
        clearkeys;
      end {setpairnode} ;


    procedure bldsetnode;

{ This operator defines a set for use by the set insert operators.
  The right node defines the set const, the left has the inserts.
}


      begin
        unnestsets(l);
        walknode(r, rkey, 0, true);
        mapkey;
        if walkdepth > 2 then targetkey := 0;
        genpseudo(doset, len, key, refcount, copycount, rkey, 0, targetkey);
        walknode(l, lkey, key, true);
        clearkeys;
      end {bldsetnode} ;


    procedure wrnode;

{ Walk and generate code for a write operator.  This is a standard unary
  operator except that the operand has a shortvisit first to make sure
  that any common expressions are put on the stack before the write
  operand.
}


      begin {wrnode}
        shortvisit(l, false);
        refcount := refcount - 1;
        unarynode(wr, rootp^.form);
        clearkeys;
      end {wrnode} ;


    procedure rdnode;

{ Walk and generate code for a read operator.  This is similar
  to a write node.
}


      begin
        shortvisit(l, false);
        refcount := refcount - 1;
        if rootp^.form = arrays then unarynode(rd, arrays)
        else
          begin
          walknode(l, lkey, 0, true);
          walknode(r, rkey, 0, true);
          mapkey;
          rootp := ref(bignodetable[root]);
          genpseudo(map[rd, rootp^.form], len, key, refcount, copycount, rkey,
                    0, 0);
          end;
        clearkeys;
      end {rdnode} ;


    procedure reservenode;

{ Walk and generate a reserrve stack node.  The only operand is the
  length of the function result
}


      begin
        mapkey;
        with rootp^ do
          genpseudo(makeroom, oprnds[1], key, 0, 0, oprnds[2], oprnds[3], 0);
      end {reservenode} ;


    procedure tempnode;

{ Walk and generate code for a known register temporary.  This is
  primarily used for specifying the registers for return values.
  The index, which is in oprnds[1], is negated and passed in the
  third operand.  It is interpreted by the code generator in a
  machine-dependent manner.
}


      begin
        mapkey;
        with rootp^ do
              genpseudo(map[op, form], len, key, refcount, copycount, 0, 0,
                        - oprnds[1]);
      end; {tempnode}


    procedure varnode(psop: pseudoop {pseudo op to generate} );

{ Walk and generate code for a variable or unsigned variable.  The
  level access is in operand three, while operands 1 and 2 are the
  level and displacement and are ignored as far as code goes.
}

      var
        threekey: keyindex; {key for level access tree}


      begin
        walknode(rootp^.oprnds[3], threekey, 0, true);
        mapkey;
        genpseudo(psop, len, key, refcount, copycount, threekey, 0, 0);
      end {varnode} ;


    procedure sysfnnode(op: operator; {root operator}
                        form: types {result form} );

{ Walk and generate code for a system function.  This is a unary node
  with the argument receiving a shortvisit to get common expressions on
  the stack prior to the argument.  The function index is in operand 1.
  Note that such functions may change type, in which case targeting is
  not applicable.
}

      var
        rp: nodeptr; {used to access right operand}


      begin
        shortvisit(r, false);

        if not (sharedPtr^.switcheverplus[fpc68881] and (loophole(standardids,
                                                       rootp^.oprnds[1]) in
           [facosid, fasinid, fatanid, fatanhid, fcoshid, fetoxm1id, fgetexpid,
           fgetmanid, fintid, flog10id, flog2id, flognp1id, fmodid, fremid,
           fscaleid, fsgldivid, fsglmulid, fsinhid, ftanid, ftanhid, ftentoxid,
           ftwotoxid, fmovecrid, absid, sqrid, sinid, cosid, expid, lnid,
           sqrtid, arctanid, truncid, roundid, snglid, dblid, acosid, asinid,
           tanid, coshid, sinid, tanhid, log10id, fabsid, labsid, sinhid,
           logid])) then
          begin
          rp := ref(bignodetable[r]);
          if form <> rp^.form then targetkey := 0;
          end;

        walkvalue(r, rkey, 0);
        mapkey;
        genpseudo(map[op, form], len, key, refcount, copycount, rkey,
                  rootp^.oprnds[1], targetkey);

      end {sysfnnode} ;


    procedure defforindexnode(notforlit: boolean {intl val is expr} );

{ Walk and generate code for a for index node.  The target field of the
  emitted pseudoop tells the code generator if a memory copy must be kept.

  This node contains the initial value expression (or literal) in operand 3,
  and if the initial value is not a literal, this expression is walked.
}

      var
        initialkey, varkey: keyindex; {initial expr key }
        initialvalue: integer; { first operand for pseudo-op}
        varp: nodeptr; {point to the defined variable}


      begin {defforindexnode}
        with rootp^ do
          begin

          walkvalue(oprnds[2], varkey, 0);

          if notforlit then
            begin
            walknode(oprnds[3], initialkey, 0, false {already decremented} );
            initialvalue := initialkey;
            end
          else initialvalue := oprnds[3];

          mapkey;

          genpseudo(map[op, ints], len, key, refcount, copycount, initialvalue,
                    varkey, ord((oprnds[1] = 0) or nowdebugging or nowwalking));

          end;
      end {defforindexnode} ;


{ Walk a conditional expression node.
  We assign a temp for the value, then walk the two sides, moving
  each to the temp.  The result is the temp.
}


    procedure questnode;

{ The condition is the first operand, while the two expressions are
  the second and third operands.
}

      var
        oldinv: boolean; {local save for "inverted"}
        oldt, oldf: integer; {local saves for "truelabel", "falselabel"}
        oldtused, oldfused: boolean; {local saves for "trueused", "falseused"}
        tlabel, flabel, jlabel: integer; {new labels for converting to value}
        k: nodeindex; {new key for building value}
        tk: integer; {temp for searching list of nodes}
        targ: nodeindex; {temp target}
        cond: nodeindex; {the condition expression}
        p: nodeptr; {for access to left and right nodes}
        form: types; {form for this operation}
        oldclearok: boolean; {old value of oktoclear}
        val_used: boolean; {the value is used}
        next: integer; {for tracing through comma ops}


      begin
        oldclearok := oktoclear;
        oktoclear := false;
        cond := l; {first get the names right}
        l := r;
        r := rootp^.oprnds[3];
        val_used := rootp^.refcount > 0;
        form := rootp^.form;

        if not val_used then
          begin
          increfcount(l, false, - 1);
          increfcount(r, false, - 1);
          end;

        oldinv := inverted;
        oldt := truelabel;
        oldf := falselabel;
        oldtused := trueused;
        oldfused := falseused;
        tlabel := newlabel;
        flabel := newlabel;
        jlabel := newlabel;
        if (targetkey <> 0) and (keytable[targetkey] <> 0) and
           targetpresent(root) then
          targetkey := 0;
        if val_used then
          begin
          k := newkey;
          context[contextsp].high := k;
          keytable[k] := 0;
          genpseudo(createtemp, len, k, 3, 0, ord(form), 0, targetkey);
          end;
        walkboolean(cond, key, tlabel, flabel);
        definelabel(tlabel);
        targ := k;
        if val_used then
          begin
          walkvalue(l, lkey, targ);
          tk := newkey;
          context[contextsp].high := tk;
          keytable[tk] := 0;
          genpseudo(map[moveop, form], len, tk, 0, 0, k, lkey, k);
          end
        else walknode(l, lkey, 0, false);
        genpseudo(jump, 0, 0, 0, 0, jlabel, 0, 0);
        definelabel(flabel);
        targ := k;
        if val_used then
          begin
          walkvalue(r, rkey, targ);
          tk := newkey;
          context[contextsp].high := tk;
          keytable[tk] := 0;
          genpseudo(map[moveop, form], len, tk, 0, 0, k, rkey, k);
          end
        else walknode(r, rkey, 0, false);
        definelabel(jlabel);
        if val_used then
          begin
          mapkey;
          genpseudo(jointemp, len, key, refcount, copycount, k, ord(form), 0);
          end;
        inverted := oldinv;
        truelabel := oldt;
        falselabel := oldf;
        trueused := oldtused;
        falseused := oldfused;
        oktoclear := oldclearok;
      end; {questnode}


{ Short Circuit Boolean Evaluation
  The following three routines handle short circuit evaluation of
  boolean expressions.  This takes advantage of the fact that it is
  frequently possible to terminate evaluation of a boolean expression
  as soon as the value of one of the operands is known.  For instance,
  if the first operand of an "and" operation is false, the entire expression
  is false and there is no need to evaluate the second half.

  This has the added advantage in a machine with condition codes that
  the condition code need not be converted to a boolean value, since the
  condition code is normally checked directly by conditional jumps.

  Short circuit evaluation is implemented using three global variables,
  "truelabel", which is the label to use if the expression is true,
  "falselabel", similar for the expression false, and "inverted", which
  indicates that a "not" has been walked and the condition is inverted.
  Since boolean expressions can be nested, these global variables are
  frequently saved and restored by the tree walking routines.
}


    procedure shortand;

{ Walk and generate code for a boolean "and", using shortcircuit
  evaluation.  In this case, control passes to the falselabel if
  the left operand is false, and to the code for the right operand
  if it is true.  Falselabel remains constant for the evaluation of
  the and, while truelabel is changed for the left operand.
}

      var
        nextlabel: labelrange; {label for right operand eval}
        t: labelrange; {local storage for truelabel}
        oldinv: boolean; {local storage for inverted}
        oldused: boolean; {local value for "trueused"}


      begin
        nextlabel := newlabel;
        t := truelabel;
        truelabel := nextlabel;
        oldused := trueused;
        trueused := false;
        oldinv := inverted;
        shortvisit(r, false);
        walknode(l, lkey, 0, true);
        if inverted then genpseudo(jumpt, 0, 0, 0, 0, falselabel, lkey, 0)
        else genpseudo(jumpf, 0, 0, 0, 0, falselabel, lkey, 0);
        inverted := oldinv;
        truelabel := t;
        if trueused then definelabel(nextlabel);
        falseused := true;
        trueused := oldused;
        walknode(r, key, 0, true);
      end {shortand} ;


    procedure shortor;

{ Walk and generate code for a boolean "or" using shortcircuit
  evaluation.  In this case, control passes to the truelabel if the
  left operand is true, and to the evaluation of the right operand
  if it is false.  Truelabel remains constant for the evaluation of
  the or, while falselabel is changed for the left operand.
}

      var
        nextlabel: labelrange; {label for right operand eval}
        f: labelrange; {local storage for falselabel}
        oldinv: boolean; {local storage for inverted}
        oldused: boolean; {local value for falseused}


      begin
        nextlabel := newlabel;
        f := falselabel;
        falselabel := nextlabel;
        oldused := falseused;
        falseused := false;
        oldinv := inverted;
        shortvisit(r, false);
        walknode(l, lkey, 0, true);
        if inverted then genpseudo(jumpf, 0, 0, 0, 0, truelabel, lkey, 0)
        else genpseudo(jumpt, 0, 0, 0, 0, truelabel, lkey, 0);
        inverted := oldinv;
        if falseused then definelabel(nextlabel);
        falseused := oldused;
        trueused := true;
        falselabel := f;
        walknode(r, key, 0, true);
      end {shortor} ;


    procedure shortnot;

{ Walk and generate code for a boolean "not", using shortcircuit
  evaluation.  This simply reverses "truelabel" and "falselabel"
  while the operand is being evaluated, then complements "inverted"
  to invert the final condition.
}

      var
        t: labelrange; {temp for inverting labels}
        b: boolean; {temp for inverting used variables}


      begin
        t := truelabel;
        truelabel := falselabel;
        falselabel := t;
        b := trueused;
        trueused := falseused;
        falseused := b;
        walknode(l, key, 0, true);
        t := truelabel;
        truelabel := falselabel;
        falselabel := t;
        b := trueused;
        trueused := falseused;
        falseused := b;
        inverted := not inverted;
      end {shortnot} ;



    begin {visitnode}
      walkdepth := walkdepth + 1;
      lkey := 0;
      rkey := 0;
      key := 0;
      rootp := ref(bignodetable[root]);
      with rootp^ do
        begin
        l := oprnds[1];
        r := oprnds[2];
        case op of
          indxchkop, cindxchkop, rangechkop, forupchkop, fordnchkop,
          forerrchkop, congruchkop:
            checknode(op);
          call: callnode(op);
          callparam: callparamnode(op);
          unscall: callnode(op);
          unscallparam: callparamnode(op);
          reserve: reservenode;
          pushaddr, pushstraddr: pushaddrnode(op, form);
          bldfmt: stacknode(op, none);
          pushproc: pushprocnode;
          pushfinal: pushfinalnode;
          pushvalue, pushlitvalue, pushfptr: stacknode(op, form);
          pushcvalue: pushcvaluenode(form);
          pushret: pushretnode;
          sysfn: sysfnnode(op, form);
          rd: rdnode;
          wr: wrnode;
          fptrop, ptrop, intop, structop, jumpvfuncop: literalnode(op);
          dummyargop: dummyargnode(op, form);
          realop, doubleop: realnode;
          ownop: ownnode;
          extop: extnode;
          originop: originsegnode(doorigin);
          segop: originsegnode(doseg);
          levop: levnode;
          varop: varnode(dovar);
          unsvarop: varnode(dounsvar);
          groupop: groupnode;
          tempop: tempnode;
          moveop, cmoveop, returnop: movenode(op, form);
          andop:
            if relation then shortand
            else binarynode(op, form);
          orop:
            if relation then shortor
            else binarynode(op, form);
          notop:
            if relation then shortnot
            else unarynode(op, form);
          modop, kwoop, stdmodop, {new and undefined for other than ints}
          divop, stddivop:
            if form = ints then divintnode(op, form)
            else binarynode(op, form);
          mulop:
            if form = ints then mulintnode(form)
            else binarynode(mulop, form);
          aindxop, paindxop, inop: orderednode(op, form);
          plusop, minusop, slashop, shiftlop, eqop, neqop, lssop, gtrop, leqop,
          geqop, xorop, shiftrop, dummyarg2op:
            binarynode(op, form);
          openarrayop: openarraynode;
          float, float1, chrstrop, chrstrop1, arraystrop, arraystrop1,
          float_double, real_to_dbl, dbl_to_real, castfptrop, castintop,
          castptrop, castrealop:
            begin
            if targetopsys <> vms then targetkey := 0;
            castnode(op, form);
            end;
          indrop, filebufindrop: unaryaddrnode(op);
          movelit: movelitnode(form);
          eqlit, neqlit, lsslit, gtrlit, leqlit, geqlit, loopholeop:
            litopnode(op, form);
          incop, decop, addrop, negop, remop, quoop, ptrchkop, definelazyop,
          compop:
            unarynode(op, form);
          setbinfileop: setbinfilenode;
          setfileop, closerangeop: unmappedunarynode(op, form);
          copystackop: copystacknode;
          defforindexop, defunsforindexop: defforindexnode(true);
          defforlitindexop, defunsforlitindexop: defforindexnode(false);
          indxop: indxnode(indx);
          pindxop: indxnode(pindx);
          vindxop, parmop: vindxnode;
          setelt: seteltnode;
          setpair: setpairnode;
          bldset: bldsetnode;
          addeqop, andeqop, muleqop, oreqop, shiftleqop, shiftreqop, subeqop,
          xoreqop:
            reflexivenode(op, form);
          preincop, postincop: incnode(op, form, rootp^.oprnds[3]);
          diveqop, modeqop: reflexdivnodes(op, form);
          commaop: commanode;
          questop: questnode;
          otherwise
            begin
            write('travrs walk error ', ord(op): 3);
            abort(walkerror);
            end;
          end;
        end;
      walkdepth := walkdepth - 1;
    end {visitnode} ;


  procedure copynode;

{ Walk a copy node and generate code to bring this temp into the current
  context.
}

    var
      oldkey: keyindex; {key for common expression}
      rootp: nodeptr; {used to access root node}


    begin
      rootp := ref(bignodetable[root]);
      { hoisting may have removed all the references. check it out }
      if rootp^.refcount <> 0 then
        begin
        walknode(rootp^.oldlink, oldkey, 0, true);
        mapkey;
        if not nowdebugging and (key >= context[contextsp].low) then
          context[contextsp].low := key + 1;
          { there is a kludge here:  we tell the code generator if copy
            was hoisted out of the loop, so that copyaccessx can take it
            into account }
        genpseudo(copyaccess, ord(currentblock^.loophdr), key, refcount,
                  copycount, oldkey, 0, 0);
        end;
    end {copynode} ;


  begin {walknode}
    key := 0;
    while root <> 0 do
      begin
      rootp := ref(bignodetable[root]);
      refcount := rootp^.refcount;
      copycount := rootp^.copycount;
      len := rootp^.len;
      if rootp^.action in [visit, revisit] then
        if rootp^.op < intop then nextroot := rootp^.slink
        else nextroot := 0
      else nextroot := 0;
      with rootp^ do
        case action of
          visit:
            begin
            action := revisit;
            visitnode
            end;
          copy:
            begin
            action := recopy;
            copynode
            end;
          revisit, recopy: mapkey;
          end;
      if counting then
        begin
        rootp := ref(bignodetable[root]);
        with rootp^ do refcount := refcount - 1;
        end;
      root := nextroot;
      end;
  end {walknode} ;
{>>>}
{<<<}
procedure walknodelist (p: nodeindex {start of node chain} );

{ Walk each node in a chain linked by "prelink".  This is used to walk the
  "preconditions" of a basic block, or for initially writing the contents
  of context[1], which contains common and constant nodes.
}

  var
    p1: nodeindex; {used to store prelink during node walking}
    ptr: nodeptr; {used to access a node}
    key: keyindex; {dummy parameter to walknode}


  begin
    while p <> 0 do
      begin
      ptr := ref(bignodetable[p]) ;
      p1 := ptr^.prelink;
      walknode(p, key, 0, false);
      p := p1;
      end;
  end {walknodelist} ;
{>>>}
{<<<}
{ Statement walking routines
  These routines walk the statement tree, inserting labels for control flow
  and walking expressions as needed.
  As the statements are walked, they are disposed of, since they don't
  contribute any common expressions, and need not be kept.
}
procedure walkstmtlist (firststmt: nodeindex {start of statement list} );
{ Walk each statement in a list using "walkstmt", and dispose of the
  statement header afterwards.  All of the real work is done in "walkstmt".
}
  var
    p: nodeptr; { for access to statement node }
    newcontrolstmt: boolean; { used to prevent extra readaccess call }
    s: nodeindex; { local copy of firststmt }

  {<<<}
    procedure walkstmt(stmt: nodeindex {statement to walk} );
  { Walk a single statement.  The actual walking is done by statement-specific
    routines which are local to this routine.  The statement routines may
    recursively call "walkstmtlist" to walk nested constructs.
    Fortunately the fields in this statement will not change at this point
    so one call to readaccess, and an assignment to currentstmt covers a
    multitude of readaccess calls!
  }

      var
        expr1key, expr2key: keyindex; {keys for expressions in headers}
        currentstmt: node; { current stmt node }
        p: nodeptr;

  {<<<}
      procedure genstmtbrk;

  { Generate a statement break for the debugger.  This pseudocode informs
    the debugger about a change in statements.
  }


        begin
          if (targetopsys = vms) and (currentstmt.textline < 0) and
             nowdebugging then
            exitStmtno := currentstmt.stmtno
          else if currentstmt.stmtno <> 0 then
            if currentstmt.stmtno <> 0 then
              genpseudo(stmtbrk, currentstmt.srcfileindx, 0, 0, 0,
                        currentstmt.stmtno, abs(currentstmt.textline),
                        ord(controlstmt) + ord(branchstmt) * 2 +
                        ord(targetstmt) * 4);
          controlstmt := false;
          branchstmt := false;
          targetstmt := false;
        end {genstmtbrk} ;
  {>>>}
  {<<<}
      procedure walkuntil;

  { Walk a until statement.  This has a label at the top for repetition,
    and one following the boolean expression for termination.  The context
    is cleared at the start of the loop, since we do not scan the
    loop looking for still valid expressions.  If the boolean expression is
    a constant true, it is replaced with a jump, if a constant false
    it is simply eliminated.
  }


        begin
          { temporarily don't put this out old p2 didn't }
            {
            genstmtbrk;
            }
          with currentstmt do
            begin
            { kludge for constant repeats }
            if expr1 = 0 then
              genpseudo(jump, 0, 0, 0, 0, getlabel(falseblock), level, 0)
            else
              begin
                { looplabel is below any hoisting in the loop which is where
                  we want to go if present. }
              if falseblock^.looplabel = 0 then
                walkboolean(expr1, expr1key, getlabel(trueblock),
                            getlabel(falseblock))
              else
                walkboolean(expr1, expr1key, getlabel(trueblock),
                            falseblock^.looplabel);
              end;
            { safe to check for loop restores now }
            if falseblock^.clearop then
              genpseudo(restoreloop, 0, 0, 0, 0, 0, 0, 0);
            if has_break then genpseudo(pascallabel, 0, 0, 0, 0, 0, 0, 0);
            end;
        end {walkuntil} ;
  {>>>}
  {<<<}
      procedure walkwhileif;

  { Walk a while/if statement.
  }


        begin
          genstmtbrk;
          with currentstmt do
            walkboolean(expr1, expr1key, getlabel(trueblock),
                        getlabel(falseblock));
        end {walkwhile} ;
  {>>>}
  {<<<}
      procedure walkcase;

  { Walk a case statement.  This evaluates the selector expression,
    then generates a casebranch followed by an entry for each
    case label, in numeric order.  This is simply generated by tracing
    the orderedlink of the labels.  Finally each statement in the case
    is generated, proceeded by a label and followed by a jump to the exit
    label.  If the selector is constant, only the specified case is
    actually generated.  Labels and label headers are disposed of as
    they are used.

    This is slightly complicated when the case expression is a relation,
    rather than value-bearing expression.  Rather than trying to generate
    hot-shit code, as only test programs have such constructs which are
    entirely equivalent to an "if" statement, we just force the inefficient
    jump-table path.
  }

        var
          p, p1: nodeindex; {used to trace and dispose of lists}
          default: labelrange; {default label or 1 if is an error}
          errordefault: boolean; {true if default gives an error}
          casekey: keyindex; {key for case expression}
          ptr1, ptr2: nodeptr; { to access nodes }
          currentlabel: labelrange; { current case label for stmt block }
          reskey: keyindex; {result of compare for split cases}
          firstgrouprec: nodeindex; {first split group for the case}
          n: nodeptr; {for access to expression}
          relationcase: boolean; {case expression is a relation}


        procedure genjumptable(firstlab, lastlab: nodeindex; {lab limits}
                               ordered: boolean {this is a contig ordered group}
                               );

  { Generate code for a case jump table.  If there is only one label
    for the table, a direct test for equality plus a jump is used instead
    of the more complicated case.
  }

          var
            fp: nodeptr; {for access to firstlab}
            lp: nodeptr; {for access to lastlab}
            p, p1: nodeptr; {for tracing lists}
            locdefault: labelrange; {label for a local default}
            done: boolean; {loop termination condition}
            thislab: nodeindex; {for tracing the chain of labels}


          begin {genjumptable}
            fp := ref(bignodetable[firstlab]);
            lp := ref(bignodetable[lastlab]);

            if not relationcase and ((fp^.caselabellow = lp^.caselabelhigh) or
               (fp^.caselabellow = fp^.caselabelhigh) and
               (lp^.caselabellow = lp^.caselabelhigh) and
               (fp^.orderedlink = lastlab)) then
              begin
              genpseudo(eqlitint, sharedPtr^.targetintsize, reskey, 1, 0, casekey,
                        fp^.caselabellow, 0);

              genpseudo(jumpt, 0, 0, 0, 0, fp^.stmtlabel, reskey, 0);
              if fp^.caselabellow <> lp^.caselabelhigh then
                begin
                genpseudo(eqlitint, sharedPtr^.targetintsize, reskey, 1, 0, casekey,
                          lp^.caselabelhigh, 0);
                genpseudo(jumpt, 0, 0, 0, 0, lp^.stmtlabel, reskey, 0);
                end;
              if errordefault then genpseudo(caseerr, 0, 0, 0, 0, 0, 0, 0)
              else genpseudo(jump, 0, 0, 0, 0, default, 0, 0);
              end
            else if ordered then
              begin
              locdefault := newlabel;
              genpseudo(lsslitint, sharedPtr^.targetintsize, reskey, 1, 0, casekey,
                        fp^.caselabellow, 0);
              genpseudo(jumpt, 0, 0, 0, 0, locdefault, reskey, 0);
              genpseudo(leqlitint, sharedPtr^.targetintsize, reskey, 1, 0, casekey,
                        lp^.caselabelhigh, 0);
              genpseudo(jumpt, 0, 0, 0, 0, lp^.stmtlabel, reskey, 0);
              definelabel(locdefault);
              if errordefault then genpseudo(caseerr, 0, 0, 0, 0, 0, 0, 0)
              else genpseudo(jump, 0, 0, 0, 0, default, 0, 0);
              end
            else
              begin
              if errordefault then locdefault := newlabel
              else locdefault := default;
              genpseudo(casebranch, locdefault, 0, ord(errordefault), 0,
                        fp^.caselabellow, lp^.caselabelhigh, casekey);
              thislab := firstlab;
              p := fp;
              repeat
                p1 := ref(bignodetable[p^.orderedlink]);
                genpseudo(caseelt, 0, 0, 0, 0, p^.stmtlabel,
                          p^.caselabelhigh - p^.caselabellow + 1, 0);
                done := thislab = lastlab;
                if not done then
                  if p1^.caselabellow - p^.caselabelhigh > 1 then
                    genpseudo(caseelt, 0, 0, 0, 0, locdefault,
                              p1^.caselabellow - p^.caselabelhigh - 1, 0);
                thislab := p^.orderedlink;
                p := p1;
              until done;
              end;
          end; {genjumptable}


        procedure casesplit(first, last: integer {index of split groups} );

  { Generate code for a single split portion of a case statement.  If
    the test is non-terminal, the routine is invoked recursively to
    generate code for the two branches of the tree.  The root of the
    subtree is always taken as the middle of the specified elements.

    Note that numbered elements are located by a linear scan of the
    list on the assumption that most such lists will be short.
  }

          var
            middle: integer; {middle of the tree}
            thisgroup: nodeindex; {middle group}
            lastlabel: labelrange; {label associated with "last" direction branch}
            firstlabel: labelrange; {label associated with "first" direction
                                     branch}
            p, lp, hp: nodeptr; {for access to nodes}


          begin
            middle := (first + last + 1) div 2;
            thisgroup := firstgrouprec;
            p := ref(bignodetable[thisgroup]);
            while p^.groupno <> middle do
              begin
              thisgroup := p^.nextstmt;
              p := ref(bignodetable[thisgroup]);
              end;

            if middle < last then
              begin {there is a right-hand branch}
              hp := ref(bignodetable[p^.highestlabel]);
              hp := ref(bignodetable[hp^.orderedlink]);
              lastlabel := newlabel;
              genpseudo(geqlitint, sharedPtr^.targetintsize, reskey, 1, 0, casekey,
                        hp^.caselabelhigh, 0);
              genpseudo(jumpt, 0, 0, 0, 0, lastlabel, reskey, 0);
              end;
            if middle > first then
              begin {there is a left-hand branch}
              lp := ref(bignodetable[p^.lowestlabel]);
              firstlabel := newlabel;
              genpseudo(lsslitint, sharedPtr^.targetintsize, reskey, 1, 0, casekey,
                        lp^.caselabellow, 0);
              genpseudo(jumpt, 0, 0, 0, 0, firstlabel, reskey, 0);
              end;
            with p^ do genjumptable(lowestlabel, highestlabel, ordered);
            if middle < last then
              begin
              definelabel(lastlabel);
              casesplit(middle + 1, last);
              end;
            if middle > first then
              begin
              definelabel(firstlabel);
              casesplit(first, middle - 1);
              end;
          end; {casesplit}


        begin {walkcase}
          genstmtbrk;
          with currentstmt do
            begin
            errordefault := (casedefptr = nil) and (sharedPtr^.switchcounters[rangecheck] > 0);

            { always need a default label }
            if errordefault then default := newlabel
            else if casedefptr = nil then default := getlabel(joinblock)
            else default := getlabel(casedefptr);

            if errordefault and (elements = 0) then
              genpseudo(caseerr, 0, 0, 0, 0, 0, 0, 0)
            else if elements <> 0 then
              begin
              n := ref(bignodetable[selector]);
              relationcase := n^.relation;
              walkvalue(selector, casekey, 0);
              reskey := newkey;
              firstgrouprec := firstgroup;
              casesplit(1, groupcount);
              end
            end;
        end {walkcase} ;
  {>>>}
  {<<<}
      procedure walkfortop;

  { Walk a for statement.  This is complicated by the
    desire to generate good code for the case when we know that the loop will
    be executed at least once.  In this case, we can put the test at the
    bottom only and avoid a jump.

    This optimization can be done if both limits are constant, and the
    first is less than the second.

    Note too, that the final value is pushed on the stack, so has a shortvisit
    to save common expressions before this.  Also, the for expressions are
    kept around until the end of the loop by walking the nodes with "counting"
    false.  They are then walked with "counting" true at the end of the
    loop.  This generates no code, just fixes reference counts.

    Note that the index variable is defined after the final value.  This
    is a kludge which produced better code on most stack machines.
    Unfortunately, it complicates the generation of for range checks.
  }

        var
          ptr: nodeptr; {used to access index node}
          constinitial, constfinal: boolean; {initial and final const}
          unsigned: boolean; {true if unsigned controlled var}
          initialvalue, finalvalue: integer; {initial and final values}
          checkexists: boolean; {for check is found}
          actualexpr1: nodeindex; {final value minus check (if any)}


        begin {walkfortop}
          genstmtbrk;
          constinitial := false;
          labelnext := false; { genblk labels controlled blk for free }
          with currentstmt do
            begin

            ptr := ref(bignodetable[expr1]);
            if ptr^.op in [forupchkop, fordnchkop, forerrchkop] then
              begin
              checkexists := true;
              actualexpr1 := ptr^.oprnds[1];
              end
            else
              begin
              checkexists := false;
              actualexpr1 := expr1;
              end;

            shortvisit(actualexpr1, false);
            checkconst(actualexpr1, constfinal, finalvalue);
            ptr := ref(bignodetable[expr2]) ;
            if (ptr^.op = defforlitindexop) or
               (ptr^.op = defunsforlitindexop) then
              begin
              constinitial := true;
              initialvalue := ptr^.oprnds[3];
              unsigned := ptr^.op = defunsforlitindexop;
              end
            else walkvalue(ptr^.oprnds[3], expr2key, 0);
            walknode(actualexpr1, expr1key, 0, false);
            if expr1key > expr2key then clearkeys; {reclaim what we can}
            walknode(expr2, expr2key, 0, false);
            if checkexists then walknode(expr1, expr1key, 0, false);

            forsp := forsp + 1;
            with forstack[forsp] do
              begin
              forkey1 := expr1key;
              forkey2 := expr2key;
              if currentstmt.stmtkind = foruphdr then
                begin
                { why does this care about debugging?? }
                if constfinal and constinitial and not nowdebugging and
                   ((initialvalue <= finalvalue) and not (unsigned and
                   (initialvalue < 0) and (finalvalue >= 0)) or unsigned and
                   (initialvalue >= 0) and (finalvalue < 0)) then
                  begin {no chance of a zero trip loop}
                  genpseudo(foruptop, forstepsize, 0, 0, 0, exitlabel(trueblock),
                            0, 0);
                  improved := true;
                  downloop := false;
                  end
                else
                  begin
                  genpseudo(foruptop, forstepsize, 0, 0, 0, exitlabel(trueblock),
                            exitlabel(falseblock), expr1key);
                  improved := false;
                  downloop := false;
                  end;
                end
              else
                begin
                if constfinal and constinitial and not nowdebugging and
                   ((initialvalue >= finalvalue) and not (unsigned and
                   (initialvalue >= 0) and (finalvalue < 0)) or unsigned and
                   (initialvalue < 0) and (finalvalue >= 0)) then
                  begin {no chance of a zero trip loop}
                  genpseudo(fordntop, forstepsize, 0, 0, 0, exitlabel(trueblock),
                            0, 0);
                  improved := true;
                  downloop := true;
                  end
                else
                  begin
                  genpseudo(fordntop, forstepsize, 0, 0, 0, exitlabel(trueblock),
                            exitlabel(falseblock), expr1key);
                  improved := false;
                  downloop := true;
                  end;
                end; { down loop }
              end; {with forstack}
            end; {with currentstmt}
        end {walkfortop} ;
  {>>>}
  {<<<}
  procedure walkforbot;
    { produce the code for the bottom of a forloop.
      Most of the work was done at the top of the loop, this is just
      clean up.
    }

    var
      ptr: nodeptr; { for access to for loop top }


    begin { walkforbot }
      ptr := ref(bignodetable[currentstmt.looptop^.beginstmt]);
      with ptr^, forstack[forsp] do
        begin
        if improved then
          begin
          if downloop then
            genpseudo(fordnimproved, forstepsize, 0, 0, 0,
                      exitlabel(trueblock), exitlabel(falseblock), forkey1)
          else
            genpseudo(forupimproved, forstepsize, 0, 0, 0,
                      exitlabel(trueblock), exitlabel(falseblock), forkey1);
          end
        else
          begin
          if downloop then
            genpseudo(fordnbottom, forstepsize, 0, 0, 0, exitlabel(trueblock),
                      exitlabel(falseblock), forkey1)
          else
            genpseudo(forupbottom, forstepsize, 0, 0, 0, exitlabel(trueblock),
                      exitlabel(falseblock), forkey1);
          end;
          { this is a kludge to prevent the exit block from being labelled
            twice, once by forbottom in genblk and once by normal block
            labeling here.
          }
        falseblock^.blocklabel := 0;
        walknode(expr1, forkey1, 0, true);
        walknode(expr2, forkey2, 0, true);
        clearkeys;
        end; {with}
      forsp := forsp - 1;
    end {walkforbot} ;
  {>>>}
  {<<<}
      procedure walkcforbot;

  { Walk the bottom of a C for statement.  This has a single expression
    then a jump to the top of the loop
  }

        var
          dummykey: keyindex;


        begin
          with currentstmt do
            begin
            walknode(expr1, dummykey, 0, false);
            clearkeys;
            if trueblock^.clearop then
              genpseudo(restoreloop, 0, 0, 0, 0, 0, 0, 0);
            if trueblock^.looplabel = 0 then
              genpseudo(jump, 0, 0, 0, 0, getlabel(trueblock), level, 0)
            else genpseudo(jump, 0, 0, 0, 0, trueblock^.looplabel, level, 0);
            if has_break then genpseudo(pascallabel, 0, 0, 0, 0, 0, 0, 0);
            end;
        end; {walkcforbot}
  {>>>}
  {<<<}
      procedure walkwith;

  { Walk a with statement.  This is very simple since the action is all taken
    care of in the expressions.
  }


        begin
          genstmtbrk;
          with currentstmt do
            begin
            walknode(expr1, expr1key, 0, false);
            end;
        end {walkwith} ;
  {>>>}
  {<<<}
      procedure walksimple;

  { Walk a simple statement (assignment or procedure call).  There is
    nothing to it.
  }


        begin
          genstmtbrk;
          walknode(currentstmt.expr1, expr1key, 0, false);
          clearkeys;
        end {walksimple} ;
  {>>>}
  {<<<}
      procedure walklabel;

  { Generate code for a pascal label
  }


        begin
          { Labels aren't actually stmts.  At least old travrs didn't think so }
          { genstmtbrk; }
          genpseudo(pascallabel, 0, 0, 0, 0, currentstmt.labelno,
                    ord(currentstmt.nonlocalref), 0);
          targetstmt := targetstmt or currentstmt.nonlocalref;
          if currentstmt.nonlocalref then
            sharedPtr^.anynonlocalgotos := true;
        end {walklabel} ;
  {>>>}
  {<<<}
      procedure walkgoto;

  { Generate code for a goto statement.
  }

        var
          ptr: nodeptr;
          p: proctableindex;


        begin {walkgoto}

          ptr := ref(bignodetable[root^.beginstmt]) ;
          p := ptr^.procref;
          if newtravrsinterface then
            branchstmt := currentstmt.labellevel <>
                          sharedPtr^.new_proctable[p div (pts + 1)]^[p mod (pts + 1)].level
          else
            branchstmt := currentstmt.labellevel <> sharedPtr^.proctable[p].level;
          genstmtbrk;
          with currentstmt do
            genpseudo(pascalgoto, 0, 0, 0, 0, labelno, labellevel, 0);
        end {walkgoto} ;
  {>>>}
  {<<<}
      procedure walksyscall;

  { Walk and generate code for a system call.  This is pretty standard, it
    does a shortvisit on the args to generate common subexpressions,
    then walks the args and generates a "sysroutine".  "new" is slightly
    different because it has a length argument along with it.
  }

        var
          ptr: nodeptr; {used to access expr node for new call}
          targetflag: 0..2; {flag to pass the type of number used}


        begin
          genstmtbrk;
          with currentstmt do
            begin
            shortvisit(expr1, false);
            targetflag := 0;
            if (expr2 = ord(valprocid)) or (expr2 = ord(strid)) then
              begin
              ptr := ref(bignodetable[expr1]);
              if expr2 = ord(valprocid) then
                ptr := ref(bignodetable[ptr^.slink]);
              if ptr^.form = reals then targetflag := 1
              else if ptr^.form = doubles then targetflag := 2;
              end;
            walknode(expr1, expr1key, 0, true);
            if expr2 = ord(getid) then
              genpseudo(sysroutine, 0, 0, 0, 0, expr2, expr1key, 0)
            else genpseudo(sysroutine, 0, 0, 0, 0, expr2, 0, targetflag);
            end;
          clearkeys;
        end {walksyscall} ;
  {>>>}
  {<<<}
      procedure walkblk;

  { Walk a block.  First all constant expressions in context[1] are
    generated, then code for the block.
  }

        var
          i: hashindex; {induction var for generating context[1]}


        begin {walkblk}
          for i := 0 to nodehashsize do walknodelist(context[1].opmap[i]);
          genpseudo(blockcode, currentstmt.fileline, 0, 0, 0, regtemps, ptrtemps,
                    realtemps);
          genstmtbrk;
          contextsp := 2;
          overflowdepth := 0;
          with context[2] do
            begin
            high := context[1].high;
            low := high + 1;
            end;
        end {walkblk} ;

  {>>>}
  {<<<}
      procedure walkbrkcont(needstmtbrk: boolean);

  { Walk a break or continue statement.  This just generates a transfer to
    the proper block;
  }


        begin
          if needstmtbrk then genstmtbrk;
          genpseudo(jump, 0, 0, 0, 0, getlabel(currentstmt.targblock), level, 0);
        end; {walkbrkcont}
  {>>>}
  {<<<}
      procedure walkreturn;

  { Walk a return statement.  Just walk the statement and transfer control
    to the exit block (stored in "trueblock");
  }

        var
          dumkey: keyindex; {for fake walk}


        begin
          genstmtbrk;
          with currentstmt do
            begin
            walknode(expr1, dumkey, 0, false);
            clearkeys;
            genpseudo(jump, 0, 0, 0, 0, getlabel(trueblock), 0, 0);
            end;
        end; {walkreturn}
  {>>>}

      begin {walkstmt}

        inverted := false;
        p := ref(bignodetable[stmt])  ;
        currentstmt := p^;
        with currentstmt do
          begin
          case stmtkind of
            blkhdr: walkblk;
            rpthdr, loophdr: genstmtbrk;
            untilhdr: walkuntil;
            whilehdr, ifhdr: walkwhileif;

            whilebothdr, loopbothdr:
              begin
              if currentstmt.looptop^.clearop then
                genpseudo(restoreloop, 0, 0, 0, 0, 0, 0, 0);
                { looplabel is below any hoisting in the loop which is where
                  we want to go if present }
              if currentstmt.looptop^.looplabel = 0 then
                genpseudo(jump, 0, 0, 0, 0, getlabel(currentstmt.looptop), level,
                          0)
              else
                genpseudo(jump, 0, 0, 0, 0, currentstmt.looptop^.looplabel, level,
                          0);
              if has_break then genpseudo(pascallabel, 0, 0, 0, 0, 0, 0, 0);
              end;

            casehdr: walkcase;
            foruphdr, fordnhdr: walkfortop;
            forbothdr: walkforbot;
            withhdr: walkwith;
            simplehdr: walksimple;
            labelhdr: walklabel;
            gotohdr: walkgoto;
            loopbrkhdr: walkbrkcont(true);
            swbrkhdr: walkbrkcont(false);
            cswbrkhdr: walkbrkcont(true);
            loopconthdr: walkbrkcont(true);
            cforhdr: walkwhileif;
            cforbothdr: walkcforbot;
            returnhdr: walkreturn;
            syscallhdr: walksyscall;
            caseerrhdr: genpseudo(caseerr, 0, 0, 0, 0, 0, 0, 0);
            nohdr: { dead statement } ;
            otherwise writeln('ouch!!', ord(stmtkind))
            end;
          end;
      end {walkstmt} ;
  {>>>}

  begin {walkstmtlist}
    controlstmt := true;
    branchstmt := false;
    targetstmt := false;
    while firststmt <> 0 do
      begin
      s := firststmt;
      p := ref(bignodetable[firststmt]);
      firststmt := p^.nextstmt;
      if p^.stmtkind in [rpthdr, whilehdr, foruphdr, fordnhdr, cforhdr] then
        controlstmt := true;
      { do this now to avoid readaccess call }
      newcontrolstmt := not (p^.stmtkind in [withhdr, simplehdr, syscallhdr]);
      walkstmt(s);
      controlstmt := newcontrolstmt;
      end;
  end {walkstmtlist} ;
{>>>}

{<<<}
procedure walk;

{ Walk the tree for a block.  This sets up global variables, emits
  block entry code, and calls "walkstmtlist" to actually walk the block
  code.
}

  var
    blocksize: addressrange;


  begin {walk}
    trueused := false;
    falseused := false;
    oktoclear := true;
    contextsp := 1;
    with context[1] do
      begin
      low := 1;
      high := 0;
      end;
    ptr := ref(bignodetable[root^.beginstmt]);
    with ptr^ do
      begin
      if final_block_size = 0 then blocksize := bs
      else blocksize := final_block_size - ps;
      genpseudo(blockentry, 0, 0, 0, 0, procref, ps, blocksize);
      end;
    { now walk the block in dfo }
    currentblock := root;
    labelnext := true;
    repeat
      oktolabel := labelnext;
      labelnext := true;
      { walk the statements for this block }
      { do the context operations for this block }

      { clear op always signify loops there are deferred }

      with currentblock^ do
        begin
        if restoreop then
          begin
          if saveop then
            begin
            definerestorelabel(0);
            definesavelabel(blocklabel);
            end
          else definerestorelabel(blocklabel);
          if joinop then definejoinlabel(0);
          end
        else if saveop then definesavelabel(blocklabel)
        else if (blocklabel <> 0) and oktolabel then
          begin
          { this prevents stmtblock of forloop from being labelled twice }
          if loophdr then
            begin
            { if block has any hoists label it now }
            if looplabel <> 0 then definelabel(blocklabel);
            end
          else definelabel(blocklabel);
          end;
        if not isdead then walknodelist(precode);

        { label loops as required }
        if loophdr and not isdead then
          begin
          if clearop then
            begin
            { while or repeat stmt, must label it }
            if looplabel <> 0 then defineclearlabel(looplabel)
            else defineclearlabel(getlabel(currentblock))
            end
          else
            begin
            { for loop, label it if not labelled already }
            if looplabel = 0 then definelabel(blocklabel);
            end;
          end;

        if not isdead then
          begin
          if beginstmt <> 0 then
            begin
            walkstmtlist(beginstmt);
            ptr := ref(bignodetable[beginstmt]);
            needjump := not (ptr^.stmtkind in
                        [forbothdr, whilebothdr, untilhdr, cforbothdr, gotohdr,
                        swbrkhdr, loopbrkhdr, loopconthdr]);
            end
          else needjump := true;
          { if the current block only has one successor better jump to it }
          { unless it is next or bottom of a for loop }
          if successor <> nil then
            begin
            if needjump and (successor^.snext = nil) and
               (successor^.suc <> dfolist) and not successor^.suc^.isdead then
              genpseudo(jump, 0, 0, 0, 0, getlabel(successor^.suc), level, 0);
            end;
          end;
        end; {with}
      currentblock := currentblock^.dfolist;
    until currentblock = nil;

    if nowdebugging then
      genpseudo (stmtbrk, 0, 0, 0, 0, 0, 0, ord(controlstmt) + 8);
    genpseudo (blockexit, 0, 0, 0, 0, symbolrecord, 0, 0);

    if travcode then
      begin
      pseudoSharedPtr^.pseudoinst := pseudoSharedPtr^.pseudobuff;
      if emitpseudo then
        codeone; { this allows skipping codeone while debugging }
      emitpseudo := false;
      end;

    clearkeys;
    contextsp := 1;
    clearkeys;

    { dispose of allocated memory }
    repeat
      currentblock := root^.dfolist;
      { dispose of the successor links for this block }
      lnk := root^.successor;
      if root^.bigblock then dispose(root, true)
      else dispose(root, false);
      blockblocks := blockblocks - 1;
      root := currentblock;
      while lnk <> nil do
        begin
        lnk2 := lnk;
        lnk := lnk^.snext;
        dispose(lnk2);
        end;
    until root = nil;
    if blockblocks <> 0 then
      writeln('warning  ', blockblocks: 1, ' blocks not released in block ',
              sharedPtr^.blockref: 1);

  end {walk} ;
{>>>}
{>>>}
{<<<  improve}
{<<<}
procedure assignregs;
{
    Purpose:
      Based on their lifetimes and worth assign local variables to registers

    Inputs:
      Uses global arrays regvars to determine lifetime.

    Outputs:
      Update regvars with register assignments.

    Algorithm:

      For each register type call allocateregs with proper parameters.

    Sideeffects:
      None

    Last Modified: 7/12/85

}

type
  regallocset = set of regalloctype;

var
  reglife: array [reghashindex] of region;
  regioncount: - 1..regtablelimit; { number of active regions - 1 }
  i: reghashindex; { induction var }
  frameneeded: boolean; { does procedure require FP? }

  {<<<}
  function disjoint(var life: region): boolean;
  {
    Purpose:
      determine if the lifetimes of life and reglife are disjoint.


    Inputs:
      life - lifetime region of a local var.

    Outputs:
      true iff lifetimes are disjoint else false.

    Algorithm:


    Sideeffects:
      None

    Last Modified: 7/12/85

  }

    type
      clip = (above, below, right, left);
      clipset = set of clip;

    var
      i: reghashindex; {induction vars }
      code1, code2, code3, code4: clipset; { clipping for rectangle's sides }


    {<<<}
    procedure clipping(lon: nodeindex;
                       fon: fonrange;
                       var clips: clipset);
     { Sutherland's clipping algorithm. See any computer graphics book. }


      begin
        if (lon < life.lonmin) then clips := [left]
        else if (lon > life.lonmax) then clips := [right]
        else clips := [];
        if (fon < life.fonmin) then clips := clips + [below]
        else if (fon > life.fonmax) then clips := clips + [above];
      end;
    {>>>}


    begin {disjoint}
      disjoint := true;
      i := 0;
      while i <= regioncount do
        begin
        with reglife[i] do
          begin
        { in order to be disjoint all 4 lines must be "off screen" where
        one lifetime is the screen. Also cannot be surrounder.
        }
          clipping(lonmin, fonmin, code1);
          clipping(lonmin, fonmax, code2);
          clipping(lonmax, fonmin, code3);
          clipping(lonmax, fonmax, code4);
          { if ( offscreen ) or ( surround ) then ... }
          if ((code1 * code2 = []) or (code1 * code3 = []) or
             (code2 * code4 = []) or (code3 * code4 = [])) or
             ((code1 * code2 = [left]) and (code1 * code3 = [below]) and
             (code2 * code4 = [above]) and (code3 * code4 = [right])) then
            begin
            disjoint := false;
            i := regioncount;
            end;
          i := i + 1;
          end; {with}
        end;
    end {disjoint} ;
  {>>>}
  {<<<}
  procedure allocateregs(maxregs: shortint;
                         acceptable: regallocset;
                         var regcount: shortint);
  {
    Purpose:
      Allocate maxregs to vars in acceptable class.

    Inputs:
      maxregs : number of registers of this type available to allocate.
      acceptable : variable type ok to allocate to this register.

    Outputs:
      regcount : number of registers allocated.

    Algorithm:
        0. Init the register lifetime to empty.
        1. Find the most valuable var that has a disjoint lifetime with
           register. If one exists then assign it to the register and
           add the vars lifetime to the register's lifetime and repeat.

           In order to be interesting, the worth must exceed the cost
           of saving and restoring the register, plus the cost of any
           load.

    Sideeffects:
      none.
  }

    var
      i, j: shortint; {induction vars }
      bestvar: reghashindex; { best var to assign this pass }
      bestworth: shortint; { most useful var with disjoint register life }
      allocated: boolean; { true if a register allocated on this path }
      varalloc: allockind; {kind of allocation}

    begin {allocateregs}
      for i := regcount + 1 to maxregs do
        begin
        regioncount := - 1;
        allocated := false;
        { find a register to assign }
        repeat
          bestworth := 0;
          j := 0;
          while j <= regtablelimit do
            begin
            with regvars[j] do
              begin
              if registercandidate and
                 (worth - 3 * ord(parameter) > bestworth) and
                 (regkind in acceptable) then
                begin
                if disjoint(varlife) then
                  begin
                  bestworth := worth - 3 * ord(parameter);
                  bestvar := j;
                  end;
                end;
              end;
            j := j + 1;
            end;
          if regioncount < 0 then bestworth := max(bestworth - 2, 0);
          if (bestworth > 0) then
            begin
            {found one to allocate }
            allocated := true;
            regvars[bestvar].worth := 0;
            regvars[bestvar].regid := i;
            regioncount := regioncount + 1;
            reglife[regioncount] := regvars[bestvar].varlife;
            { update debug file }
            with regvars[bestvar] do
              if debugrecord <> 0 then
                begin
                case regvars[bestvar].regkind of
                  ptrreg: varalloc := ptrregister;
                  genreg, bytereg: varalloc := genregister;
                  realreg: varalloc := realregister;
                  end;
                dbg_alloc (debugrecord, varalloc, regid)
                end;
            end;
        until bestworth = 0;
        if allocated then
          regcount := regcount + 1;
        end;
    end {allocateregs} ;
  {>>>}

begin
  if sharedPtr^.switcheverplus[tblock] and (sharedPtr^.tblocknum = sharedPtr^.blockref) then
    begin
    { show register lifetimes }
    writeln('  off typ worth lmin lmax fmin fmax');
    for i := 0 to regtablelimit do
      if regvars[i].registercandidate then
        begin
        with regvars[i], varlife do
          writeln(offset: 5, ord(regkind): 3, worth: 7, lonmin: 5, lonmax: 5,
                  fonmin: 5, fonmax: 5);
        end;
    end;

  { assign general registers, Static link comes out of general regs }
  ptrtemps := 0;
  if newtravrsinterface then
    with sharedPtr^.new_proctable[sharedPtr^.blockref div (pts + 1)]^[sharedPtr^.blockref mod (pts + 1)] do
      begin
      if intlevelrefs then ptrtemps := 1;
      if (register_return and not sharedPtr^.switcheverplus[structstatic] and
         (struct_calls or struct_ret)) and
         (sharedPtr^.switcheverplus[debugging] or sharedPtr^.switcheverplus[targdebug]) then
        ptrtemps := ptrtemps + 1;
      end
  else
    with sharedPtr^.proctable[sharedPtr^.blockref] do
      begin
      if intlevelrefs then ptrtemps := 1;
      if (register_return and not sharedPtr^.switcheverplus[structstatic] and
         (struct_calls or struct_ret)) and
         (sharedPtr^.switcheverplus[debugging] or sharedPtr^.switcheverplus[targdebug]) then
        ptrtemps := ptrtemps + 1;
      end;

    { For Versados the debugger/profiler uses one dedicated register.
      If generating 68000 pic and there is an own section, then a
      dedicated register is used here too.  If both are true the
      debugger loses and debugger steps are three instructions long.
    }
  if (targetopsys = vdos) and
     ((sharedPtr^.switcheverplus[pic] and (sharedPtr^.ownsize > 0)) or
      sharedPtr^.switcheverplus[debugging] or sharedPtr^.switcheverplus[profiling]) then
    ptrtemps := ptrtemps + 1;

  allocateregs(assignptrreg, [ptrreg], ptrtemps);
  regtemps := 0;
  allocateregs(assignreg, [genreg], regtemps);
  realtemps := 0;
  if sharedPtr^.switcheverplus[fpc68881] then
    allocateregs(assignrealreg, [realreg], realtemps);

  if sharedPtr^.switcheverplus[tswitch1] and dumpDetails then
    begin
    writeln ('register assignments for block ', sharedPtr^.blockref: 1);
    for i := 0 to regtablelimit do
      with regvars[i], varlife do
        begin
        if regid <> 0 then
          begin
          writeln ('id ', regid: 2, ' typ ', ord(regkind): 1, ' off ', offset:
                   1, ' lon ', lonmin: 1, ' ', lonmax: 1, ' fon ', fonmin: 1,
                   ' ', fonmax: 1);
          end;
        end;
    end;
end;
{>>>}
{<<<}
procedure loops;
{<<<}
{
    Purpose:
      Hoist invariant expressions out of loops.

    Inputs:
      Flow graph

    Outputs:
      Modified flow graph.

    Algorithm:
      The basic blocks are walked in reverse order. Whenever we back in to
      a loop we begin examining all of the expressions within the loop
      to determine if they are invariant. When an expression is determined
      to be invariant it is hooked to the header block of the loop. As
      usual things are more complicated than this sounds. The two major
      complications are common subexpressions shared by two loops and
      the need to insert copy operations so that nested contexts can
      reference the expression that since being hoisted is no longer within
      it's context. The first complication also manages to solve the
      problem for hoisting invariants multiple levels of loops.

      We hoist hoist any expression that is invariant and "safe". Some
      expressions are invariant but may not be safe such as:
      if p <> nil then foo := p^;
      p^ may be invariant but if it is hoisted the a segment fault may
      occur which would not happen if hoisting did not occur. Operators
      are divided into safe and unsafe classes, addition, subtraction are
      safe array subscripting, pointer dereferencing, division are not
      safe. (On machines where overflow traps occur on addition/subtraction
      even they are not safe). Invariant safe expressions are always hoisted,
      Invariant unsafe expressions are only hoisted if the basic block
      containing the expression will execute if the closest loop containing
      it will run if execution happens to reach it.

      As a side effect this hoisting can cause slower execution when
      expressions are hoisted out of loops which rarely if ever execute.
      This is a rare occurrence according to the literature and is
      ignored.

    Sideeffects:
      Many

    Last Modified: 7/3/85

}

{>>>}

  var
    blk: basicblockptr; { for walking blocks }
    ptr: nodeptr; { for access to stmt node }
    nextblk: basicblockptr; { next block to examine }
    anyinvars: boolean; { used for testing purposes }


  procedure examineloop(loopblk, bottomblk: basicblockptr);
{
    Purpose:
      Examine loop for invariant expressions

    Inputs:
      loopblk : ptr of the block describing loophdr of loop to examine.
      bottomblk : ptr to final block in the loop.

    Outputs:
      modified graph

    Algorithm:


    Sideeffects:
      invariants marked.

    Last Modified: 9/9/85

}

    var
      p: nodeindex; { for walking hoist chains }
      ptr, ptr2: nodeptr; { for access to nodes }
      stmt: nodeindex; { current stmt in basic block }
      lasthoist: nodeindex; { index of last invariant hoisted in this loop }
      currenthoist: nodeindex; { index of current invariant from inner loop }
      nexthoist: nodeindex; { index of next invariant from inner loop }
      previoushoist: nodeindex; { index of previous invariant from inner loop }
      current: basicblockptr; { basic block being examined }
      innerloop: basicblockptr; { basic block containing an innerloop }
      secondlevel: boolean; { true if examining expressions that have already
                             been hoisted in some other loop }
      finalwrite: nodeindex; { index of 1st write outside loop's writes }
      temp: addressrange; { for building write list }
      fixnode: nodeindex; { index of node that points to pushfinal }
      newoprnd: nodeindex; { index of pushfinal oprnd }
      finalexpr: nodeindex; { index of for final expression }
      initexpr: nodeindex; { index of for index variable }
      dominating: boolean; { true if current block dominates loopblks exit and
                            loopblk executes }


    procedure definecontext(outerblk, innerblk: basicblockptr);
{
    Purpose:
      Find the context stack of the basicblock "innerblk".

    Inputs:
      outerblk : the basic block defining the outermost context
      innerblk : the basic block we wish to find the context for.

    Outputs:
      none : just side effects

    Algorithm:
      Starting at outerblk, we walk dfolist until we reach innerblock.
      At each saveop we increment the context stack and save the block
      pointer. At each restoreop we decrement the context stack.

    Sideeffects:
      modifies context[1]..context[n] for use by hoistit.

    Last Modified: 11/26/86

}

      var
        overflow: shortint; { depth of context overflow }


      begin {definecontext}
        contextsp := 0;
        overflow := 0;
        context[0].firstblock := outerblk;

        repeat
          if outerblk^.restoreop then
            begin
            if overflow = 0 then contextsp := contextsp - 1
            else overflow := overflow - 1;
            end;
          if outerblk^.saveop then
            begin
            if contextsp = contextdepth then overflow := overflow + 1
            else
              begin
              contextsp := contextsp + 1;
              context[contextsp].firstblock := outerblk;
              end;
            end;
          outerblk := outerblk^.dfolist;
        until outerblk = innerblk^.dfolist;

      end; {definecontext}


    procedure hoistit(expr: nodeindex);
{
    Purpose:
      Link expression into the precode chain of loopblk and mark all of
      the graph below it as hoisted by loopblk.

    Inputs:
      expr : expression to be hoisted.

    Outputs:
      modified graph.

    Algorithm:
      If a copy is present must search the subgraph for the nodes which point
      to copies and make them point directly to the copied expression.

    Sideeffects:
      modified graph.

    Last Modified: 6/27/85

}

      var
        ptr: nodeptr; { for access to node }
        copied: nodeptr; { for building copy node }
        lastcopy: nodeindex; { previous copynode in copy chain }
        refc, copyc: refcountrange; { ref count of hoisted expression }
        newexpr: nodeindex; { the node to hoist if copies needed }
        sp: contextindex; { induction var }


      procedure flood(expr: nodeindex;
                      forceflood: boolean);
{
    Purpose:
      Mark expression rooted in expr as hoisted.

    Inputs:
      expr : index of node to mark as hoisted.

    Outputs:
      modified graph

    Algorithm:
      recursive descent of graph.

    Sideeffects:
      modified graph.

    Last Modified: 7/6/85

}

        var
          i: 1..3; {induction vars }
          ptr: nodeptr; { for node access }
          operands: operandarray; { local copy of oprnd field }
          nodeoperands: nodeoperandarray; { local copy of nodeoprnd field }


        begin {flood}

          ptr := ref(bignodetable[expr]);
          if (ptr^.hoistedby = nil) or forceflood then
            begin
            ptr^.hoistedby := loopblk;
            if ptr^.action = visit then
              begin
              operands := ptr^.oprnds;
              nodeoperands := ptr^.nodeoprnd;
              for i := 1 to 3 do
                begin
                if nodeoperands[i] then flood(operands[i], false);
                end
              end
            else flood(ptr^.oldlink, false);
            end;

        end {flood} ;


      procedure removecopies(depth: contextindex; {depth to which we remove 'em}
                             expr: nodeindex);
{
    Purpose:
      Remove copies in expr which are at least as deep as the target context
      depth to which we will hoist.

    Inputs:
      depth: how deep to go, presumed > 0.
      expr : index of expression graph to search.

    Outputs:
      modified graph

    Algorithm:
      recursive descent of graph.

    Sideeffects:
      modified graph.

    Last Modified: 7/6/85

}

        var
          i: 1..3; {induction vars }
          d: contextindex; { running depth count along a particular oprnd }
          copylink: nodeindex; { running index to copy node's target }
          exprptr: nodeptr; { for access to original node }
          ptr: nodeptr; { for walking copy links }
          mustwrite: boolean; { true if expr changed and must be written }
          operands: operandarray; { local copy of oprnd field }
          nodeoperands: nodeoperandarray; { local copy of nodeoprnd field }


        begin {removecopies}

          exprptr := ref(bignodetable[expr]);

          { should always be a visit node }
          if exprptr^.action = visit then
            begin
            operands := exprptr^.oprnds;
            nodeoperands := exprptr^.nodeoprnd;
            for i := 1 to 3 do
              begin
              if nodeoperands[i] then
                begin
                ptr := ref(bignodetable[operands[i]]);
                if ptr^.action = copy then
                  begin
                  mustwrite := true;
                  blocksin[1].written := true;
                  d := depth;
                  repeat
                    d := d - 1;
                    copylink := ptr^.oldlink;
                    exprptr^.oprnds[i] := copylink;
                    ptr^.refcount := ptr^.refcount - 1;
                    ptr := ref(bignodetable[copylink]);
                    ptr^.copycount := ptr^.copycount - 1;
                  until (d = 0) or (ptr^.action = visit);
                  if d > 0 then removecopies(d, copylink);
                  end
                else removecopies(depth, operands[i]);
                end;
              end; {for}
            end
          else
            begin
            writeln('removecopies bad node found');
            abort(inconsistent);
            end;

        end {removecopies} ;


      procedure onecopy(sp: contextindex; { current context level}
                        c: nodeindex {where to build copy node} );

        { Build one copy access node in chain leading to hoisted expr
        }


        begin {onecopy}

          ptr := ref(bignodetable[c]);
          copied^.copycount := refc;

          with ptr^ do
            begin
            refcount := refc;
            copycount := copyc;
            action := copy;
            oldlink := lastcopy;
            directlink := newexpr;
            hoistedby := loopblk;
            prelink := context[sp].firstblock^.precode;
            context[sp].firstblock^.precode := c;
            end;
          lastcopy := c;
          copied := ptr;
        end {onecopy} ;


      begin {hoistit}
        ptr := ref(bignodetable[expr]);

        { first see if it's been hoisted already or not a true invariant }

        if not ((ptr^.action = visit) and
           (ptr^.op in
           [defforlitindexop, defforindexop, forindexop, endexpr, defunsforlitindexop,
           defunsforindexop])) and (secondlevel or (ptr^.hoistedby = nil)) then
          begin
            { Two complications arise here. First we must walk the expression
              to remove the references to the
              copy operations since now the expression will be higher in the
              graph than the copy. In this case we should also search the
              precode chain for an expression that matches this one otherwise
              we can produce much slower "optimized" code.

              Second if the block being hoisted out of is a nested context
              we must replace the original node with a copy operation.
            }
          if contextsp > 0 then removecopies(contextsp, expr);

            { expr must be hooked to the precode of loopblk. If we are within
              nested context(s) we must build the proper copy chains. We then
              convert the original node to a copy and build a new node as the
              actual expression.
            }
          if contextsp > 0 then
            begin

            { Build a duplicate of expr, this is the node we will hoist }

            if lastnode + contextsp >= tnodetablesize then abort(manynodes);

            lastnode := lastnode + 1;
            newexpr := lastnode;

            copied := ref(bignodetable[newexpr]);

            copied^ := ptr^;
            copied^.prelink := 0;
            lastcopy := newexpr;
            refc := ptr^.refcount;
            copyc := ptr^.copycount;

            for sp := 1 to contextsp - 1 do
              begin
              lastnode := lastnode + 1;
              onecopy(sp, lastnode);
              end;
            onecopy(contextsp, expr);
            expr := newexpr;
            end; {contextsp > 0}

          if lasthoist = 0 then loopblk^.precode := expr
          else
            begin
            ptr := ref(bignodetable[lasthoist]);
            ptr^.prelink := expr;
            end;
          lasthoist := expr;

          { count the number of hoists that occur }
          if dumpFiles then
            begin
            ptr := ref (bignodetable[expr]);
            if not anyinvars then
              anyinvars := true;
            end;
          hoistone := hoistone + 1;
          end;

        { now mark all nodes in expression as hoisted }

        flood(expr, true);
      end; {hoistit}


    function simpleinvar(oprnd: nodeindex; {pushfinal's oprnd}
                         other: nodeindex {deffor... op} ): boolean;

{   Purpose:
      Examine the expression indexed by oprnd and see if it is a simple
      variable which is invariant in the current loop, but is NOT the
      loop variable.

    Inputs:
      oprnd: index of the expression to examine.
      other: index of the deffor operator, for comparison.

    Outputs:
      simplevar: true if oprnd is a simple invariant variable reference.

    Algorithm:
      Examine the writes for the current loop.

    Sideeffects:
      none

    Last Modified: 9/26/86 (Rick)
}

      var
        ptr: nodeptr; { for access to nodes }
        varlev: levelindex; { level of var op }
        off: addressrange; { where in frame of var }
        written: boolean; { true if found on write list }


      begin {simpleinvar}
        simpleinvar := false;
        ptr := ref(bignodetable[oprnd]);
        if ptr^.action = copy then
          begin
          { Point to the real operand }
          oprnd := ptr^.directlink;
          ptr := ref(bignodetable[oprnd]);
          end {copy} ;
        if ((ptr^.op = varop) or (ptr^.op = unsvarop)) and
           not loopblk^.deadlevels[ptr^.oprnds[1]] then
          begin
          varlev := ptr^.oprnds[1];
          off := ptr^.oprnds[2];
            { A simple variable points to an indxop, which points
              to a levop}
          ptr := ref(bignodetable[ptr^.oprnds[3]]);
          if ptr^.op in [indxop, vindxop] then
            begin
            ptr := ref(bignodetable[ptr^.oprnds[1]]);
              { Globalop's and localop's are converted to levop's
                by buildexpr }
            if (ptr^.op = levop) then
              begin
              { First, check to see if this is the loop variable }
              ptr := ref(bignodetable[other]);
              if (level <> varlev) or (ptr^.oprnds[2] <> off) then
                begin
                  { It isn't the loop variable, so now check to see
                    if it's written within the loop }
                p := loopblk^.writes;
                written := false;
                while not written and (p <> 0) and (p <> finalwrite) do
                  begin
                  ptr := ref(bignodetable[p]);
                  if (ptr^.oprnds[1] = varlev) and (ptr^.oprnds[2] = off) then
                    written := true;
                  p := ptr^.looplink;
                  end {while} ;
                simpleinvar := not written;
                end {not loop var} ;
              end {levop} ;
            end {indxop} ;
          end {varop} ;
      end {simpleinvar} ;


    procedure examineexpression(expression: nodeindex;
                                hoistsubtrees: boolean);
      forward;
{
    Purpose:
      Examine the oprnd indexed by expression and find any invariant
      subexpressions it contains and hoist them.

    Inputs:
      expression : index of the expression operand to be examined.
        This expression cannot be hoisted because it is either unsafe
        or not applicable.

      hoistsubtrees: if true, we may hoist any subtrees which are invariant.

    Outputs:
      modified graph.

    Algorithm:
      Examines each operand of the node "expression". For each
      invariant it finds it hoists it. If the expressions has sequential
      expressions connected to it each of those expressions are examined.

    Sideeffects:
      graph is changed.

    Last Modified: 7/22/85

}


    function invariantoprnd(oprnd: nodeindex;
                            var worthit: boolean;
                            hoistsubtrees: boolean): boolean;
{
    Purpose:
      Examine the oprnd indexed by oprnd and see if it is invariant in
      the current loop context.
      And hoistable.

    Inputs:
      oprnd : index of the expression operand to be examined.
      copyfound : true if earlier caller found a copy node in this subgraph.
      hoistsubtrees: true if we should hoist invariant subtrees

    Outputs:
      returns true if oprnd is invariant and can be hoisted.
      copyfound : true if oprnd was a copy node.
      worthit : true if oprnd is invariant and worth ( or legal ) to
                be hoisted.

    Algorithm:
      If oprnd is not hoistable type of operator calls examineexpression
      to search for invariants beneath this operator. Otherwise recursively
      examines each operand of the node "oprnd" if all of it's
      subexpressions are invariant then returns true.

    Sideeffects:
      none.

    Last Modified: 7/22/85

}

      var
        i: 0..contextdepth; {induction var }
        ptr: nodeptr; { for node access }
        operands: operandarray; { local copy of oprnd field }
        nodeoperands: nodeoperandarray; { local copy of nodeoprnd field }
        copyfound: boolean; {true if this node was a copy node}
        musthoist: boolean; {true if we must hoist common subexpression}
        invar: boolean; { true if oprnd is invariant }
        isvar: boolean; { true if op is var/unsvar }
        blockhoist: boolean; {true if intermediate copies block hoisting}
        hoist: array [1..3] of boolean; { true if subexpression hoistable}
        aindxkludge: boolean; { true if aindx should be hoisted anyway}


      function varisinvar: boolean;
{
    Purpose:
      determine if the (uns)varop is invariant.

    Inputs:
      expr : copy of the varop node.

    Outputs:
      true : if the variable is invariant in this context.

    Algorithm:
      Obvious!

    Sideeffects:
      Who me?

    Last Modified: 6/27/85

}

        var
          currentvar: nodeindex; { for walking write chains }
          found: boolean; { true if expression found on write chains }
          ptr: nodeptr; { for access to expression nodes }


        begin {varisinvar}
            { Only called on pass 2, when invariant flag is not enough to
              determine if invariant in this context or when target flag
              is on and marked invariant.
            }
          if loopblk^.deadlevels[operands[1]] then
            begin
            varisinvar := false;
            ptr := ref(bignodetable[oprnd]);
            ptr^.invariant := false; { warn others early }
            end
          else
            begin

            { must check against the writes }

            currentvar := loopblk^.writes;
            found := false;
            while (currentvar <> finalwrite) and not found do
              begin
              ptr := ref(bignodetable[currentvar]);
              if (operands[1] = ptr^.oprnds[1]) and
                 (operands[2] = ptr^.oprnds[2]) then
                found := true;
              currentvar := ptr^.looplink;
              end;
            if found then
              begin
              varisinvar := false;
              ptr := ref(bignodetable[oprnd]);
              ptr^.invariant := false;
              end
            else varisinvar := true;
            end;
        end {varisinvar} ;


      begin {invariantoprnd}

        ptr := ref(bignodetable[oprnd]);

        worthit := false;
        aindxkludge := false;
        copyfound := false;

        i := contextsp;
        while (i > 0) and (ptr^.action = copy) do
          begin
          copyfound := true; {a few redundant assignments here won't hurt}
          oprnd := ptr^.oldlink;
          ptr := ref(bignodetable[oprnd]);
          i := i - 1;
          end;

        invar := ptr^.action = copy;
        blockhoist := copyfound and (ptr^.refcount > ptr^.copycount);
        musthoist := hoistsubtrees and not copyfound and (contextsp > 0) and
                     (ptr^.hoistedby <> loopblk) and (ptr^.refcount > 1);

        if ptr^.action = visit then
          begin
          if ((ptr^.op = paindxop) or (ptr^.op = aindxop)) and
             not dominating and (oprnd <> currenthoist) then
            begin
                { this is a kludge, it is ok to hoist array indexing as
                  long as we make sure that the possible bad address is
                  not used until the actual reference point. That is for
                  "invarop" + array[invar] the addition operator cannot
                  be hoisted but both operands can.
                }
            aindxkludge := true;
            end;

          { see if this expression is not a hoistable type or unsafe }

          if {was not ptr^.local and -- I don't know what this was supposed to
              fix, but I know what it breaks; you really cannot hoist those.
              a.o. no backend propagates correctly a key with a branchaccess
              (see copyaccess); hoisting a call also seems kind of peculiar. }
           (((ptr^.form = bools) and ptr^.relation) or
           (ptr^.op in
           [forindexop, forupchkop, fordnchkop, forerrchkop, moveop, cmoveop, movelit, lssop, leqop, neqop, eqop, gtrop,
           geqop, lsslit, leqlit, eqlit, neqlit, gtrlit, geqlit, withop,
           setfileop, setfileaddrop, setinput, newset, ptrchkop,
                  { could do this if travrs kept better track get/put don't
                   mark var as written }
                  { could do bldset, setelt, setpair if genblk would make
                    sure stack temp not popped during loop, someday... }
           bldset, setelt, setpair, bldnil, bldfmt, inop, pushaddr, pushvalue,
           pushcvalue, pushfinal, pushlitvalue, call, unscall, callparam,
           copystackop, unscallparam, reserve, pushproc, rd, wr, switchstack,
           closerangeop, definelazyop, filebufindrop, setbinfileop,
           setbinfileop, sysfn, dummyargop]) or
           (ptr^.op in [rangechkop, indxchkop]) and (nowwalking or
           nowdebugging) or not dominating and
           (ptr^.op in
           [divop, stddivop, remop, quoop, kwoop, modop, stdmodop, rangechkop, indxchkop]) or
           ((targetopsys = vdos) and sharedPtr^.switcheverplus[pic] and
           (ptr^.op in [extop]))) then
            examineexpression(oprnd, hoistsubtrees and not copyfound)
          else
            begin
            if (ptr^.hoistedby = loopblk) or (ptr^.hoistedby = root) then
              invar := true
            else
              begin {must check}
              if ptr^.op in [defforindexop, defforlitindexop, defunsforindexop,
                 defunsforlitindexop] then
                begin
                { must determine if we are in this for loop or deeper }
                ptr := ref(bignodetable[loopblk^.beginstmt]);
                invar := ptr^.expr2 <> oprnd;
                end
              else {ordinary operator}
                begin
                operands := ptr^.oprnds;
                nodeoperands := ptr^.nodeoprnd;
                isvar := (ptr^.op = varop) or (ptr^.op = unsvarop);
                if not dominating and (ptr^.op = indrop) then
                  begin {uservar^ can't be invariant, internal indrs can be}
                  ptr := ref(bignodetable[ptr^.oprnds[1]]);
                  invar := (ptr^.action = visit) and (ptr^.op <> unsvarop);
                  end
                else invar := true;
                for i := 1 to 3 do
                  begin
                  hoist[i] := false;
                  if nodeoperands[i] then
                    begin
                    if not invariantoprnd(operands[i], hoist[i],
                                          hoistsubtrees and not copyfound) then
                      invar := false;
                    end;
                  end;

              { Varop's require additional checking to determine invariantness }

                if invar and isvar then invar := varisinvar;
                    {
                      If entire expression wasn't hoistable, hoist worthwhile
                      invariant subexpressions.
                    }
                if hoistsubtrees and not copyfound then
                  if not invar then
                    begin
                    for i := 1 to 3 do if hoist[i] then hoistit(operands[i]);
                    end
                  else if aindxkludge or musthoist then
                    begin
                    { can't let this go any further }
                    invar := not aindxkludge;
                    hoistit(oprnd);
                    end;
                worthit := invar and not (copyfound or musthoist);
                end; {ordinary operator}
              end; {else must check}
            end; {hoistable}
          end; {action = visit}
        invariantoprnd := invar and not blockhoist;
      end {invariantoprnd} ;


    procedure examineexpression {expression: nodeindex} ;

      var
        i: 1..3; {induction var }
        ptr: nodeptr; { for node access }
        operands: operandarray; { local copy of oprnd field }
        nodeoperands: nodeoperandarray; { local copy of nodeoprnd field }
        valuable: boolean; { true if invariant worth hoisting }


      begin {examineexpression}
        repeat
          ptr := ref(bignodetable[expression]);
          if ptr^.action = visit then
            begin

            operands := ptr^.oprnds;
            nodeoperands := ptr^.nodeoprnd;
              {
                this expression may contain several parallel expressions
                which should be examined also
              }
            if ptr^.op < intop then expression := ptr^.slink
            else expression := 0;
            for i := 1 to 3 do
                {
                  Examine each operand to determine if expression is
                  invariant.  If it is hoist it.
                }
              if nodeoperands[i] then
                begin
                if invariantoprnd(operands[i], valuable, hoistsubtrees) then
                  if valuable and hoistsubtrees then hoistit(operands[i]);
                end;
            end
          else expression := 0;
        until expression = 0;
      end {examineexpression} ;


    procedure examineinvariant(var expression: nodeindex;
                               previous: nodeindex);
{
    Purpose:
      Examine an expression found to be invariant in an inner loop and
      hoist any part of it found to be invariant in this loop.

    Inputs:
      expression : invariant expression to be examined.
      previous : index of previous invariant on precode list.

    Outputs:
      expression : 0 if entire expression was found to be invariant
        otherwise unchanged.

    Algorithm:
      Examine expression to determine if it is invariant. If entire
      expression is invariant insert in precode chain of loopblk,
      remove from precode chain of hoistedby and replace it with a
      copy operator.
      Otherwise link any invariant subexpressions found onto loopblk's
      precode list and insert the appropriate copy operations.

    Sideeffects:
      modified graph.

    Last Modified: 7/3/85

}

      var
        ptr: nodeptr; { for access to node }
        valuable: boolean;


      begin {examineinvariantoprnd}

        ptr := ref(bignodetable[expression]);
        secondlevel := true;
        if (ptr^.hoistedby = innerloop) and invariantoprnd(expression, valuable,
                                                           false) then
          begin
          if valuable then
            begin
            if previoushoist = 0 then innerloop^.precode := nexthoist
            else
              begin
              ptr := ref(bignodetable[previoushoist]);
              ptr^.prelink := nexthoist;
              end;
            ptr := ref(bignodetable[expression]);
            ptr^.prelink := 0;
            hoistit(expression);
            expression := 0;
            end
          end;

        if expression <> 0 then {try to hoist bits of it, at least}
          examineexpression(expression, true);

        secondlevel := false;

      end {examineinvariantoprnd} ;


    begin {examineloop}

      { see if this loop is too deeply nested, and ignore it if so}

      if not (loopblk^.deadloop or loopblk^.isdead) then
        begin
          { find the last node in the precode chain, loops rarely have any already
            unless they are within a with statement.
           }

        p := loopblk^.precode;
        lasthoist := 0;
        currenthoist := 0;
        while p <> 0 do
          begin
          if loopblk^.looplabel = 0 then loopblk^.looplabel := newlabel;
          ptr := ref(bignodetable[p]);
          lasthoist := p;
          p := ptr^.prelink;
          end;

        { find the first write outside of this loop }

        if loopblk^.lastwrite <> 0 then
          begin
          ptr := ref(bignodetable[loopblk^.lastwrite]);
          finalwrite := ptr^.looplink;
          end
        else finalwrite := 0;

        current := bottomblk;

        { examine each basic block within the loop }

        while current <> loopblk^.rdfolist do
          begin

          { define the context of the current block }

          definecontext(loopblk, current);

          { examine each statement in this block }
          if not current^.isdead and (current^.beginstmt <> 0) then
            begin
            stmt := current^.beginstmt;
            ptr := ref(bignodetable[stmt]);

            { see if we just backed into a new loop }
            if (current <> bottomblk) and
               (ptr^.stmtkind in
               [forbothdr, cforbothdr, whilebothdr, untilhdr, loopbothdr]) then
              begin
              if ptr^.stmtkind = untilhdr then innerloop := ptr^.falseblock
              else innerloop := ptr^.looptop;
              examineloop(innerloop, current);

              { examine the expressions hoisted out of inner loop(s) }

              definecontext(loopblk, current);

              if innerloop^.dominates and (innerloop^.precode <> 0) then
                begin

                { see if we can hoist any invariants from innerloop }

                dominating := loopblk^.willexecute;
                previoushoist := 0;
                currenthoist := innerloop^.precode;
                repeat
                  ptr := ref(bignodetable[currenthoist]);
                  nexthoist := ptr^.prelink;
                  if ptr^.action = visit then
                    examineinvariant(currenthoist, previoushoist);

                  { if entire expression wasn't hoisted make it previous}

                  if currenthoist <> 0 then previoushoist := currenthoist;
                  currenthoist := nexthoist;
                until currenthoist = 0;
                end; {precode <> 0}
              current := innerloop;
              end {current <> bottomblk}

              { if this block doesn't dominate loop exit ignore it }

            else if (current = loopblk) or current^.dominates then
              begin

              { examine each stmts expressions }

              if current = loopblk then dominating := current^.dominates
              else dominating := loopblk^.willexecute and current^.dominates;
              repeat
                ptr := ref(bignodetable[stmt]);
                { get next stmt while it's cheap }
                stmt := ptr^.nextstmt;
                secondlevel := false;
                if (ptr^.stmtkind in
                   [ifhdr, whilehdr, withhdr, simplehdr, untilhdr,
                   syscallhdr]) and (ptr^.expr1 <> 0) then
                  examineexpression(ptr^.expr1, true)

                else if ptr^.stmtkind = casehdr then
                  begin
                  examineexpression(ptr^.selector, true);
                  end;
              until stmt = 0;
              end; {else}
            end; {beginstmt<>0}

          current := current^.rdfolist;
          end; {while}

          { finally if this loop is a for loop and the final limit is a
            simple invariant var then no need to "pushfinal" it just
            reference it.
          }
        if loopblk^.beginstmt <> 0 then
          begin
          fixnode := loopblk^.beginstmt;
          ptr := ref(bignodetable[fixnode]);
          if (ptr^.stmtkind = foruphdr) or (ptr^.stmtkind = fordnhdr) then
            begin
            finalexpr := ptr^.expr1;
            initexpr := ptr^.expr2;
            ptr := ref(bignodetable[ptr^.expr2]);
            temp := ptr^.len; {length of index variable}
            ptr := ref(bignodetable[finalexpr]);
            if ptr^.op in [forupchkop, fordnchkop, forerrchkop] then
              begin
              fixnode := finalexpr;
              ptr := ref(bignodetable[ptr^.oprnds[1]]);
              if ptr^.op = pushfinal then
                begin
                newoprnd := ptr^.oprnds[1];
                ptr := ref(bignodetable[newoprnd]);
                if simpleinvar(newoprnd, initexpr) and (temp = ptr^.len) then
                  begin
                  { delete the pushfinal op }
                  ptr2 := ref(bignodetable[fixnode]);
                  ptr2^.oprnds[1] := newoprnd;
                  end;
                end;
              end
            else if ptr^.op = pushfinal then
              begin
              newoprnd := ptr^.oprnds[1];
              ptr := ref(bignodetable[newoprnd]);
              if simpleinvar(newoprnd, initexpr) and (temp = ptr^.len) then
                begin
                { delete the pushfinal op }
                ptr2 := ref(bignodetable[fixnode]);
                ptr2^.expr1 := newoprnd;
                end;
              end;
            end; { forloop}
          end { <> 0 } ;

        if (lasthoist > 0) and (loopblk^.looplabel = 0) then
          loopblk^.looplabel := newlabel;
        end;
    end {examineloop} ;


  begin {loops}
    anyinvars := false;

    { walk the blocks until we find a loophdr }

    blk := tail;
    repeat
      { this test will be unneeded when empty basic blocks are removed }
      if not blk^.isdead and (blk^.beginstmt <> 0) then
        begin
        ptr := ref(bignodetable[blk^.beginstmt]);
        if (ptr^.nodeform = stmtnode) and
           (ptr^.stmtkind in
           [loopbothdr, whilebothdr, forbothdr, cforbothdr, untilhdr]) then
          begin
          { get next blk now while its cheap }
          if ptr^.stmtkind = untilhdr then nextblk := ptr^.falseblock^.rdfolist
          else nextblk := ptr^.looptop^.rdfolist;
          examineloop(nextblk^.dfolist, blk);
          blk := nextblk;
          end
        else blk := blk^.rdfolist;
        end
      else blk := blk^.rdfolist;
    until blk = nil;

  end {loops} ;
{>>>}
{<<<}
procedure smooth;
{
    Purpose:
      Smooth out size of expression.

    Inputs:
      none.

    Outputs:
      none.

    Algorithm:
      For each basic block, examine each statement and call
      smoothexpr to all the work.

    Sideeffects:
      Graph is changed.

    Last Modified: 11/12/85

}

  var
    ptr: nodeptr; { for access to nodes }
    stmt: nodeindex; { current stmt in basic block }
    blk: basicblockptr; { block being examined }


  procedure smoothexpr(expression: nodeindex;
                       initial: addressrange);
{
    Purpose:
      Convert the length of all arithmetic operators in an
      expression the size of the widest length contained in
      the expression.

    Inputs:
      expression : index of the expression to be examined.

    Outputs:
      none.

    Algorithm:
      Walk all of the nodes of the expression recording the
      max and min values of the length field. If after walking
      the entire expression min <> max the rewalk the expression
      converting length to max. Complicated by the fact that
      some pseudoops cannot have their length fields changed
      ( e.g. varop ) and others ( e.g. aindxop ) have bogus lengths.
      Whenever an aindxop is seen the index expression is set to
      be targetintsize regardless of max and min size of the expression.

    Sideeffects:
      Graph is changed.

    Last Modified: 11/12/85

}

    var
      maxlen, minlen: addressrange; { size ranges of expression }


    procedure getsize(expr: nodeindex);
{
    Purpose:
      Find the maximum and minimum size of expression rooted in expr

    Inputs:
      expr : expression to determine size for.

    Outputs:
      none.

    Algorithm:
      walk expression nodes recording max an min values.

    Sideeffects:
      maxlen and minlen in enclosing procedure modified.

    Last Modified: 11/12/85

    Note: this could have been coded to take maxlen and minlen as
    var parameters but this simply wastes stack space.

}

      var
        i: 1..3; { induction var }
        operands: operandarray; { local copy of oprnd field }
        nodeoperands: nodeoperandarray; { local copy of nodeoprnd field }
        ptr: nodeptr; { for access to node }


      begin {getsize}
        ptr := ref(bignodetable[expr]);
        if (ptr^.action = visit) then
          begin
          operands := ptr^.oprnds;
          nodeoperands := ptr^.nodeoprnd;
          if (ptr^.op < intop) then
            begin
            if ptr^.op = pushvalue then
              begin
              { expressions pushed to stack should be computed at stackalign
                size. At least on 32k it is desirable.
              }
              maxlen := stackalign;
              end;
            { must smooth as parallel expression }
            if ptr^.slink <> 0 then smoothexpr(ptr^.slink, 0);
            end
          else
            begin
            if (ptr^.op in
               [plusop, minusop, mulop, divop, stddivop, remop, quoop, kwoop,
               modop, stdmodop, negop, shiftlop, incop, decop]) and
               (ptr^.form in [ints, scalars, subranges]) then
              begin
              if ptr^.len > maxlen then maxlen := ptr^.len;
              if ptr^.len < minlen then minlen := ptr^.len;
              end
            else if (ptr^.op = aindxop) or (ptr^.op = setelt) or
                    (ptr^.op = paindxop) then
              begin
              smoothexpr(operands[2], sharedPtr^.targetintsize);
              { prevent separate expression from influencing this expression}
              nodeoperands[2] := false;
              end
            else if ptr^.op = setpair then
              begin
              smoothexpr(operands[3], 0);
              nodeoperands[3] := false;
              smoothexpr(operands[2], 0);
              nodeoperands[2] := false;
              end
            else if (not (ptr^.form in [ints, subranges, scalars])) and
                    (ptr^.op in
                    [orop, andop, eqop, neqop, notop, plusop, minusop, mulop,
                    divop, stddivop, remop, quoop, kwoop, modop, stdmodop,
                    negop, shiftlop, incop, decop]) then
              begin
              smoothexpr(operands[1], 0);
              nodeoperands[1] := false;
              smoothexpr(operands[2], 0);
              nodeoperands[2] := false;
              end;
            end;
          for i := 1 to 3 do
            begin
            if nodeoperands[i] then
              begin
              getsize(operands[i]);
              end;
            end;
          end { action=visit}
        else if ptr^.action = copy then
          begin
          getsize(ptr^.directlink);
          end;
      end; {getsize}


    procedure setsize(expr: nodeindex);
{
    Purpose:
      Set the size of the expression to maxlen

    Inputs:
      expr : expression to set size for.

    Outputs:
      none.

    Algorithm:
      walk expression nodes setting len for appropriate ops.

    Sideeffects:
      graph is modified.

    Last Modified: 11/12/85

    Note: this could have been coded to take maxlen as a parameter
    but this simply wastes stack space.

}

      var
        i: 1..3; { induction var }
        operands: operandarray; { local copy of oprnd field }
        nodeoperands: nodeoperandarray; { local copy of nodeoprnd field }
        ptr: nodeptr; { for access to node }


      begin {setsize}
        ptr := ref(bignodetable[expr]);
        if (ptr^.action = visit) then
          begin
          if (ptr^.op in
             [plusop, minusop, mulop, divop, stddivop, remop, quoop, kwoop,
             modop, stdmodop, negop, shiftlop, incop, decop]) and
             (ptr^.form in [ints, subranges, scalars]) then
            begin
            ptr^.len := maxlen;
            end;
          operands := ptr^.oprnds;
          nodeoperands := ptr^.nodeoprnd;
          { don't follow certain expressions }
          if (ptr^.op = aindxop) or (ptr^.op = setelt) or
             (ptr^.op = paindxop) then
            nodeoperands[2] := false
          else if ptr^.op = setpair then
            begin
            nodeoperands[3] := false;
            nodeoperands[2] := false;
            end
          else if (not (ptr^.form in [ints, subranges, scalars])) and
                  (ptr^.op in [orop, andop, eqop, neqop, notop]) then
            begin
            nodeoperands[1] := false;
            nodeoperands[2] := false;
            end;
          for i := 1 to 3 do
            begin
            if nodeoperands[i] then
              begin
              setsize(operands[i]);
              end;
            end;
          end { action=visit}
        else if ptr^.action = copy then
          begin
          setsize(ptr^.directlink);
          end;
      end; {setsize}


    begin {smoothexpr}
      maxlen := initial;
      minlen := sharedPtr^.targetintsize;

      getsize(expression);
      { only smoothing integer expressions }
      { temp let codegen blowup if smooth wrong thing }
      if (maxlen > minlen) { ( maxlen <= sharedPtr^.targetintsize ) } then
        setsize(expression);
    end {smoothexpr} ;


  begin {smooth}
    blk := root;
    repeat
      { examine each stmts expressions }
      stmt := blk^.beginstmt;
      while stmt <> 0 do
        begin
        ptr := ref(bignodetable[stmt]);
        { get next stmt while it's cheap }
        stmt := ptr^.nextstmt;
        if ptr^.stmtkind in
           [ifhdr, whilehdr, withhdr, simplehdr, untilhdr, syscallhdr] then
          begin
          smoothexpr(ptr^.expr1, 0);
          end
        else if ptr^.stmtkind = casehdr then
          begin
          smoothexpr(ptr^.selector, 0);
          end
        end;
      blk := blk^.dfolist;
    until blk = tail;
  end {smooth} ;
{>>>}
{<<<}
procedure improve;
{
    Purpose:
      Optimize the flow graph.

    Inputs:
      A flow graph rooted in "root"

    Outputs:
      An improved flow graph.

    Algorithm(s):
      calls various improving procedures

    Sideeffects:
      Graph is changed.

    Last Modified: 7/3/85

}

  begin {improve}
    assignregs;
    { smooth before hoisting }
    { Smoothing causes poor code for these machines. }
    { smooth; }

    if (hoisting in sharedPtr^.genset) and not irreducible then
      loops;
  end {improve} ;
{>>>}
{>>>}

{<<<}
procedure dumptree;
{ dump the entire tree structure for a block to the dump file }

var
  i: nodeindex; {induction var for writing nodes}
  ptr: nodeptr; {access to nodes}
  lnk: linkptr;
  count: shortint;
  blockp: basicblockptr; { for walking block nodes }

  {<<<}
  function conditionsmatch: boolean;

  begin
    if sharedPtr^.blockref = sharedPtr^.tblocknum then
      conditionsmatch := true
    else
      conditionsmatch := false;

    conditionsmatch := true;
  end;
  {>>>}

begin
  if dumpFiles then
    if dumpDetails and conditionsmatch then
      begin
      { first dump from root to tail }
      blockp := root;
      while blockp <> nil do
        begin
        with dumpFile^ do
          begin
          bblock := true;
          id := loophole (integer, blockp);
          basic := blockp^;
          end;
        put (dumpFile);

        if true then
          begin
          write ('successors for block ', blockp^.blocklabel: 1, ' ==> ');
          lnk := blockp^.successor;
          count := 0;
          while lnk <> nil do
            begin
            if count > 10 then
              begin
              writeln;
              count := 0;
              end;
            count := count + 1;
            write (lnk^.suc^.blocklabel: 1, ' ');
            lnk := lnk^.snext;
            end;
          writeln;
          end; {true}
        blockp := blockp^.dfolist;
        end;

      for i := 1 to lastnode do
        begin
        ptr := ref(bignodetable[i]);
        with dumpFile^ do
          begin
          bblock := false;
          nodelab := i;
          nodeent := ptr^;
          end;
        put (dumpFile);
        end;

      break (dumpFile);
      end;
end;
{>>>}

{<<<}
procedure getintfile;
{ Do the equivalent of a "get" on the intermediate file from analys.
  If the last element of the buffer was just read, a new buffer is
  read.  Otherwise the global index "nextintcode" is incremented.
  The next element is referenced as intfile^[nextintcode].

  This routine is also responsible for setting switchcounters to
  reflect the effect of embedded switches.  It also updates the element
  counts (mlow and mhi) to those for the output file.  This effectively
  groups all switches changed in a procedure to the front of that
  procedure.
}

begin
  while (sharedPtr^.currentswitch <= sharedPtr^.lastswitch) and
        (sharedPtr^.switches[sharedPtr^.currentswitch].mlow <= sharedPtr^.getlow) do
    with sharedPtr^.switches[sharedPtr^.currentswitch] do
      begin
      sharedPtr^.switchcounters[s] := sharedPtr^.switchcounters[s] + v;
      mlow := sharedPtr^.putlow;
      sharedPtr^.currentswitch := sharedPtr^.currentswitch + 1;
      end;
  sharedPtr^.getlow := sharedPtr^.getlow + 1;

  if nextintcode = diskbufsize then
    begin
    nextintcode := 0;
    if not eof(interSharedPtr^.interFile) then
      get (interSharedPtr^.interFile);
    end
  else
    nextintcode := nextintcode + 1;
end;
{>>>}
{<<<}
function getintfileint: integer;
{ Returns an integer passed in the intermediate file as a sequence of bytes }

var
  { This fudges an integer into bytes.  The constant "32" is }
  { simply a large enough number to include all probable systems. }
  fudge:
    record
      case boolean of
        true: (int: integer);
        false: (byte: packed array [1..32] of hostfilebyte);
    end;
  j: 1..32; {induction var}

begin
  fudge.int := interSharedPtr^.interFile^.block[nextintcode].b;
  if fudge.int = hostfilelim then
    for j := 1 to hostintsize * hostfileunits do
      begin
      getintfile;
      fudge.byte[j] := interSharedPtr^.interFile^.block[nextintcode].b;
      end;
  getintfileint := fudge.int;
end;
{>>>}
{<<<}
procedure getintreal (var val: realarray);
{ Get a real value from the intermediate file into val }

var
  i: 1..32;
  s: addressrange; {size read so far}
  kludge:
    packed record
      case boolean of
        true: (r: realarray);
        false: (i: packed array [1..32] of integer; );
    end;

begin
  s := 0;
  i := 1;
  while s < size(realarray) do
    begin
    getintfile;
    kludge.i[i] := getintfileint;
    i := i + 1;
    s := s + size(integer);
    end;
  val := kludge.r;
end;
{>>>}

{ Initialization data is passed in the intermediate file as a series of operators.
  Such operators can appear in thd midst of an expression,
  or they can be preceeded by a "begdata" statement and appear outside of a statement or even a block body.
  They do not cause anything to be placed in the tree, but generate pseudo-ops directly }
{<<<}
procedure takeDataOp;
{ Take a data operator and generate output code. }

var
  this_op: operator; {current operator}
  len, op1, op2: integer; {operands}
  realval: realarray; {a value if it's a real}

begin
  this_op := interSharedPtr^.interFile^.block[nextintcode].o;

  if this_op = drealop then
    begin
    getintfile;
    len := getintfileint;
    getintreal (realval);
    genrealop (map[drealop, none], len, 0, 0, 0, realval);
    end

  else
    begin
    len := 0;
    op1 := 0;
    op2 := 0;
    case this_op of
      daddop, dsubop, dstoreop, dendop: {nothing} ;
      {<<<}
      daddrop:
        begin
        getintfile;
        len := getintfileint;
        getintfile;
        op1 := getintfileint;
        getintfile;
        op2 := getintfileint;
        end;
      {>>>}
      {<<<}
      dfaddrop, dintop, dstructop:
        begin
        getintfile;
        len := getintfileint;
        getintfile;
        op1 := getintfileint;
        end;
      {>>>}
      {<<<}
      dstartop, dfieldop:
        begin
        getintfile;
        op1 := getintfileint;
        getintfile;
        op2 := getintfileint;
        end;
      {>>>}
      {<<<}
      dfillop:
        begin
        getintfile;
        len := getintfileint;
        end;
      {>>>}
      end;
    genpseudo(map[this_op, none], len, 0, 0, 0, op1, op2, 0);

    if newtravrsinterface then
      begin
      if this_op = dfaddrop then
        sharedPtr^.new_proctable[op1 div (pts + 1)]^[op1 mod (pts + 1)].referenced := true
      end
    else if this_op = dfaddrop then
      sharedPtr^.proctable[op1].referenced := true;
    end;
end;
{>>>}
{<<<}
procedure passdata;
{ Called when a "begdata" statement is found.  It passes data statements until it finds an "endexpr" operator }

begin
  getintfile;
  while interSharedPtr^.interFile^.block[nextintcode].o <> endexpr do
    begin
    takeDataOp;
    getintfile;
    end;

  getintfile; {skip the endexpr}
end;
{>>>}
{<<<}
procedure build;
{<<<}
{ Build the statement tree for a procedure or function.
  This procedure contains all of the code to build a statement tree.
  As the tree is being built, all common subexpressions are detected
  and noted so that "walk" generates pseudocode for the common
  part only once.  This can be done because the pascal control structures
  provide a disciplined flow of data which avoids the need for elaborate
  flow tracing algorithms.  In the rare case when a "goto" is used, it
  simply clears all common subexpressions at the label and turns of lifetime analysis.
  The result is a basic block tree in core, with statement and expression
  trees in the virtual node structure }
{ Build a basic block tree for a procedure or function.
  This procedure itself actually does very little of the building,
  it uses internal procedures to do this.  This procedure itself
  initializes the block header, calls "buildstmtlist" to build the
  block body, and reads in temp data at the end of the block.
  Dead code elimination is much complicated by the addition of the
  C language, which allows jumps into structures.
}
{>>>}
{<<<}
type
  locallabelptr = ^locallabeltype;
  {<<<}
  locallabeltype =
    record
      block: basicblockptr; { basic block defining this pascal label }
      labelno: labelrange; { label value }
      link: locallabelptr; { predecessor chain }
    end;
  {>>>}

  loop_descriptor = ^loop_data;
  {<<<}
  loop_data = {holds data on loop nesting}
    record
      outer: loop_descriptor; {outer case, if any}
      header: nodeindex; {the header statement}
      cont_block: basicblockptr; {where to continue}
      break_block: basicblockptr; {where to break}
      break_found: boolean; {we found a break}
      cont_found: boolean; {we found a continue}
      looploop: boolean; {we are a "loop" loop, not "repeat" loop etc}
    end;
  {>>>}

  case_descriptor = ^case_data;
  {<<<}
  case_data =
    record
      outer: case_descriptor; {outer case, if any}
      casetopblock: basicblockptr; {block containing the selector}
      tailblock: basicblockptr; {the block following the case exit}
      casetopstmt: nodeindex; {the casehdr}
      caseexpr: nodeindex; {the expression for this case}
      contextlev: natural; {context level of the case controlled stat}
      loopd: natural; {loop depth of the case controlled stat}
      firstorder: nodeindex; {first node in ordered chain}
      lastorder: nodeindex; {last node in ordered chain}
      highlabel, lowlabel: integer; {for optimizing label access}
      lastlab: nodeindex; {last label allocated (inverse text order)}
      firstsplit: nodeindex; {the first case group we have built}
      splitcount: integer; {the number of groups}
      removing: boolean; {we are removing code}
      constvalue: integer; {the selector value if removing}
      found: boolean; {found a label in this group with value constvalue}
      ever_found: boolean; {we ever found one}
      casedef_found: boolean; {found a default label in this group}
      otherflow: boolean; {there is other flow into the current node}
      saveminfon: integer; {fon before statement list}
      savemaxfon: integer; {fon after statement list}
      old_swbreak_found: boolean; {save the flag}
      old_caselab_found: boolean; {in fact, two flags}
      last_dead: boolean; {the last case was dead}
      entry_dead: boolean; {case was dead on entry}
      start_deadcount: natural; {starting deadcount}
      lab_found: boolean; {we found a label in the code}
    end;
  {>>>}

  dead_log = ^dead_element;
  {<<<}
  dead_element =
    record
      next: dead_log; {next level of interest}
      level: natural; {level which was live}
    end;
  {>>>}
{>>>}
{<<<}
var
  locallabels: locallabelptr; { ptr to local label chain }
  templink: locallabelptr; { for disposing the local label links }
  i: integer; {induction var for reading temps}
  temp: nodeindex; { place holder }
  lastblock: basicblockptr; { most recent block added to dfo chain }
  currentblock: basicblockptr; { current basic block }
  retblock: basicblockptr; {return block for C programs}
  currentlaststmt: nodeindex; { index of last statement in this block}
  block_exit_block: basicblockptr; {exit from the routine}
  this_loop: loop_descriptor; {Current innermost loop}
  this_case: case_descriptor; {descriptor of current case statement}
  call_depth: integer;
  cond_depth: integer;

  deadcount: natural; {count of dead code levels}
  deadcode: boolean; {code is actually dead}
  gotodead: natural; {count of dead code due to goto's}
  dead_level: dead_log; {last level which was enlivened}
  swbreak_found: boolean; {we found a switch break}
  caselab_found: boolean; {we found a case label}
  b: basicblockptr; {for scanning the blocks}
{>>>}

  {<<<}
  { Dead code elimination -
    In Pascal dead code can be eliminated by a simple count of dead code
    levels.  In C, which allows jumps into structured constructs, the
    bookkeeping is more complicated.  Such a jump can suddenly "enliven"
    dead code.

    To keep track of this we separate the dead code flag from the count of
    dead levels and turn on code again whenever we have a label (C only.)
    Code will be live from there until deadcount is zero.  Suppose,
    however, that we have some inner dead code, which increments deadcount
    after the label.  In this case we turn off code generation, but log
    this level so we can turn it on again when we hit it.  This is probably
    a rare occurance, so we allocated it on the heap rather than use an
    array or some other more efficient method.

    We would also like to include breaks and goto's in the general mechanism,
    especially since the C switch statement requires that we remember
    about them anyway.  We do this by logging the dead code level at
    the start of each structured statement (and the block, for that matter),
    incrementing the deadcount when a break is found, and decrementing
    it at the end of a block if the deadcount exceeds the saved count.

    This scheme works for everything but switch breaks which must be
    turned on by case labels.  The problem is that the break (and the
    label) may be improperly nested in other structured statements.
    We handle this with a special "switchbreak" flag, which must,
    of course be stacked in the switch descriptor.  This flag is set only
    when the context level of the break is the same as that of the switch.
    It's only in this situation that there is no structured statement to
    turn things on.  We also provide a flag which says that a case label
    was detected, and on exit from a level, if both flags are set they
    are turned off and the deadcount is decremented.

    This algorithm is incapsulated in the routine "dead_exit".
    }
  {>>>}
  {<<<}
  procedure incr_deadcount;
  { Increment deadcount.  This always turns off code generation, and possibly logs a turn-on point. }

  var
    d: dead_log; {for creating a log entry}

  begin
    if not deadcode and (deadcount > 0) then
      begin
      new(d);
      d^.next := dead_level;
      d^.level := deadcount;
      dead_level := d;
      end;
    deadcount := deadcount + 1;
    deadcode := true;
  end;
  {>>>}
  {<<<}
  procedure decr_deadcount;
  { Decrement deadcount.  This turns on code generation if deadcount becomes
    zero or if it matches a previously logged level
  }
  var
    d: dead_log; {for disposing of a log entry}

  begin
    deadcount := deadcount - 1;
    if dead_level <> nil then
      begin
      if dead_level^.level = deadcount then
        begin
        deadcode := false;
        d := dead_level;
        dead_level := d^.next;
        dispose(d);
        end;
      end
    else if deadcount = 0 then deadcode := false;
  end;
  {>>>}
  {<<<}
  procedure dead_exit(start: natural {starting dead count} );
  { This routine should be called at the end of each branch in a
    structured statement.  The parameter is the value of deadcount
    at the start of that expression.  All local adjustments of deadcount
    must be done by the time this is called.
  }
  begin
    if deadcount > start then
      begin
      gotodead := gotodead - 1;
      decr_deadcount;
      end;

    if swbreak_found and caselab_found then
      decr_deadcount;
    swbreak_found := false;
    caselab_found := false;
  end;
  {>>>}

  {<<<}
  function bumpvarcount(varlev: levelindex; {level of var}
                        varisparam: boolean; {true if var is a parameter}
                        varoffset: addressrange {offset of var} ): boolean;
  { bump the useage count of a register candidate variable }

  var
    i: reghashindex; { hash value }

  begin {bumpvarcount}
    { if this is a register candidate, do lots of stuff }
    bumpvarcount := false;
    if varlev = level then
      begin
        { This hashes the variable's offset.  Really should be a
          function call.  However, it would be called in several
          high bandwidth places, and would produce an unneeded
          speed penalty in this phase.  This code is replicated
          in doreference, killasreg, initbuild and walk:indxnode.
        }
      i := (varoffset div sharedPtr^.targetintsize) mod (regtablelimit + 1);
      while ((regvars[i].offset <> varoffset) or
            (regvars[i].parameter <> varisparam)) and
            (regvars[i].worth >= 0) do
        i := (i + 1) mod (regtablelimit + 1);
      with regvars[i], varlife do
        begin
        if worth >= 0 then
          begin
          { a definition }
          bumpvarcount := true;
          worth := worth + loopfactor;
          { set lifetime bounds }
          if lonmin = 0 then lonmin := laststmtnode;
          if laststmtnode > lonmax then lonmax := laststmtnode;
          if foncount < fonmin then fonmin := foncount;
          if foncount > fonmax then fonmax := foncount;
          end;
        end; {with}
      end;
  end {bumpvarcount} ;
  {>>>}
  {<<<}
  procedure dodefine(varp: nodeindex);
  {
      If within a loop, mark the var described by varp as written. Also for
      a local variable update it's reference count and lifetime.
      If in a loop:
       If procedure call has not killed all var's at this level previously,
       search the read list and remove this var, if it is found.  Then link
       this node into this loop's write list.
      If a local var, update refcount and lifetime fields.
  }
   { add a new definition of a simple var located at varoffset at local level }

  var
    ptr, ptr1: nodeptr; { for access to bit map nodes }
    varlev: levelindex; { varaible level }
    varoffset: addressrange; { location at varlev }
    varisparam: boolean; { true if variable is a parameter }
    now, prev: nodeindex; { for walking read chain }
    found: boolean; { loop exit flag }

  begin {dodefine}
    ptr := ref(bignodetable[varp]);
    varlev := ptr^.oprnds[1];
    varoffset := ptr^.oprnds[2];
    ptr1 := ref(bignodetable[ptr^.oprnds[3]]);

    if ptr1^.action = copy then
      ptr1 := ref(bignodetable[ptr1^.directlink]);

    varisparam := (ptr1^.oprnds[1] = localparamnode);

    ptr^.invariant := false;
    ptr^.regcandidate := bumpvarcount(varlev, varisparam, varoffset);

    { if in a loop, add this to the writes for the loop, and kill the reads }

    if loopdepth > 0 then
      begin
      { if procedure call has killed off all reads, it's easy }
      if not loopstack[loopdepth].deadlevels[varlev] then
        begin
        with loopstack[loopdepth] do
          begin
          if ptr^.looplink <> 0 then
            writeln('write looplink <> 0 var ', varp: 1, ' block ', sharedPtr^.blockref:
                    1);
          ptr^.looplink := writes;
          writes := varp;
          if lastwrite = 0 then lastwrite := varp;

          { on this level, kill any reads of this var }

          prev := 0;
          now := reads;
          while (now <> 0) do
            begin
            ptr := ref(bignodetable[now]);
            if varoffset = ptr^.oprnds[2] then
              found := (varlev = ptr^.oprnds[1])
            else found := false;
            if found then
              begin
              ptr^.invariant := false;
              if prev <> 0 then
                begin
                ptr1 := ref(bignodetable[prev]);
                ptr1^.looplink := ptr^.looplink;
                end
              else reads := ptr^.looplink;
              now := ptr^.looplink;
              { isolate the node }
              ptr^.looplink := 0;
              end
            else
              begin
              prev := now;
              now := ptr^.looplink;
              end;
            end; {while}
          end; {with}
        end;
      end;
  end; {dodefine}
  {>>>}
  {<<<}
  procedure doreference(varp: nodeindex);
  {
      If within a loop, mark the var described by varp as read, if not already
      marked as written or dead by procedure call.  Also for a local variable,
      update it's reference count and lifetime.
      If in a loop:
       If procedure call has not killed all var's at this level previously,
       search the write list.  If this var is not found, then link
       this node into this loop's read list.
      If a local var, update refcount and lifetime fields.
  }
  var
    i: reghashindex; { hash value }
    j: nodeindex; { for walking read/write chains }
    found: boolean; { loop exit flag }
    ptr, ptr1: nodeptr; { for access to nodes }
    varlev: levelindex; { variable level }
    varoffset: addressrange; { location at varlev }
    varisparam: boolean; { true if variable is a parameter }

  begin
    ptr := ref(bignodetable[varp]);
    varlev := ptr^.oprnds[1];
    varoffset := ptr^.oprnds[2];

    ptr1 := ref(bignodetable[ptr^.oprnds[3]]);
    if ptr1^.action = copy then
      ptr1 := ref(bignodetable[ptr1^.directlink]);

    varisparam := (ptr1^.oprnds[1] = localparamnode);

    ptr^.regcandidate := bumpvarcount(varlev, varisparam, varoffset);

    { if in a loop, determine if modified in it yet }
      { If we have overflowed loopstack, then since invariant is
        initialized to false by default, all variables inside deeply
        nested loops (except forloop induction vars) will be marked
        as not invariant, which is what we want.
        NOTE: we must ignore forloop induction vars since they exist
        across loops and we can easily wind up building a circular
        list if references exist in multiple loops. This doesn't hurt
        since for loops are recognized as invariant by a different process.
      }
    { if already marked invariant, can't be written, is cse }
    if (loopdepth > 0) and (loopoverflow = 0) and not ptr^.invariant then
      begin

      { eliminate operands we are sure are written quickly.
      written := loopstack[loopdepth].deadlevels[varlev] or  ptr^.target;
      }
      if not (loopstack[loopdepth].deadlevels[varlev] or ptr^.target) then
        begin
        { must check the write list }
        j := loopstack[loopdepth].writes;
        found := false;
        while (j <> 0) and (not found) do
          begin
          ptr := ref(bignodetable[j]);
          if varoffset = ptr^.oprnds[2] then
            found := (varlev = ptr^.oprnds[1])
          else found := false;
          j := ptr^.looplink;
          end;
        if not found then
          begin

          { Add it to the reads for this level, if not there already.
            Since this is the only place that sets invariant to true,
            if its true now this is a common subexpression and var
            is already linked in.
          }

          ptr := ref(bignodetable[varp]);
          if not ptr^.invariant then
            begin
            ptr^.invariant := true;
            ptr^.looplink := loopstack[loopdepth].reads;
            loopstack[loopdepth].reads := varp;
            end;
          end;
        end; {must check }
      end;
  end;
  {>>>}
  {<<<}
  procedure loopkill(lower, upper: levelindex);
  {
      Kill the reads of any loop read that is within the destructive
      power of the levels lower..upper.
      Sets the dead levels for all levels in the loop. Then
  }
  var
    now, prev: nodeindex; { for walking looplink of reads }
    ptr, ptr1: nodeptr; { for access to nodes }
    i: 1..maxloopdepth; {induction var }
    varlev: levelindex; { lex level of var }
    l: levelindex; { induction var }


  begin {loopkill}
    for i := 1 to loopdepth do
      begin
      with loopstack[i] do
        begin
        { first set the bounds }
        for l := lower to upper do deadlevels[l] := true;
      {
        Now kill all the reads that are already present in the loop
        that are within bounds.
      }
        { on this level, kill any reads of this var }
        prev := 0;
        now := reads;
        while now <> 0 do
          begin
          ptr := ref(bignodetable[now]);
          varlev := ptr^.oprnds[1];

          if (varlev <= upper) and (varlev >= lower) then
            begin
            ptr^.invariant := false;
            if prev <> 0 then
              begin
              ptr1 := ref(bignodetable[prev]);
              ptr1^.looplink := ptr^.looplink;
              end
            else reads := ptr^.looplink;
            now := ptr^.looplink;
            { isolate the node }
            ptr^.looplink := 0;
            end
          else
            begin
            prev := now;
            now := ptr^.looplink;
            end;
          end;
        end;
      end;
  end {loopkill} ;
  {>>>}
  {<<<}
  procedure killasreg(varp: nodeindex);
  { Make a variable ineligible for register allocation.
      If level is locallevel, hash the offset, find the
      variable in the table, and invalidate it.
  }
  var
    i: reghashindex; {hash value}
    ptr, ptr1: nodeptr; {for access to bit map nodes}
    varisparam: boolean; {true if the var in question is a parameter}
    varoffset: addressrange; {location at varlev}
    now, prev: nodeindex; {for walking read chain}


  begin {killasreg}

    ptr := ref(bignodetable[varp]);
    while ptr^.op = commaop do
      begin
      varp := ptr^.oprnds[2];
      ptr := ref(bignodetable[varp]);
      end;

      { Verify that operand is a variable.  Pushaddr also takes
        structop, pushcvalue, call, unscall, callparam, unscallparam,
        etc., which are ok but ignored here.
      }

    if (ptr^.op in [varop, unsvarop, newvarop, newunsvarop]) and
       (ptr^.oprnds[1] = level) then
      begin
      blocksin[1].written := true;
      varoffset := ptr^.oprnds[2];
      ptr1 := ref(bignodetable[ptr^.oprnds[3]]);

      if ptr1^.action = copy then
        ptr1 := ref(bignodetable[ptr1^.directlink]);

      varisparam := (ptr1^.oprnds[1] = localparamnode);

        { This hashes the variable's offset.  Really should be a
          function call.  However, it would be called in several
          high bandwidth places, and would produce an unneeded
          speed penalty in this phase.  This code is replicated
          in doreference, dodefine, initbuild and walk:indxnode.
          }
      i := (varoffset div sharedPtr^.targetintsize) mod (regtablelimit + 1);
      while ((regvars[i].offset <> varoffset) or
            (regvars[i].parameter <> varisparam)) and
            (regvars[i].worth >= 0) do
        i := (i + 1) mod (regtablelimit + 1);
      if regvars[i].worth >= 0 then
        begin
        ptr^.regcandidate := false;
        regvars[i].registercandidate := false;
        end;
      end;
  end {killasreg} ;
  {>>>}
  {<<<}
  procedure addpredsuccs(predblock, succblock: basicblockptr);
  { Add block "succblock" to the successor chains of block predblock
   Add block "predblock" to the predeccessor chains of block succblock
  }
  var
    newlink: linkptr; { ptr to new link block }

  begin
    if (predblock <> nil) and (succblock <> nil) then
      begin
      new(newlink);
      newlink^.snext := predblock^.successor;
      predblock^.successor := newlink;
      newlink^.suc := succblock;
      newlink^.pnext := succblock^.predeccessor;
      succblock^.predeccessor := newlink;
      newlink^.pre := predblock;
      end;
  end; {addpredsuccs}
  {>>>}
  {<<<}
  procedure newblock(var b: basicblockptr; {resulting block node}
                     predblock: basicblockptr; { predecessor block }
                     largeblock: boolean { true if loophdr is possible} );
  {<<<}
  { Make a new basic block node. The fields are all given default values.
    Since this is a new context "firstblock" in this context level is
    set to point here. This is done so that preconditions can be hooked
    to the basic block header. Also the default action is to make this
    block the successor of currentblock and currentblock the predecessor
    of the new block.
  }
  {>>>}

  var
    l: levelindex; { induction var }


  begin
    if largeblock then
      new(b, true)
    else
      new(b, false);

    { default is that code will dominate if context dominates }
    b^.dominates := context[contextsp].dominates;
    blockblocks := blockblocks + 1;
    currentblock := b;

    { now initialize to something reasonable ( re-init if dead ) }

    with b^ do
      begin
      bigblock := largeblock;
      isdead := deadcode and (removedeadcode in sharedPtr^.genset);
      visited := visitstate;
      precode := 0;
      beginstmt := 0;
      forcelabel := false;
      loophdr := false;
      joinop := false;
      saveop := false;
      restoreop := false;
      clearop := false;
      dfolist := nil;
      rdfolist := nil;
      successor := nil;
      predeccessor := nil;
      blocklabel := 0;
      if largeblock then
        begin
        willexecute := false;
        deadloop := false;
        looplabel := 0;
        reads := 0;
        writes := 0;
        lastwrite := 0;
        for l := 0 to maxlevel do deadlevels[l] := false;
        end;
      end; {with}

    if (predblock <> nil) then addpredsuccs(predblock, currentblock);
  end {newblock} ;
  {>>>}
  {<<<}
  procedure newstmt(var p: nodeindex; {resulting statement node}
                    s: stmthdrtype {type of node to make} );
  { Make a new statement node of type "s".  The fields are initialized
    appropriately.  If this is the first statement in a new context
    level, the pointer "prestmt" in the context record is set to it
    to provide a place to link preconditions for the statement sequence
    in this context.
  }
  var
    ptr, ptr1: nodeptr; {used for access to node}

  begin {newstmt}
    if lastnode = tnodetablesize then abort(manynodes)
    else
      begin
      lastnode := lastnode + 1;
      laststmtnode := lastnode;
      if lastnode > maxnodes then maxnodes := lastnode;
      p := lastnode;
      { if this is the first stmt for this basic block link it in }
      if currentblock^.beginstmt = 0 then
        begin
        if context[contextsp].firstblock = nil then
          context[contextsp].firstblock := currentblock;
        currentblock^.beginstmt := lastnode;
        currentlaststmt := lastnode;
        end
      else
        begin
        ptr := ref(bignodetable[currentlaststmt]);
        ptr^.nextstmt := lastnode;
        currentlaststmt := lastnode;
        end;
      ptr := ref(bignodetable[p]);
      with ptr^ do
        begin
        nodeform := stmtnode;
        srcfileindx := 0;
        nextstmt := 0;
        stmtkind := s;
        if s in
           [whilehdr, rpthdr, ifhdr, foruphdr, fordnhdr, withhdr, casehdr,
           loophdr, simplehdr, syscallhdr, gotohdr, cforhdr, loopbrkhdr,
           cswbrkhdr, loopconthdr, returnhdr] then
          begin

          getintfile;
          srcfileindx := getintfileint;

          laststmt := laststmt + 1;
          stmtno := laststmt;

          { This little hack is needed if the entire procedure body is
            deadcoded out and if the first statement of the procedure
            has the source file index, then the index will be lost.
            If this is also the first procedure in the module then pma
            will have no filename to print.  Since we always pass the
            blkhdr this code will copy the srcfileindx up.  We only
            support changing source file between procedures, not in the
            middle, so the previous node should be is not a blkhdr.  If
            it is not just let it go.

            Don sez: this little hack has the effect of removing the
            file index passed with the first dummy statment used by
            the new debugger.  So I hacked it a little bit more.
            Would have been MUCH better if the analys/travrs interface
            had been changed so that the srcfileindex was just passed
            in the intcode for blkhdr.  Note the assignment I added
            for stmtno:  the little hack didn't work for newdebugger
            'cause walkblk only emits a genstmtbrk if stmtno <> 0.
            The check for 'simplehdr' should be sufficient because
            only structured statements can trigger dead code and if
            the first statement of a block is a simple statement, the
            entire body won't be removed.
          }
          if s <> simplehdr then
            begin
            ptr1 := ref(bignodetable[p - 1]);
            if (ptr1^.nodeform = stmtnode) and (ptr1^.stmtkind = blkhdr)
            then
              begin
              ptr1^.srcfileindx := srcfileindx;
              srcfileindx := 0;
              end;
            end;

          getintfile;
          textline := getintfileint;
          end;

        case s of
          blkhdr:
            begin
            stmtno := laststmt;
            laststmt := laststmt + 1;

            textline := getintfileint;
            getintfile;
            procref := getintfileint;
            sharedPtr^.blockref := procref;
            getintfile;
            ps := getintfileint;
            getintfile;
            bs := getintfileint;
            getintfile;
            fileline := getintfileint;
            getintfile;
            if newtravrsinterface then
              begin
              level := sharedPtr^.new_proctable[procref div (pts + 1)]^[procref mod
                       (pts + 1)].level;
              intlevelrefs := sharedPtr^.new_proctable[procref div (pts +
                              1)]^[procref mod (pts + 1)].intlevelrefs;
              end
            else
              begin
              level := sharedPtr^.proctable[procref].level;
              intlevelrefs := sharedPtr^.proctable[procref].intlevelrefs;
              end;
            end;
          casehdr:
            begin
            selector := 0;
            casedefptr := nil;
            elements := 0;
            joinblock := nil;
            lowestlabel := 0;
            highestlabel := 0;
            end;
          caselabhdr:
            begin
            caselabellow := 0;
            caselabelhigh := 0;
            stmtblock := nil;
            stmtlabel := 0;
            orderedlink := 0;
            end;
          whilehdr, rpthdr, ifhdr, foruphdr, fordnhdr, withhdr, simplehdr,
          syscallhdr, untilhdr, cforhdr, cforbothdr, nohdr:
            begin
            expr1 := 0;
            expr2 := 0;
            has_break := false;
            trueblock := nil;
            falseblock := nil;
            end;
          loopbrkhdr, loopconthdr, swbrkhdr, cswbrkhdr: targblock := nil;
          gotohdr, labelhdr:
            begin
            labelno := 0;
            nonlocalref := false;
            labellevel := 0;
            end;
          otherwise
          end {case}
        end; {else}
      end; {with}
  end {newstmt} ;
  {>>>}
  {<<<}
  procedure newexprnode(var n: nodeindex {resulting new node} );
  { Allocates a new expression node in the virtual node space and initializes its fields. }

  var
    p: nodeptr; {used for access to node}

  begin
    if lastnode = tnodetablesize then abort(manynodes)
    else
      begin
      lastnode := lastnode + 1;
      if lastnode > maxnodes then maxnodes := lastnode;
      n := lastnode;
      p := ref(bignodetable[lastnode]);
      with p^ do
        begin
        {nice to use structured constant here }
        nodeform := exprnode;
        op := endexpr;
        form := none;
        action := visit;
        refcount := 0;
        copycount := 0;
        valid := false;
        mustinvalidate := false;
        join := false;
        target := false;
        relation := false;
        local := false;
        invariant := false;
        nodeoprnd[1] := false;
        nodeoprnd[2] := false;
        nodeoprnd[3] := false;
        cost := 0;
        prelink := 0;
        hoistedby := nil;
        looplink := 0;
        slink := 0;
        len := 0;
        hasvalue := false;
        ownvar := false;
        oprnds[1] := 0;
        oprnds[2] := 0;
        oprnds[3] := 0;
        oldlink := 0;
        end;
      end;
  end {newexprnode} ;
  {>>>}
  {<<<}
  function hash(op: operator; {operator of this node}
                i1, i2: integer {operand nodes} ): maphashindex;
  { Generate a hash function to speed search for identical nodes.
    It is set up so that all variables hash to the same value (0), so
    they can be searched easily for context changes.  For instance,
    all variables must be marked invalid when a label is encountered.

    This ignores the fact that the rval field overlays the operand fields.
    We simply take whatever happens to be there.  Since the values are
    initialized to zero before assigning to rval, the worse we can do
    is make the hash not as good.
  }
  begin
    if op in [varop, unsvarop] then hash := 0
    else
      begin
      if modworks then hash := (ord(op) + i1 + i2) mod nodehashsize + 1
      else hash := ((ord(op) + i1 + i2) and 32767) mod nodehashsize + 1;
      end;
  end {hash} ;
  {>>>}
  {<<<}
  procedure initbuild;
  {<<<}
  { Initialize the "build" procedure.  Called once before building each
    block body.  It resets the node counter "lastnode" to reuse nodes,
    initializes stack pointers, and clears context maps.
  }
  {>>>}

  var
    n: nodeindex; {dummy argument to newexprnode}
    i: shortint; {induction var for clearing opmap and virt mem}
    localvar: localvartype; { file read temp }
    ptr: nodeptr; { for access to node }
    j: reghashindex; { unsigned var for quicker mod }

  begin
    blockblocks := 0;
    thrashing := false;

    lastnode := - 1;
    laststmtnode := - 1;
    currentblock := nil;
    block_exit_block := nil;
    deadcount := 0;
    gotodead := 0;
    deadcode := false;
    dead_level := nil;
    swbreak_found := false;
    caselab_found := false;
    newexprnode(n);

    withsp := 0;
    forsp := 0;
    loopdepth := 0;
    loopoverflow := 0;
    contextsp := 2;
    overflowdepth := 0;

    this_loop := nil;
    this_case := nil;
    final_block_size := 0;

    with context[2] do
      begin
      for i := 0 to nodehashsize do opmap[i] := 0;
      searchlevel := 2;
      joinflag := false;
      dominates := true;
      firstblock := nil;
      end;

    with context[1] do
      begin
      opmap := context[2].opmap;
      searchlevel := 1;
      joinflag := false;
      dominates := false;
      firstblock := nil;
      end;
    shorteval := false;

    locallabels := nil;

    visitstate := false; { set initial state }

    { set option mask, do everything as default }
    sharedPtr^.genset := [firstgenopt..lastgenopt];

    { now remove some based on current switch value }
    if (sharedPtr^.switchcounters[debugging] > 0) or (sharedPtr^.switchcounters[profiling] > 0) or
       sharedPtr^.switcheverplus[targdebug] then
      begin
      sharedPtr^.genset := sharedPtr^.genset - [lifetimes, propagation, hoisting, removedeadcode,
                subexpressions, tailmerging, bitops];
      end;

    { now override these options based upon command line }
    if sharedPtr^.switcheverplus[genmask] then
      if sharedPtr^.genoptmask < 0 then
        sharedPtr^.genset := sharedPtr^.genset + sharedPtr^.overrideset
      else
        sharedPtr^.genset := sharedPtr^.genset - sharedPtr^.overrideset;

    nowdebugging := (sharedPtr^.switchcounters[debugging] > 0) or
                    (sharedPtr^.switchcounters[profiling] > 0) or
                    sharedPtr^.switcheverplus[targdebug];
    nowwalking := (sharedPtr^.switchcounters[walkback] > 0);
    exitStmtno := 0;

    { init the local var map }
    regvars[0].regid := 0;
    regvars[0].varlife.lonmin := 0;
    regvars[0].varlife.fonmin := 0;
    if lifetimes in sharedPtr^.genset then
      begin
      regvars[0].varlife.lonmax := 0;
      regvars[0].varlife.fonmin := shortmaxint;
      regvars[0].varlife.fonmax := 0;
      end
    else
      begin
      { no lifetimes set region to encompass entire block }
      regvars[0].varlife.lonmax := tnodetablesize;
      regvars[0].varlife.fonmin := 0;
      regvars[0].varlife.fonmax := shortmaxint;
      end;

    regvars[0].worth := - 1;
    regvars[0].registercandidate := false;

    for j := 1 to regtablelimit do
      begin
      regvars[j] := regvars[0];
      end;

    read (sharedPtr^.localFile, localvar);
    while localvar.typ <> none do
      begin
      { This hashes the var's offset, really should be a function call.
        However it would be called in several high bandwidth places and
        places an unneeded speed penalty on this phase.
        This code is replicated in doreference, killasreg, dodefine
        and walk:indxnode. }
      j := (localvar.offset div sharedPtr^.targetintsize) mod (regtablelimit + 1);
      while regvars[j].worth >= 0
        do j := (j + 1) mod (regtablelimit + 1);
      with regvars[j] do
        begin
        { figure out mapping from data type to register type }
        registercandidate := true;
        case localvar.typ of
          ptrs, fptrs: regkind := ptrreg;
          reals, doubles:
            if sharedPtr^.switcheverplus[fpc68881] then regkind := realreg
            else regkind := genreg;
          otherwise regkind := genreg;
          end {typ} ;
        offset := localvar.offset;
        debugrecord := localvar.debugrecord;
        parameter := false;

        { mark this spot as allocated }
        worth := 0;
        end;
      read (sharedPtr^.localFile, localvar);
      end;

    foncount := 0;
    loopfactor := 1; { every ref equal 1 ref }
    irreducible := false;
    localparamnode := 0;
  end;
  {>>>}
  {<<<}
  procedure addopmap(n: nodeindex; {node to add}
                     op: operator; {operator of that node}
                     hashvalue: maphashindex; {hash for node}
                     contextlevel: contextindex {context to add to} );
  { Add an operator to the opmap of the context specified by "contextlevel".
    Only those operators which can contribute to common subexpressions
    are added to the map.  Some are excluded (such as rd) because they
    have an important side-effect, while others are excluded because
    they are not useful.  The operator is included in the calling sequence
    to avoid a possible file access, only to discover that the node is
    not needed.
  }

  var
    p: nodeptr; {use to access op chain items}

  begin
    if (op >= intop) then
      with context[contextlevel] do
        begin
        p := ref(bignodetable[n]);
        p^.slink := opmap[hashvalue];
        { operators at contextlevel 1 are hoisted for free }
        if contextlevel = 1 then
          begin
          p^.prelink := p^.slink;
          p^.hoistedby := root;
          end;
        opmap[hashvalue] := n;
        end;
  end;
  {>>>}
  {<<<}
  procedure savecontext;
  {<<<}
  { Save the common expression context for entry into a new level of
    branching structure.  This is called on entry to an "if" or "case" to
    save the context for later restoration.  This allow each branch of
    the structure to start off with the same initial context.

    If contextsp = contextdepth, overflowdepth is incremented.  If not,
    a new level of the context stack is allocated with an initially clear
    opmap.  Each still valid expression has its "deepestvalid" field set
    to the new level, which allows the expressions to be reset to valid
    if they are invalidated at an inner level.  Since expressions are
    built bottom up (starting with the terminals), only variables need be
    marked.  This is simple to do because the hash function places all
    variables in opmap[0].
  }
  {>>>}

  var
    p: nodeptr; {used for access to nodes}
    i: shortint; {general purpose induction var}
    n: nodeindex; {used to trace list of nodes on opmap[0]}

  begin
    if contextsp = contextdepth then
      overflowdepth := overflowdepth + 1
    else
      begin
      contextsp := contextsp + 1;
      context[contextsp] := context[contextsp - 1];
      with context[contextsp] do
        begin
        firstblock := nil;
        joinflag := false;
        for i := 0 to nodehashsize do opmap[i] := 0;
        for i := searchlevel to contextsp do
          begin
          n := context[i].opmap[0];
          while n <> 0 do
            begin
            p := ref(bignodetable[n]);
            with p^ do
              begin
              if valid then
                begin
                deepestvalid := contextsp;
                end;
              n := slink;
              end;
            end;
          end;
        end;
      end;

    { entering a new context, it will not run }
    context[contextsp].dominates := false;
  end;
  {>>>}
  {<<<}
  procedure restorecontext;
  {<<<}
  { Restore the context to the state it had prior to a "savecontext".
    This is called on exit from an inner level of statement nesting to
    restore the context to the state it had on entry to the level.  Any
    nodes which were invalidated within the inner level have their
    joinflag set so that they will be invalidated in a later join.

    Also, if "deepestvalid" is greater than the current level, the
    valid" flag is set on, and "deepestvalid is reset to the current
    level.

    If overflowdepth > 0, we have overflowed the context stack and cannot
    properly restore context.  In this case, all nodes active at the current
    level are simply destroyed.  This is implemented by clearing the
    hash table for the current level.
  }
  {>>>}

  var
    p: nodeptr; {used for access to nodes}
    i: shortint; {Induction var for context level scan}
    n: nodeindex; {used to trace nodes on opmap[0]}


  begin
    if overflowdepth > 0 then
      begin
      overflowdepth := overflowdepth - 1;
      { since we've lost track assume the worst }
      context[contextsp].dominates := false;
      for i := 0 to nodehashsize do
        context[contextdepth].opmap[i] := 0;
      end

    else
      begin
      contextsp := contextsp - 1;
      with context[contextsp] do
        begin
        for i := searchlevel to contextsp do
          begin
          n := context[i].opmap[0];
          while n <> 0 do
            begin
            p := ref(bignodetable[n]);
            with p^ do
              begin
              join := join or not valid;
              if deepestvalid > contextsp then
                begin
                deepestvalid := contextsp;
                valid := true;
                end;
              n := slink;
              end;
            end;
          end;
        end;
      end;
  end;
  {>>>}
  {<<<}
  procedure popcontext;
  {<<<}
  { Used as a replacement for "restorecontext" when the restored
    values are no longer valid.  This is necessary because "break"
    can invalidate values from within a loop.  We pop the stack and
    leave variables invalidated rather than resetting them.
    we have to go through and reset deepestvalid, so we don't get
    to skip the scan.
  }
  {>>>}

  var
    p: nodeptr; {used for access to nodes}
    i: shortint; {Induction var for context level scan}
    n: nodeindex; {used to trace nodes on opmap[0]}

  begin
    if overflowdepth > 0 then
      begin
      overflowdepth := overflowdepth - 1;
      { since we've lost track assume the worst }
      context[contextsp].dominates := false;
      for i := 0 to nodehashsize do
        context[contextdepth].opmap[i] := 0;
      end

    else
      begin
      contextsp := contextsp - 1;
      with context[contextsp] do
        begin
        for i := searchlevel to contextsp do
          begin
          n := context[i].opmap[0];
          while n <> 0 do
            begin
            p := ref(bignodetable[n]);
            with p^ do
              begin
              join := join or not valid;
              if deepestvalid > contextsp then deepestvalid := contextsp;
              n := slink;
              end;
            end;
          end;
        end;
      end;
  end;
  {>>>}
  {<<<}
  procedure clearcontext;
  {<<<}
  { Clear the context.  Used in situations when it is impossible to
    predict what expressions will be available, such as procedure call,
    label, or entry to a looping construct.

    There is an optimization used here which may not be obvious.  The
    variable "searchlevel" (local to a context) defines the minimum
    context level which will be searched for common expressions.
    By setting this to the current context, all prior contexts are
    effectively cleared without the labor of invalidating all of the
    nodes in them.  the "joinflag" in a context is used in a manner
    similar to  the individual "join" flags in expression nodes.  It
    says that the entire context should be invalidated when a "join"
    is executed.
  }
  {>>>}

  var
    i: shortint; {general purpose induction var}

  begin
    with context[contextsp] do
      begin
      for i := 0 to nodehashsize do opmap[i] := 0;
      if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
        for i := 2 to contextsp - 1 do context[i].joinflag := true;
      searchlevel := contextsp;
      end;
  end;
  {>>>}
  {<<<}
  procedure joincontext;
  {<<<}
  { Join a set of branching paths.  Called at the end of all paths of a
    branching construct to invalidate all nodes which have been
    invalidated on any path.  Such nodes are marked with a "join" flag
    which was set in "restorecontext" if the node had been invalidated.
    If "joinflag" is set for this context level, the entire level is
    invalid and is cleared at this point.

    Note that join flags are left set.  This is necessary because the
    contexts may be nested, and the nodes may be validated again by an
    outer "restorecontext.

    "Deepestvalid" is also adjusted to the current level if it is
    greater than the current level.
  }
  {>>>}

  var
    p: nodeptr; {used for access to nodes}
    i: shortint; {Induction var for context level scan}
    n: nodeindex; {used to trace nodes on opmap[0]}

  begin
    with context[contextsp] do
      begin
      if joinflag then
        begin
        searchlevel := contextsp;
        for i := 0 to nodehashsize do opmap[i] := 0;
        end
      else
        begin
        for i := searchlevel to contextsp do
          begin
          n := context[i].opmap[0];
          while n <> 0 do
            begin
            p := ref(bignodetable[n]);
            with p^ do
              begin
              if deepestvalid > contextsp then deepestvalid := contextsp;
              if join then valid := false;
              n := slink;
              end;
            end;
          end;
        end;
      end;
  end;
  {>>>}
  {<<<}
  procedure pushloop(cblock: basicblockptr; {continue block}
                     bblock: basicblockptr {break block} );
  { Push a loop onto the list of currently active loops.  This is needed
    so that a break or continue statement can find its loop. The descriptor
    also saves data on blocks important to the loop.
  }
  var
    l: loop_descriptor;

  begin
    new(l);
    with l^ do
      begin
      outer := this_loop;
      cont_block := cblock;
      break_block := bblock;
      cont_found := false;
      break_found := false;
      looploop := false;
      end;
    this_loop := l;
  end;
  {>>>}
  {<<<}
  procedure poploop;
  { Pop a previously pushed loop }

  var
    l: loop_descriptor;

  begin
    l := this_loop;
    this_loop := l^.outer;
    dispose(l);
  end;
  {>>>}
  {<<<}
  procedure updatecontext;
  {<<<}
  { Called at the points in expression building where the results of
    updating a variable must be taken into account.  This is normally
    the point at which "newvarop"s are converted to "varops".  At
    this point, nodes which are marked "mustinvalidate" are invalidated,
    and the "mustinvalidate" flag is removed.  Such nodes are created
    when a "newvarop" is scanned.
  }
  {>>>}

  var
    i: 0..contextdepth; {induction var on context levels}

    {<<<}
    procedure clobber(n: nodeindex {start of node chain} );
    { Scan the chain of nodes beginning with "n" and invalidate any with the "mustinvalidate" flag set }

      var
        p: nodeptr; {used for access to nodes}

      begin
        while n <> 0 do
          begin
          p := ref(bignodetable[n]);
          with p^ do
            begin
            if valid and mustinvalidate then
              begin
              if deepestvalid > contextsp then deepestvalid := contextsp;
              valid := false;
              mustinvalidate := false;
              end;
            n := slink;
            end;
          end;
      end {clobber} ;
    {>>>}

  begin
    if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
      for i := context[contextsp].searchlevel to contextsp do
        clobber(context[i].opmap[0]);
  end;
  {>>>}
  {<<<}
  procedure updatenewvars(root: nodeindex {expression to process} );
  {<<<}
  { Scan an expression rooted in "root" and convert all "newvarop" and
    "newunsvarop" notes to "varop" and "unsvarop" nodes, then enter
    them in the local opmap.

    "Newvarop" is generated when the value of the variable is to be updated
    in the current expression.  This update doesn't take place until the
    end of the expression evaluation, so the old value of the variable is
    available for use in common subexpressions within that expression.
    the "newvarop" is not entered in the opmap, and so is not available
    for common expression matching.  At the time when the update takes place,
    the expression is scanned and all "newvarop" nodes are changed to
    "varop" nodes and entered in the opmap for use in common expression
    matching.

    The global "newvarcount" is used to reduce the amount of time spent
    scanning the expression, as the scan can now be stopped as soon as the
    value of "newvarcount" goes to zero.  This is global as it applies to
    all levels of the recursive scan.
  }
  {>>>}

  var
    cnt: oprndindex; { induction var for scanning operands}
    p: nodeptr;      { used for access to root node}
    newop: operator; { new operator if node is changed}

    {<<<}
    procedure killvars (low, high: levelindex);
    { We have been writing through a pointer, and some offsets are used as
      special flags to describe what levels are killed.  This routine
      actually does the killing.
    }

    var
      n: nodeindex; {for tracing list of nodes}
      p: nodeptr; {for access to nodes}
      i: contextindex; {induction var}

    begin
    end; {killvars}
    {>>>}

  begin
    while (newvarcount > 0) and (root <> 0) do
      begin
      p := ref (bignodetable[root]);
      if p^.action = visit then
        begin
        if (p^.op = newvarop) or (p^.op = newunsvarop) then
          begin
          newvarcount := newvarcount - 1;
          if p^.op = newvarop then newop := varop
          else newop := unsvarop;
          p^.op := newop;
          addopmap (root, newop, 0, contextsp);
          end
        else
          begin
          for cnt := 1 to 3 do
            if p^.nodeoprnd[cnt] and (newvarcount > 0) then
              begin
              updatenewvars (p^.oprnds[cnt]);
              p := ref(bignodetable[root]);
              end;
          if p^.op < intop then
            root := p^.slink
          else
            root := 0;
          end
        end
      else root := 0;
      end;
  end;
  {>>>}
  {<<<}
  procedure buildstmtlist (lasts: stmttype {statement to terminate build} ;
                           successorblock: basicblockptr { block succeeding this list of stmts } );
  { Build a sequential list of statements beginning at
    "currentblock^.beginstmt" and terminating when "lasts" is read from the input file.
    Statements which are executed sequentially (separated by ";" in the input) are simply linked  with the "nextstmt" field.
    Since all structured statements are fully bracketed in the intermediate file,
    it is sufficient simply to build statements until the ending bracket specified by "lasts" is read.
  }
    {<<<}
    procedure buildstmt;
    { Build a single statement and link it on the list defined by
      currentblock^.beginstmt and currentlaststmt.
      "beginstmt" is intialized to zero prior to the first
      call to this procedure, and will be left pointing to the first
      statement built.  "currentlaststmt" will always point to the last
      statement added to the list, to simplify adding statements to the end.

      The first statement in the intfile is examined, the proper internal
      procedure called to build that statement type, and the result is
      linked on the list.  This set of procedures is, of course, highly recursive }

    var
      thisstmt: nodeindex; {statement being built}
      ptr: nodeptr; { for access to statement node }

    {<<<}
    procedure assignvalue (movenode: nodeindex);
    {
      Purpose:
        Assign a literal value to var or unsvar node for use in constant
        propagation.

      Inputs:
        movenode : A movelit/move-intop node.

      Outputs:
        none

      Algorithm:
        Examine left hand side ( oprnd[1] ) of movenode to see if it
        is a simple variable ( i.e. not an array or pointer reference ).
        If movelit op so set value field to the value in oprnds[2].

      Sideeffects:
        Var node may change.

      Last Modified: 8/9/85
    }

      var
        thevar: nodeindex; { index of the var to assign value }
        thevalue: integer; { value to be assigned }
        ptr: nodeptr; { for access to nodes }


      begin {assignvalue}

        { top of stack is a movelit examine left hand side }

        ptr := ref(bignodetable[movenode]);
        if ptr^.op = movelit then thevalue := ptr^.oprnds[2]
        else
          begin
          ptr := ref(bignodetable[ptr^.oprnds[1]]);
          thevalue := ptr^.oprnds[1];
          end;
        thevar := ptr^.oprnds[1];
        { access the (new)varop }
        ptr := ref(bignodetable[thevar]);
        { see if it is simple }
        ptr := ref(bignodetable[ptr^.oprnds[3]]);
        if ptr^.op = indxop then
          begin
          ptr := ref(bignodetable[ptr^.oprnds[1]]);
          if ptr^.op = levop then
            begin
            ptr := ref(bignodetable[thevar]);
            ptr^.hasvalue := true;
            ptr^.value := thevalue;
            end;
          end;

      end {assignvalue} ;
    {>>>}
    {<<<}
    procedure buildproperptr (var oprnd: stackrecord; {opnd referenced}
                             contextlevel: contextindex {ref level} );
    { Build a valid local reference to an operand.  Since the operand is
      possibly defined at some outer context, and must have a copy node
      built in the local context, this routine scans all context levels
      from the operand definition level to the level at which it is used
      and inserts copy nodes if there are none already.  An appropriate
      copy node is then substituted for "oprnd".  The refcount and copycount
      of the base operand are incremented for each copy created.
      References within the local context do not need copies made, as changes
      in this node are easily taken into account by the code generator.

      Copy nodes for a context level are kept in a list based in the
      field "preconditions" for the first statement in the context.
      This list contains only copy nodes, and is generated prior to any
      other code for the statement.
    }

      var
        j: contextindex; {induction var for context search}
        originallink: nodeindex; {points to formal parent of node}
        n1, n2: nodeindex; {pointers for tracing node list}
        ptr, ptr2: nodeptr; {used for node access}
        foundcopy: boolean; {true if copy found at this level}


      begin
        with oprnd do
          if not litflag and not (deadcode and
             (removedeadcode in sharedPtr^.genset)) then
            begin
            if (l <> 1) then
              begin
              originallink := p;
              for j := l + 1 to contextlevel do
                with context[j] do
                  begin
                  n1 := firstblock^.precode;
                  foundcopy := false;
                  while (n1 <> 0) and not foundcopy do
                    begin
                    n2 := n1;
                    ptr := ref(bignodetable[n1]);
                    foundcopy := (ptr^.oldlink = p);
                    n1 := ptr^.prelink;
                    end;
                  if not foundcopy then
                    begin
                    newexprnode(n2);
                    ptr := ref(bignodetable[n2]);
                    ptr^.refcount := 0;
                    ptr^.copycount := 0;
                    ptr^.action := copy;
                    ptr^.prelink := firstblock^.precode;
                    ptr^.hoistedby := firstblock;
                    ptr^.oldlink := p;
                    ptr^.directlink := originallink;
                    firstblock^.precode := n2;
                    end;
                  ptr := ref(bignodetable[p]);
                  with ptr^ do
                    begin
                    refcount := refcount + 1;
                    if ptr^.action = visit then
                      if ptr^.op = commaop then
                        increfcount(ptr^.oprnds[2], deadcode, 1);
                    copycount := copycount + 1
                    end;
                  p := n2;
                  end;
              end;
            end;
      end {buildproperptr} ;
    {>>>}
    {<<<}
    function insertexpression (var n: workingnode;
                              contextlevel: contextindex;
                              isunique: boolean;
                              relationbuilt: boolean; { true if oprnds are
                                                       relations }
                              var lev: contextindex; { it's context level}
                              var uniquenode: boolean {inserted node is
                                                       unique}
                              ): nodeindex;

     { Insert a expression node in the specified context, if necessary, and push a
       stack element with a reference to that node.

       If there is any possibility that the node may be found in the
       context stack then all levels are searched from the specified out
       to the outermost still valid (searchlevel).  If the operand exists
       already, a reference to it is pushed onto the stack, otherwise
       a new node is created from the working node and entered into the
       specified level.  "IsUnique" is used to speed up the search, and if
       the node is a new one, "uniquenode" is set true to speed up search
       for operators using the node.
     }

      var
        level: shortint; {induction var for level search}
        insertindex: nodeindex; {prev node if found, else 0}

      {<<<}
      procedure compare(nindex: nodeindex; {candidate match}
                        var equal: boolean {set if matched} );
      { Compare the node being constructed with a candidate node to see if they
        belong to the same equivalence class.  An equivalence class is
        defined by having the operators equal and all operands equivalent,
        where copies are considered equivalent to the node which they copy.

        The first node created is the representative of the entire equivalence
        class, and all equivalent nodes are represented as copies of that node
        or as references to that node.  For a node to be a candidate for
        consideration by this routine, it must be valid.

        Note: all operands are compared using the "i" field, even though
        some of them are actually nodes.  This relies on storage layout of the
        records, so is machine dependent.
      }

        var
          p: nodeptr; {used for access to candidate}


        {<<<}
        function getclass(i: oprndindex {operand number} ): integer;
        {<<<}
        { Get the representative node of the equivalence class of operand
          "i" of the candidate node.  This routine simply gets the
          operand value if it is not a node (nodeoprnd off), or gets the node
          and strips off the copies to get the representative for the class.
        }
        {>>>}

          var
            ptr: nodeptr; {used to access node}


          begin
            with p^ do
              begin
              getclass := oprnds[i];
              if nodeoprnd[i] then
                begin
                ptr := ref(bignodetable[oprnds[i]]);
                if ptr^.action = copy then getclass := ptr^.directlink;
                end;
              end;
          end {Getclass} ;
        {>>>}


        begin {Compare}
          p := ref(bignodetable[nindex]);
          equal := p^.valid and (n.op = p^.op) and (n.form = p^.form) and
                   (n.len = p^.len);
          if equal then
            equal := (n.oprndlist[2].i = getclass(2)) and
                     (n.oprndlist[1].i = getclass(1)) and
                     (n.oprndlist[3].i = getclass(3));
        end {Compare} ;
      {>>>}
      {<<<}
      function addnode: nodeindex;
      { Create a new node and added it to the opmap at the specified level.
        This is called when there is no earlier expression to use.  First
        all operands are made available at the current level with "buildproperptr".
        The reference count for each operand is incremented, and then
        an new node is created an initialized with data from the workingnode
        "n" (global in buildnode).
      }

        var
          hashvalue: maphashindex; {node hash value}
          i1: oprndindex; {induction var for operand handling}
          ptr: nodeptr; {provides access to new node}
          newptr: nodeindex; {resulting node}


        begin {addnode}
          hashvalue := hash(n.op, n.oprndlist[1].i, n.oprndlist[2].i);
          if (n.op <> realop) then
            for i1 := 1 to 3 do
              with n, oprndlist[i1] do
                begin
                buildproperptr(oprndlist[i1], contextlevel);
                if not litflag then increfcount(p, deadcode, 1);
                end;
          newexprnode(newptr);
          addopmap(newptr, n.op, hashvalue, contextlevel);
          ptr := ref(bignodetable[newptr]);
          with ptr^ do
            begin
            refcount := 0;
            copycount := 0;
            action := visit;
            op := n.op;
            form := n.form;
            len := n.len;
            ownvar := n.ownvar;
            regcandidate := false; {dodefine will set if node is}
            if (deadcode and (removedeadcode in sharedPtr^.genset)) then
              valid := false {any language}
            else
              valid := true;
            cost := n.cost;
            relation := relationbuilt;
            local := cond_depth > 0;
            invariant := false;

            for i1 := 1 to 3 do
              with n.oprndlist[i1] do
                if not litflag then
                  begin
                  nodeoprnd[i1] := true;
                  oprnds[i1] := p;
                  end
                else oprnds[i1] := i;
            end;
          addnode := newptr;
        end {addnode} ;
      {>>>}
      {<<<}
      procedure searchcontext(contextlevel: contextindex;
                              var nindex: nodeindex {result} );

      { Search a specified context level for a node equivalent to "n".
        "Nindex is set to the node if one exists, otherwise to zero.

        The chain from the hash value in opmap is simply searched sequentially.
      }

        var
          n1: nodeindex; {Used to trace op map list}
          ptr: nodeptr; {Used for access to opmap nodes}
          found: boolean; {set if valid match is found}


        begin
          if (subexpressions in sharedPtr^.genset) or (contextlevel = 1) then
            begin
            n1 := context[contextlevel].opmap[hash(n.op, n.oprndlist[1].i,
                                                   n.oprndlist[2].i)];
            found := false;
            while not found and (n1 <> 0) do
              begin
              compare(n1, found);
              nindex := n1;
              ptr := ref(bignodetable[n1]);
              n1 := ptr^.slink;
              end;
            if not found then nindex := 0;
            end
          else nindex := 0;
        end {searchcontext} ;
      {>>>}

      begin {insertexpression}
              { if we are building useless stmts don't insert stuff
                into lower levels!
              }
        if (deadcode and (removedeadcode in sharedPtr^.genset)) then
          contextlevel := contextsp;
        level := contextlevel + 1;
        insertindex := 0;
        if not isunique and (n.op >= intop) and (n.form <> bools) and
           ((n.op <> sysfn) or (n.oprndlist[1].i <> ord(timeid))) and
           ((call_depth = 0) or (cond_depth = 0) or (contextlevel = 1)) then
          with context[contextlevel] do
            repeat
              level := level - 1;
              searchcontext(level, insertindex);
            until (level = searchlevel) or (insertindex <> 0);

        { if we didn't find it add it into the graph }

        if insertindex <> 0 then
          begin
          lev := level;
          insertexpression := insertindex;
          uniquenode := false;
          end
        else
          begin
          lev := contextlevel;
          insertexpression := addnode;
          uniquenode := true;
          end;
      end {insertexpression} ;
    {>>>}
    {<<<}
    function simplify (var root: integer): boolean;
    {<<<}
    {
        Purpose:
          Take the expression tree rooted in root and simplify it if possible.

        Inputs:
          root : root of expression tree.

        Outputs:
          root : root of modified expression tree.
          possibly modified/different expression tree.

        Algorithm:
          Search the tree for things we know how to simplify. This involves
          folding constant expressions. Also by using algebraic laws we
          can rearrange the expression so folding opportunities arise that
          otherwise wouldn't happen, e.g. "1+foo+5" ==> foo+1+5 ==> foo+6.
          Also some operators are converted to the "lit" flavor since some
          code generators appreciate it.

        Sideeffects:
          many if tree is modified.

        Last Modified: 8/8/85

    }
    {>>>}

      var
        nextroot: nodeindex; { for following slink chains }
        current: nodeindex; { sub graph we are working on now }
        ptr: nodeptr; { for accessing node }
        changes: boolean; { true if any important changes happen in a pass }
        intvalue: integer; { saved value of an integer operand }
        opnum: oprndindex; { operand we want to change }
        newop: operator; { new operator }
        newnode: workingnode; { basic intop node }
        result: boolean; { result of compare fold }
        op: operator; { save copy of node's op field }
        newoperands: operandarray; { copy of node's new oprnd field }
        oldoperands: operandarray; { saved copy of node's original oprnd field
                                    }
        nodeoperands: nodeoperandarray; { saved copy of node's nodeoprnd
                                         field}
        i: oprndindex; { induction var }


      {<<<}
      procedure binaryfold(procedure signedop
                                (left, right: integer;
                                 var result: integer;
                                 var overflow: boolean);
                           procedure unsignedop
                                (left, right: integer;
                                 var result: integer;
                                 var overflow: boolean);
                           associate: operator);
       {<<<}
       {
           Purpose:
             Try and do folding of binary operator.

           Inputs:
             signedop : signed folding routine.
             unsignedop : unsigned folding routine.
             associate : the operator we can do associative rearrangement with.
                         ( e.g. 1+a+3, addop is associate and becomes a + 4 )

           Outputs:
             none

           Algorithm:
             Simple at the present. If expression has intops (unsintop?) as
             only operands call the appropriate folding routine. Since unsintop
             does not yet exist problem can exist if signop does not return
             the same value as unsignedop. We ignore that problem for now. This
             is reasonably safe, but should be fixed. Also algorithm should be
             expanded at some point to use associative law to fold things like
             1 + foo + 5 to foo + 6.

           Sideeffects:
             graph is modified

           Last Modified: 6/27/85

       }
       {>>>}

        var
          overflow: boolean; { true if arithmetic overflow occurs during fold
                              }
          leftp, rightp: nodeptr; { for access left and right nodes }
          lev: contextindex; { dummy var }


        begin {binaryfold}
          leftp := ref(bignodetable[oldoperands[1]]);
          rightp := ref(bignodetable[oldoperands[2]]);
          if (leftp^.op = intop) and (leftp^.action = visit) then
            begin
            if (rightp^.op = intop) and (rightp^.action = visit) then
              begin
              { fold it return new root }
              signedop(leftp^.oprnds[1], rightp^.oprnds[1],
                       newnode.oprndlist[1].i, overflow);
              if not overflow then
                begin
                simplify := true;
        { Replace root with this new folded node.  "current" == "root"
          whenever folding is possible, so this works better than it looks.
        }
                root := insertexpression(newnode, 1, false, false, lev,
                                         result);
                increfcount(root, deadcode, 1);
                { 1 less use of the intop operands and this node }
          { don't bother this can drive refcount negative and intops
            are harmless anyway. When simplify is moved to improve phase
            this can come back.
          }
          {
          increfcount(oldoperands[1], deadcode, - 1);
          increfcount(oldoperands[2], deadcode,  - 1);
          }
                end
              else
                begin
                { give an error message??? }
                { for now ignore it }
                end;
              end
            else if associate <> endexpr then
              begin
              { search rest of expression for another intop }
              end;
            end
          else if (rightp^.action = visit) and (rightp^.op = intop) and
                  (associate <> endexpr) then
            begin
            { search rest of expression for another intop }
            end;
        end {binaryfold} ;
      {>>>}


      begin {simplify}
        simplify := false;
        changes := not (deadcode and (removedeadcode in sharedPtr^.genset));
        { init your basic intop }
        with newnode do
          begin
          len := sharedPtr^.targetintsize;
          cost := 0;
          form := none;
          op := intop;
          for i := 1 to 3 do
            with oprndlist[i] do
              begin
              relation := false;
              litflag := true;
              i := 0;
              end;
          end;
        while changes do
          begin
          changes := false;
          current := root;
          while current <> 0 do
            begin
            nextroot := 0;
            ptr := ref(bignodetable[current]);
            if (ptr^.action = visit) then
              begin
              if (ptr^.op < intop) then nextroot := ptr^.slink;
        { can't simplify any cse's since we would have to find the
          other reference(s) to this node.
        }
              if (ptr^.form in
                 [none, ints, chars, subranges, bools, scalars]) and
                 (ptr^.refcount <= 1) then
                begin
                op := ptr^.op;
                oldoperands := ptr^.oprnds;
                newoperands := oldoperands;
                nodeoperands := ptr^.nodeoprnd;
                for i := 1 to 3 do
                  begin
                  if nodeoperands[i] then
                    begin
                    if simplify(newoperands[i]) then
                      begin
                      ptr := ref(bignodetable[oldoperands[i]]);
                      if ptr^.action = visit then
                        if (ptr^.op < intop) and (ptr^.op > newunsvarop) then
                          while ptr^.slink <> 0 do
                            begin
                            oldoperands[i] := ptr^.slink;
                            ptr := ref(bignodetable[oldoperands[i]]);
                            end;
                      ptr := ref(bignodetable[oldoperands[i]]);
                      ptr^.refcount := ptr^.refcount - 1;
                      ptr^.valid := ptr^.refcount > 0;
                      changes := true;
                      end;
                    end;
                  end;
                { make the changes in this node }
                if changes then
                  begin
                  ptr := ref(bignodetable[current]);
                  ptr^.oprnds := newoperands;
                  end;
                { now can we simplify this node }
                case op of
                  defforindexop, defunsforindexop, moveop, pushvalue:
                    begin
            { if previous changes made oprnd[opnum] constant
              change to lit type.  However don't count as a change
              since it is harmless }
                    case ptr^.op of
                      defforindexop:
                        begin
                        opnum := 3;
                        newop := defforlitindexop;
                        end;
                      defunsforindexop:
                        begin
                        opnum := 3;
                        newop := defunsforlitindexop;
                        end;
                      moveop:
                        begin
                        opnum := 2;
                        newop := movelit;
                        end;
                      pushvalue:
                        begin
                        opnum := 1;
                        newop := pushlitvalue;
                        end;
                      otherwise
                      end;
                    ptr := ref(bignodetable[newoperands[opnum]]);
                    if (ptr^.op = intop) and (ptr^.action = visit) then
                      begin
                      { remove ref count from the intop }
                      intvalue := ptr^.oprnds[1];
                      ptr^.refcount := ptr^.refcount - 1;
                      ptr := ref(bignodetable[current]);
                      ptr^.op := newop;
                      ptr^.oprnds[opnum] := intvalue;
                      ptr^.nodeoprnd[opnum] := false;
                      if (newop = movelit) and (propagation in sharedPtr^.genset) then
                        assignvalue(current);
                      end;
                    end;
                  lssop, leqop, neqop, eqop, gtrop, geqop:
                    begin
                    { if foldable do it, or if convertable to lit type do it }
                    ptr := ref(bignodetable[newoperands[2]]);
                    if (ptr^.op = intop) and (ptr^.action = visit) then
                      begin
                      { at least convert to lit form }
                      intvalue := ptr^.oprnds[1];
                      ptr := ref(bignodetable[newoperands[1]]);
                      if (ptr^.op = intop) and (ptr^.action = visit) then
                        case op of
                          lsslit: result := intvalue < ptr^.oprnds[1];
                          leqlit: result := intvalue <= ptr^.oprnds[1];
                          gtrlit: result := intvalue > ptr^.oprnds[1];
                          geqlit: result := intvalue >= ptr^.oprnds[1];
                          eqlit: result := intvalue = ptr^.oprnds[1];
                          neqlit: result := intvalue <> ptr^.oprnds[1];
                          end
                      else
                        begin
                        ptr := ref(bignodetable[current]);
                        ptr^.nodeoprnd[2] := false;
                        ptr^.oprnds[2] := intvalue;
                        case op of
                          lssop: ptr^.op := lsslit;
                          leqop: ptr^.op := leqlit;
                          neqop: ptr^.op := neqlit;
                          eqop: ptr^.op := eqlit;
                          gtrop: ptr^.op := gtrlit;
                          geqop: ptr^.op := geqlit;
                          end;
                        end;
                      end
                    end;
                  lsslit, leqlit, eqlit, neqlit, gtrlit, geqlit:
                    begin
                    intvalue := ptr^.oprnds[2]; {???}
                    ptr := ref(bignodetable[newoperands[1]]);
                    if false and (ptr^.op = intop) and
                       (ptr^.action = visit) then
                      begin
                { can't really do the folding here yet since operands
                  could be unsigned and that will surely give wrong
                  results.
                }
                      changes := true;
                      case op of
                        lsslit: result := intvalue < ptr^.oprnds[1];
                        leqlit: result := intvalue <= ptr^.oprnds[1];
                        gtrlit: result := intvalue > ptr^.oprnds[1];
                        geqlit: result := intvalue >= ptr^.oprnds[1];
                        eqlit: result := intvalue = ptr^.oprnds[1];
                        neqlit: result := intvalue <> ptr^.oprnds[1];
                        end
                      end;
                    end;
                  andop, orop:
                    begin
                    end;
                  plusop: binaryfold(add, usadd, plusop);
                  minusop: binaryfold(subtract, ussubtract, endexpr);
                  mulop: binaryfold(multiply, usmultiply, mulop);
                  kwoop: binaryfold(divide, usdivide, endexpr);
                  modop, stdmodop:
                    binaryfold(remainder, usremainder, endexpr);
                  divop, stddivop, quoop, remop:
                    begin
                    end;
                  negop, notop:
                    begin
                    end;
                  incop, decop:
                    begin
                    end;
                  { shiftlop some day...: }
                  otherwise;
                  end; {case}
                end; {if foldable }
              end;
            current := nextroot;
            end; {while root}
          end; {while changes}

      end {simplify} ;
    {>>>}
    {<<<}
    function buildexpr: nodeindex;
    { Build an expression tree.  Called from various statement building
      procedures to build an expression (or group of expressions).

      This procedure reads the intermediate file and builds expressions
      until it reads an "endexpr" operator.  This may be a complicated
      group of expressions, for instance a procedure call with all arguments,
      but it will always be a tree with a single root, which is placed
      in "root".

      The tree as built must have assignment targets noted in it, an
      improvement which allows better code generation.  C allows nested
      assignment statements, so we can't use a simple on-the-fly
      algorighm to pick these up.  Instead, a "moveop" scans the left
      side looking for targets, then the right side marking instances
      of the target variable.  This is all done by the "marktargets"
      routine.
    }

      var
        stackp: nodeptr;

      {<<<}
      procedure sequence_point;
      { Invalidate all newvarops anywhere on the stack }

        var
          i: natural;


        begin
          for i := sp downto 1 do
            if not stack[sp].litflag then updatenewvars(stack[sp].p);
          updatecontext;
        end;
      {>>>}
      {<<<}
      procedure clear_expr(expr: nodeindex; {expression to clear}
                           mark: nodeindex {last valid node} );
      {<<<}
      { Scan an expression and invalidate all nodes which are later than "mark".
        This is used for conditional expressions, which may generate values on
        one path which do not exist on the other.  We don't try to take into
        account expressions which might be invalidated on one path and not the
        other.  We don't have enough bookkeeping info in the nodes for that
        one.  In some better world conditional expressions would be handled like
        all other control flow, but we don't have that yet.
      }
      {>>>}

        var
          p: nodeptr; {for access to entry}
          n: node; {local copy of the node}
          i: 1..3; {for scanning operands}


        begin
          if expr > mark then
            begin
            p := ref(bignodetable[expr]);
            p^.valid := false;
            if p^.action in [visit, revisit] then
              begin
              n := p^;
              for i := 1 to 3 do
                if n.nodeoprnd[i] then clear_expr(n.oprnds[i], mark);
              if (n.slink <> 0) and (n.op < intop) then
                clear_expr(n.slink, mark);
              end;
            end;
        end; {clear_expr}
      {>>>}
      {<<<}
      procedure marktargets(left, right: nodeindex);
      { Scan the left side looking for a newvarnode, then scan the right side
        looking for varnodes with matching displacement.  The target flag is
        set in any matching nodes.
      }

        var
          targfound: boolean; {we have found a target}
          targlev: integer; {target level}
          targoff: integer; {target offset}


        {<<<}
        procedure define_target(n: nodeindex);
        { Scan a tree, searching for newvarops.  We check for the deepest
          nodes first in the fond hope that we will pick up the earliest
          newvarop.  Other ones might arise because we find volatile variables
          in C or "origin" variables in Pascal.
        }

          var
            op: operator; {local copy of operator}
            oprnds: operandarray; {local copy of operands}
            nodeoprnd: nodeoperandarray; {says if oprnds are nodes}
            p: nodeptr; {for access to node}
            i: oprndindex; {induction var}


          begin {define_target}
            if n <> 0 then
              begin
              p := ref(bignodetable[n]);
              if p^.action = copy then
                begin
                n := p^.directlink;
                p := ref(bignodetable[n]);
                end;

              op := p^.op;
              oprnds := p^.oprnds;
              nodeoprnd := p^.nodeoprnd;
              for i := 1 to 3 do
                if nodeoprnd[i] then define_target(oprnds[i]);
              if targfound and
                 (op in [newvarop, newunsvarop, varop, unsvarop]) then
                begin
                if (targlev = oprnds[1]) and (targoff = oprnds[2]) then
                  begin
                  p^.target := true;
                  p^.mustinvalidate := true;
                  end;
                end
              else if (op = newvarop) or (op = newunsvarop) then
                begin
                targfound := true;
                targlev := oprnds[1];
                targoff := oprnds[2];
                end;
              end;
          end; {define_target}
        {>>>}


        begin {marktargets}
          targfound := false;
          define_target(left);
          if targfound then define_target(right);
        end; {marktargets}
      {>>>}
      {<<<}
      procedure buildnode;
      {<<<}
      { Build the kind of node specified by the current operator in the intermediate
        file.  The node built will be left in stack[sp], and may consume operands
        which are already on the stack.

        The body of the procedure consists of a large case statement which
        selects the proper action for the particular node being built.

        The basic action for most nodes is to gather data in a working
        node, search the available context for a congruent node, and return
        a new node, a copy of an old node at an outer context, or a reference
        to an old node at the current context level.  For some nodes, of course,
        there are special actions needed.  If the node is new, and eligible
        for common expression use, it is inserted in the opmap of the current
        context.

        The "unique" flag is used to signal that the node contains at
        least one unique operand, so there is no need to search for it.
        This eliminates a lot of unnecessary searching.

        Some special nodes, such as constants, are inserted in context[1].
        Nodes in this context level are emitted at the beginning of the block,
        and no copies of them are ever made, since the code generator will
        never modify them.
      }
      {>>>}

      var
        relationbuilt: boolean; {There is a relation in this node}
        unique: boolean; {set if no possibility of prior congru. expr}
        ptr: nodeptr; {used for access to an operand node}
        tmp: stackrecord; {used to hold stack top for swap and temp}
        n: workingnode; {used to accumulate operands for node}
        i: oprndindex; {induction var for operand search}
        cnvts: standardids; {converted standard id}

      {<<<}
      procedure insertnode(contextlevel: contextindex);
      { Insert a node in the specified context, if necessary, and push a
        stack element with a reference to that node.
      }
        begin {Insertnode}
          if sp = maxexprstack then abort(manytemps);
          sp := sp + 1;
          with stack[sp] do
            begin
            context_mark := 0;
            litflag := false;
            i := 0; {clear any previous junk}
            relation := relationbuilt;
            p := insertexpression(n, contextlevel, unique, relationbuilt, l,
                                  uniqueoprnd);
            end;
        end {insertnode} ;
      {>>>}
      {<<<}
      procedure insertnormal;
      { Insert a node in the current context, the normal action. }

        begin
          insertnode(contextsp);
        end {insertnormal} ;
      {>>>}
      {<<<}
      procedure insertsequential;
      { Insert a node which can be linked by the sequential link (slink) to
        the previous node.  This is the case if oprnds[1] points to the previous
        node, and the result of evaluating the previous nodes is not used by
        this node.
      }

        var
          newexprnode: nodeindex; {index for this node}
          newptr: nodeptr; {used to access top element on the stack}
          prevnode: nodeindex; {prior node}
          prevptr: nodeptr; {used to access previous operator}


        begin
          insertnormal;
          newexprnode := stack[sp].p;
          newptr := ref(bignodetable[newexprnode]);
          if newptr^.oprnds[1] <> 0 then
            begin
            prevnode := newptr^.oprnds[1];
            prevptr := ref(bignodetable[prevnode]);
            if prevptr^.action = visit then
              if (prevptr^.op > newunsvarop) and (prevptr^.op < intop) then
                begin
                stack[sp].p := newptr^.oprnds[1];
                newptr^.oprnds[1] := 0;
                newptr^.nodeoprnd[1] := false;
                while prevptr^.slink <> 0 do
                  begin
                  prevnode := prevptr^.slink;
                  prevptr := ref(bignodetable[prevnode]);
                  end;
                prevptr := ref(bignodetable[prevnode]);
                prevptr^.slink := newexprnode;
                end;
            end;
        end; {insertsequential}
      {>>>}

      {<<<}
      procedure buildintoprnds(count: oprndindex {number to build} );
      { Build "count" literal integer operands in the workingnode "n".
        These operands take their values from the next "count" records
        in the intfile.
      }

        var
          t: oprndindex; {induction var}


        begin
          for t := 1 to count do
            with n.oprndlist[t] do
              begin
              getintfile;
              litflag := true;
              relation := false;
              i := getintfileint;
              end;
        end {buildintopnrds} ;
      {>>>}

      {<<<}
      procedure collectopdata;
      { Collect the operand data (length, cost, form) provided with the
        normal binary or unary operands and save it in the workingnode "n".
      }


        begin
          getintfile;
          n.len := getintfileint;
          getintfile;
          n.cost := min(getintfileint, maxcost);
          getintfile;
          n.form := interSharedPtr^.interFile^.block[nextintcode].f;
        end {collectopdata} ;
      {>>>}
      {<<<}
      procedure collectoprnds(count: oprndindex {number of opnds} );
      {<<<}
      { Collect "count" operands from the top of the stack and save them in
        the workingnode "n".  The global variables "unique" and "relationbuilt"
        are set if they are true for any operand.  If a relation is built, it
        is noted as part of the "cost" field in "n".  This is a hack to
        save data space during bootstrap.
      }
      {>>>}

        var
          i: oprndindex; {induction variable}


        begin
          for i := count downto 1 do
            begin
            unique := unique or stack[sp].uniqueoprnd;
            n.oprndlist[i] := stack[sp];
            sp := sp - 1
            end;
        end {collectoprnds} ;
      {>>>}
      {<<<}
      procedure collectwork(count: oprndindex {operand count} );
      { Do the work of collecting all necessary data for an operator.
        First the operator data is read, then "count" arguments obtained from
        the stack.  The results are left in "n".
      }


        begin
          collectopdata;
          collectoprnds(count);
        end {collectwork} ;
      {>>>}
      {<<<}
      procedure collectargs(count: oprndindex {operand count} );
      { Collect data for a node with "count" operands, then create the
        node, insert it in the appropriate context, and push a reference
        to the node onto the stack.
      }


        begin
          collectwork(count);
          insertnormal;
        end {collectargs} ;
      {>>>}
      {<<<}
      procedure collectseqargs(count: oprndindex {operand count} );
      { The same as collect args, except that "insertsequential" is used instead of "insertnormal }

        begin
          collectwork(count);
          insertsequential;
        end; {collectseqargs}
      {>>>}
      {<<<}
      procedure killaffectedvars(s: stackindex {stack entry holding proc} );
      { Kill variables affected by current procedure call or procedure push.  For
        procedure params death to variables occurs somewhat before their allotted
        time has expired by Pascal semantics, but not by much.  Since proc params
        are quite rare we don't worry too much about "sub-optimality" in this case.
      }

        var
          i: contextindex; {induction var on context levels}
          l, u: levelindex; {Level bounds within which to invalidate}
          cr: cseregionindex; {for clobbering cse's}

        {<<<}
        procedure clobber(nindex: nodeindex {start of chain} );
        { Invalidate all variables on the chain headed by "nindex" which
          have lex levels between "l" and "u" inclusive, and, if global,
          fall within the deadly bounds of the proper cseregion.
        }

          var
            ptr: nodeptr; {used for access to nodes}


          begin
            while nindex <> 0 do
              begin
              ptr := ref(bignodetable[nindex]);
              with ptr^ do
                begin
                if (oprnds[1] >= l) and (oprnds[1] <= u) and
                   ((oprnds[1] > 1) or
                   (oprnds[2] >= sharedPtr^.cseregiontable[cr, ownvar].low) and
                   (oprnds[2] <= sharedPtr^.cseregiontable[cr, ownvar].high)) then
                  begin
                  valid := false;
                  if deepestvalid > contextsp then
                    begin
                    deepestvalid := contextsp;
                    end;
                  end;
                nindex := slink;
                end;
              end;
          end {clobber} ;
        {>>>}

        begin {killaffectedvars}
          if stack[s].litflag then
            begin
            if newtravrsinterface then
              with sharedPtr^.new_proctable[stack[s].i div (pts + 1)]^[stack[s].i mod
                   (pts + 1)] do
                begin
                if stack[s].i <= cseregions then cr := stack[s].i
                else cr := 0;
                if globaldeath then l := 0
                else l := 2;
                if intlevelrefs then u := level - 1
                else u := 1;
                end
            else
              with sharedPtr^.proctable[stack[s].i] do
                begin
                if stack[s].i <= cseregions then cr := stack[s].i
                else cr := 0;
                if globaldeath then l := 0
                else l := 2;
                if intlevelrefs then u := level - 1
                else u := 1;
                end
            end
          else
            begin
            cr := 0;
            l := 0;
            u := level - 1;
            end;
          if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
            begin
            if loopdepth > 0 then loopkill(l, u);
            for i := context[contextsp].searchlevel to contextsp do
              clobber(context[i].opmap[0]);
            updatecontext;
            end;
        end {killaffectedvars} ;
      {>>>}

      {<<<}
      procedure callnode;
      { Build a node for a procedure call.  This has three operands, a
        literal with the proc index (for an explicit proc) or a node index
        (for a proc parameter), the "reserve" for the return value, and
        the parameter list.

        All newvarops in the parameter list must be converted to varops, and
        any variables which were modified must be invalidated.  Also, since
        no detailed data is kept on what variables are modified by the called
        procedure,  all variable which are defined at lex levels which the
        procedure might access must be invalidated.  In the case of a parameter
        procedure, we must assume that it can destroy everything in sight.
        If the procedure makes no references except to local and global
        variables, (intlevelrefs false) there is no need to invalidate
        intermediate level variables.

        The level and displacement are stored as operands in the varops for
        just this purpose.  Note that pointers and file buffer variables have
        a "level" of 0, and are invalidated whenever global vars are invalidated.
        The field "globaldeath" in the procedure table is used to indicate the
        need for global invalidation.
      }

        var
          final: nodeindex; { index of final node on parm list }
          reserve: nodeindex; { index of reserve node on parm list }
          reverseparms: boolean; { true if we should reverse param list}

        {<<<}
        function reverse(current, previous: nodeindex): nodeindex;
        {
            Purpose:
              reverse the a link list of nodes linked through slink.

            Inputs:
              current : index of node we must switch slink field.
              previous : new value for slink field.

            Outputs:
              reverse : index of tail node in the list

            Algorithm:
              straight forward.

            Sideeffects:
              changes the nodes as described.

            Last Modified: 9/23/85

        }

          var
            ptr: nodeptr; { for access to current node }


          begin {reverse}
            ptr := ref(bignodetable[current]);
            if ptr^.slink = 0 then
              begin
              reverse := current;
              ptr^.slink := previous;
              end
            else
              begin
              reverse := reverse(ptr^.slink, current);
              ptr^.slink := previous;
              end;
          end {reverse} ;
        {>>>}


        begin
          call_depth := call_depth - 1;
          updatenewvars(stack[sp - 1].p);
          reverseparms := false;
          with stack[sp - 2] do
            if litflag then
            { reverse parameters if calling c on some machines }
              if newtravrsinterface then
                begin
                with sharedPtr^.new_proctable[i div (pts + 1)]^[i mod (pts + 1)] do
                  if (calllinkage = nonpascalcall) and (stack[sp].i > 1) then
                    begin
                    reverseparms := true;
                    { remember where reserveop is while it's cheap }
                    reserve := stack[sp - 1].p;
                    end
                end
              else
                begin
                with sharedPtr^.proctable[i] do
                  if (calllinkage = nonpascalcall) and (stack[sp].i > 1) then
                    begin
                    reverseparms := true;
                    { remember where reserveop is while it's cheap }
                    reserve := stack[sp - 1].p;
                    end;
                end;
          killaffectedvars(sp - 2);
          collectargs(3);
            { now that all the refcounts are set reverse parameter list
             if calling "c".
            }
          if reverseparms then
            begin
            { first on list is the reserve }
              ptr := ref(bignodetable[reserve]);
              ptr^.slink := reverse(ptr^.slink, 0);
            end;

        end {callnode} ;
      {>>>}
      {<<<}
      procedure pushprocnode;


        begin {pushprocnode}
          killaffectedvars(sp);
          collectseqargs(3);
        end {pushprocnode} ;
      {>>>}
      {<<<}
      procedure buildvarnode;
      { Build a node for a variable reference.  The length of the variable is
        read from the file, then level and displacement are read and made into
        operands 1 and 2.  These are used as an identification for the
        variable when specific variables need to be invalidated, or for checking
        for the target.

        If the variable is the same as the target, it is marked as a target node
        and the "mustinvalidate" bit is set to invalidate this node at the next
        update time.
        If the variable has a known value we substitute a reference to it's
        value which is much cheaper.
      }

        var
          stackp: nodeptr; {used to access top of stack node}
          i: oprndindex; { induction var }


        begin {buildvar}
          getintfile;
          n.len := getintfileint;
          buildintoprnds(2);
          n.oprndlist[3] := stack[sp];
          getintfile;
          unique := false;
          n.ownvar := loophole(boolean, getintfileint);
          sp := sp - 1;
          insertnormal;
          stackp := ref(bignodetable[stack[sp].p]);

          { if the var has a value assigned use that instead }
          {travrs does not yet handle extended range variables...}
          if stackp^.hasvalue and ((n.op = varop) or
             (stackp^.value > 0)) then
            begin
            { should tell some one that operand is now a literal
              and can be folded. Future plans...
            }
            n.op := intop;
            n.len := sharedPtr^.targetintsize;
            n.oprndlist[1].i := stackp^.value;
            n.oprndlist[2].i := 0;
            n.oprndlist[3].i := 0;
            for i := 1 to 3 do
              begin
              n.oprndlist[i].litflag := true;
              n.oprndlist[i].relation := false;
              end;
            sp := sp - 1;
            insertnode(1);
            end
          else
            begin
            unique := n.oprndlist[3].uniqueoprnd;
            if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
              doreference(stack[sp].p);
            end;
        end {buildvarnode} ;
      {>>>}
      {<<<}
      procedure buildnewvarnode;
      { Build a node for a "newvarop" or "newunsvarop".  This is a flag
        to the tree builder that this is going to be an assignment target,
        and will be changed to a "varop" at the next update time.  In the mean
        time, references to the variable of the same name can be optimized.

        All variables which match in level and displacement will have their
        "mustinvalidate" flag set so they will become invalid at the
        next update.
      }

        var
          j: contextindex; {induction var on levels}
          stackp: nodeptr; {used to access top of stack node}
          p: nodeptr; { for access to nodes }


        {<<<}
        procedure clobber(n1: nodeindex {start of chain} );
        { Set the "mustinvalidate" flag for all variable nodes on the
          chain rooted in "n1" which have the same level and displacement as
          the variable being created.

          The global "newvarcount" is incremented to keep track of how many
          are created.  This allows termination of the scan on "updatecontext"
          as soon as all targets are accounted for.
        }

          var
            ptr: nodeptr; {used for node access}


          begin
            while n1 <> 0 do
              begin
              ptr := ref(bignodetable[n1]);
              with ptr^ do
                begin
                if valid and (oprnds[1] = n.oprndlist[1].i) and
                   (oprnds[2] = n.oprndlist[2].i) then
                  begin
                  mustinvalidate := true;
                  end;
                n1 := ptr^.slink;
                end;
              end;
          end {clobber} ;
        {>>>}

        begin
          { if dead part of tree don't recognize this }
          if (deadcode and (removedeadcode in sharedPtr^.genset)) then
            begin
            n.op := varop;
            buildvarnode;
            end
          else
            begin
            getintfile;
            n.len := getintfileint;
            buildintoprnds(2);
            n.oprndlist[3] := stack[sp];
            getintfile;
            unique := false;
            n.ownvar := loophole(boolean, getintfileint);
            sp := sp - 1;
            insertnormal;
            dodefine(stack[sp].p);
            for j := contextsp downto context[contextsp].searchlevel do
              clobber(context[j].opmap[0]);
            newvarcount := newvarcount + 1;
            end;
        end {buildnewvarnode} ;
      {>>>}
      {<<<}
      procedure builddeffor;
      { Build a defforindex operator.  Only tricky thing is that we must
        remove the effect of the "dodefine" spawned by the control var's
        definition.  It will be re-inserted inside the for loop by the
        routine "buildfor"
       }

        var
          p: nodeptr;


        begin {builddeffor}
          { must defer the define until after from and to done }
          getintfile;
          n.len := getintfileint;
          buildintoprnds(1);
          n.oprndlist[3] := stack[sp];
          sp := sp - 1;
          n.oprndlist[2] := stack[sp];
          sp := sp - 1;
          insertnormal;
          p := ref(bignodetable[n.oprndlist[2].p]);

          { If we're within a loop, unhook for-loop control variable
            from the list of writes, as it really belongs within the
            loop (gets "more valuable" and more likely to be assigned
            a register).  If we don't unhook, exitloop will hook 'em
            in a circle as it appends the inner-loop writes to the outer
            loop's.  It doesn't check for duplicates, as this is impossible
            except for for-loops control vars, which are explicit CSE's
            throughout the life of the loop.  Of course, if this is a
            dead level, it hasn't been put on the write list at all,
            in which case we probably ought not remove it!
          }

          if (loopdepth > 0) and
             not loopstack[loopdepth].deadlevels[level] then
            begin
            p := ref(bignodetable[n.oprndlist[2].p]);
            loopstack[loopdepth].writes := p^.looplink;
            if loopstack[loopdepth].writes = 0 then
              loopstack[loopdepth].lastwrite := 0;
            p^.looplink := 0;
            end;

          with forstack[forsp], stack[sp] do
            begin
            forref := p;
            forlevel := l;
            end;
        end {builddeffor} ;
      {>>>}
      {<<<}
      procedure pushlitint;
      { Push a literal integer onto the stack }

        begin
          if sp = maxexprstack then abort(manytemps);
          sp := sp + 1;
          with stack[sp] do
            begin
            context_mark := 0;
            relation := false;
            litflag := true;
            uniqueoprnd := false;
            getintfile;
            i := getintfileint;
            end;
        end;
      {>>>}
      {<<<}
      procedure buildptrnode;
      { Build a node for a NIL pointer.  This is inserted into the tree as an integer value }


        begin {buildptrnode}
          n.len := sharedPtr^.ptrsize;
          pushlitint;
          collectoprnds(1);
          insertnode(1);
        end {buildptrnode} ;
      {>>>}
      {<<<}
      procedure buildrealnode(rsize: shortint; {size of a real}
                              form: types {reals or doubles} );
      {<<<}
      { Build a node for a real number.

        Currently, only "C" represents all real constants in IEEE extended
        form, as other language definitions make no provision for compile
        time (i.e. folding) arithmetic to yield different answers than
        calculations performed at runtime.

        Build a node for a real number.  This is inserted into the
        tree as a set of nodes, with the least significant part
        being inserted first. This allows the sharing of these
        nodes.  They will be written as a unit when the tree is
        walked. The chain of values is linked through oprnds[3],
        and the chain is terminated when oprnds[3] = 0.
      }
      {>>>}

        var
          intpieces, {number of integers per real}
           j: 0..maxrealwords; {induction var}


        begin
          n.len := rsize;
          n.form := form;
          intpieces := size(realarray) div (hostfileunits * hostintsize);

          for j := 1 to intpieces do
            pushlitint;

          if odd(intpieces) then
            j := 1
          else
            j := 2;

          collectoprnds(j);
          insertnode(1);
          intpieces := intpieces - j;

          while intpieces > 0 do
            begin
            collectoprnds(3);
            insertnode(1);
            intpieces := intpieces - 2;
            end;
        end {buildreal} ;
      {>>>}

      begin
        { Initialize the working node }
        relationbuilt := false;
        unique := false;
          { if the statement we are collecting now are useless don't search for them! }
        unique := deadcode and (removedeadcode in sharedPtr^.genset);
        n.len := sharedPtr^.targetintsize;
        n.cost := 0;
        n.ownvar := false;
        n.op := interSharedPtr^.interFile^.block[nextintcode].o;
        n.form := none;
        for i := 1 to 3 do
          with n.oprndlist[i] do
            begin
            relation := false;
            litflag := true;
            l := 0;
            i := 0
            end;

        case n.op of
          jumpvfuncop:
            begin
            buildintoprnds(2);
            insertnormal;
            end;

          deleteop:
            begin
            collectwork(1);
            increfcount(n.oprndlist[1].p, deadcode, - 1);
            end;

          addrop:
            begin
            { must remove as register candidate}
            { top of stack is var we want address of }
            if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
              begin
              killasreg(stack[sp].p);
              end;
            collectargs(1);
            end;
          float, negop, indrop, filebufindrop, incop, decop, remop, quoop,
          ptrchkop, pushcvalue, definelazyop, setbinfileop, copystackop,
          closerangeop, chrstrop, arraystrop, groupop, compop, float_double,
          real_to_dbl, dbl_to_real:
            collectargs(1);
          tempop:
            begin
            collectwork(1);
            unique := true;
            insertnormal;
            end;
          dummyargop: collectseqargs(2);
          setfileop:
            begin
            killinput := false;
            collectargs(1);
            end;
          pushfinal:
            begin
            collectargs(1);
            ptr := ref(bignodetable[n.oprndlist[1].p]);
            if (ptr^.action = visit) and (ptr^.op = intop) then
              begin
              { just return the integer }
              stack[sp].p := n.oprndlist[1].p;
              end;
            end;
          wr: collectseqargs(1);
          rd:
            begin
            collectopdata;
            if n.form in [arrays, strings, files] then collectoprnds(1)
            else collectoprnds(2);
            insertsequential;
            end;
          setelt, plusop, minusop, mulop, bldset, divop, stddivop,
          dummyarg2op, slashop, kwoop, modop, stdmodop, shiftlop, indxop,
          pindxop, aindxop, paindxop, forerrchkop, loopholeop, shiftrop,
          xorop, returnop, castfptrop, castintop, castptrop, castrealop:
            collectargs(2);
          openarrayop:
            begin
            collectwork(2);
            insertnode(1);
            sp := 0; {throw it away}
            end;
          commaop:
            begin
            collectargs(2);
            increfcount(n.oprndlist[1].p, deadcode, - 1);
            increfcount(n.oprndlist[2].p, deadcode, - 1);
            end;
          clearnewop: sequence_point;
          saveop:
            begin
            sequence_point;
            stack[sp].context_mark := lastnode;
            cond_depth := cond_depth + 1;
            end;
          restop:
            begin
            sequence_point;
            clear_expr(stack[sp].p, stack[sp - 1].context_mark);
            stack[sp].context_mark := lastnode;
            end;
          questop:
            begin
            sequence_point;
            clear_expr(stack[sp].p, stack[sp - 1].context_mark);
            cond_depth := cond_depth - 1;
            collectargs(3);
            end;
          vindxop: collectargs(3);
          parmop: collectargs(2);
          moveop:
            begin
            collectwork(2);
            marktargets(n.oprndlist[1].p, n.oprndlist[2].p);
            insertnormal;
            end;
          movelit:
            begin
            collectwork(2);
            marktargets(n.oprndlist[1].p, 0);
            insertnormal;
            if (n.form = ints) and (propagation in sharedPtr^.genset) then
              assignvalue(stack[sp].p);
            end;
          addeqop, andeqop, diveqop, modeqop, muleqop, oreqop, shiftleqop,
          shiftreqop, subeqop, xoreqop, preincop, postincop:
            begin {Could fold these, but we won't bother yet}
            increfcount(stack[sp - 2].p, deadcode, 1);
            collectargs(3);
            end;
          pushaddr, pushstraddr:
            begin
            { must remove as register candidate}
            { top of stack is the address to push }
            if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
              begin
              killasreg(stack[sp].p);
              end;
            collectseqargs(2);
            end;
          pushvalue, pushlitvalue, bldfmt, pushfptr: collectseqargs(2);
          pushret: collectseqargs(2);
          notop:
            begin
            collectopdata;
            relationbuilt := (n.form = bools) and (shorteval or stack[sp].relation);
            collectoprnds(1);
            insertnormal;
            end;
          andop, orop:
            begin
            collectopdata;
            relationbuilt := (n.form = bools) and (shorteval or
                             stack[sp].relation or
                             stack[sp - 1].relation);
            collectoprnds(2);
            insertnormal;
            end;
          setpair, forupchkop, fordnchkop, cmoveop: collectargs(3);
          pushproc: pushprocnode;
          rangechkop, indxchkop, cindxchkop, congruchkop:
            begin
            collectopdata;
            if not stack[sp - 2].relation or
               (stack[sp - 1].i <> ord(false)) or
               (stack[sp].i <> ord(true)) then
              begin
              collectoprnds(3);
              insertnormal;
              end
            else sp := sp - 2;
            end;
          call, callparam, unscall, unscallparam: callnode;
          sysfn:
            begin
            collectopdata;
            cnvts := loophole(standardids, stack[sp - 1].i);
            if (n.form = bools) and not (cnvts in [predid, succid]) then
              relationbuilt := true;
            unique := cnvts in
                      [frexpid, modfid, memcpyid, memmoveid, memsetid,
                      strcatid, strcpyid, strncpyid, strncatid];
            collectoprnds(2);
            insertnormal;
            end;
          lsslit, leqlit, eqlit, neqlit, gtrlit, geqlit, lssop, leqop,
          neqop, eqop, gtrop, geqop, inop:
            begin
            relationbuilt := true;
            collectargs(2)
            end;
          float1, chrstrop1, arraystrop1:
            begin
            tmp := stack[sp];
            sp := sp - 1;
            collectargs(1);
            sp := sp + 1;
            stack[sp] := tmp;
            end;
          defforindexop, defunsforindexop, defforlitindexop,
          defunsforlitindexop:
            builddeffor;
          forindexop:
            begin {Use for stack to locate var}
            getintfile;
            begin
            with forstack[getintfileint] do
              begin
              if sp = maxexprstack then abort(manytemps);
              sp := sp + 1;
              with stack[sp] do
                begin
                context_mark := 0;
                relation := false;
                litflag := false;
                uniqueoprnd := false;
                p := forref;
                l := forlevel;
                end;
              if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
                if bumpvarcount(level, false, forref) then {nothing} ;
              end;
            end;
            end;
          levop:
            begin
            buildintoprnds(2);
            if (n.oprndlist[1].i <> 0) and
               (n.oprndlist[1].i <> level) then
              begin
              n.oprndlist[3] := stack[sp];
              sp := sp - 1;
              end;
            if (n.oprndlist[1].i = level) then
              begin
              insertnode(1);
              localparamnode := stack[sp].p;
              end
            else
              insertnormal;
            end;
          reserve:
            begin
            call_depth := call_depth + 1;
            buildintoprnds(1);
            if stack[sp].litflag then
              begin
              n.oprndlist[2].i := stack[sp].i;
              if (n.oprndlist[2].i = 0) then
                sp := sp - 1;
              end
            else n.oprndlist[2].i := 0;
            insertnormal;
            end;
          intop:
            begin {this and other literals are entered in context 1}
            buildintoprnds(1);
            insertnode(1);
            end;
          fptrop:
            begin
            buildintoprnds(1);
            insertnode(1);
            end;
          ptrop: buildptrnode;
          realop: buildrealnode (sharedPtr^.targetrealsize, reals);
          doubleop: buildrealnode (doublesize, doubles);
          structop:
            begin
            buildintoprnds(2);
            n.len := n.oprndlist[2].i;
            insertnormal;
            end;
          varop, unsvarop: buildvarnode;
          newvarop, newunsvarop: buildnewvarnode;
          ownop: insertnode(1);
          extop:
            begin
            buildintoprnds(1);
            insertnormal;
            end;
          globalop:
            begin
            n.op := levop;
            with n.oprndlist[1] do
              begin
              relation := false;
              litflag := true;
              i := 1
              end;
            insertnode(1);
            end;
          originop, segop:
            begin
            buildintoprnds(1);
            insertnormal;
            end;
          localop:
            begin
            n.op := levop;
            with n.oprndlist[1] do
              begin
              litflag := true;
              relation := false;
              i := level
              end;
            insertnode(1);
            end;
          lit: pushlitint;
          withop:
            begin
            if sp = maxexprstack then abort(manytemps);
            sp := sp + 1;
            getintfile;
            with stack[sp] do
              begin
              context_mark := 0;
              relation := false;
              litflag := false;
              uniqueoprnd := false;
              with withstack[getintfileint] do
                begin
                l := withlevel;
                p := withref;
                end;
              end;
            end;
          switchstack:
            begin
            tmp := stack[sp];
            stack[sp] := stack[sp - 1];
            stack[sp - 1] := tmp
            end;
          bldnil, newset:
            begin
            sp := sp + 1;
            with stack[sp] do
              begin
              context_mark := 0;
              relation := false;
              uniqueoprnd := false;
              litflag := false;
              l := 1;
              p := 0
              end;
            end;
          daddop, daddrop, dfaddrop, dfieldop, dfillop, dintop, drealop,
          dstartop, dstoreop, dstructop, dsubop, dendop:
            takeDataOp;
          otherwise
            begin
            write('travrs build error', ord(n.op));
            abort(builderror);
            end;
          end;
        getintfile;
      end {buildnode} ;
      {>>>}

      begin {buildexpr}
        newvarcount := 0;
        sp := 0;
        cond_depth := 0;
        call_depth := 0;
        while interSharedPtr^.interFile^.block[nextintcode].o <> endexpr do buildnode;
        if sp > 0 then
          begin
          updatenewvars(stack[sp].p);
          if spare6 in sharedPtr^.genset then { temp}
            if simplify(stack[sp].p) then;
          if sp > 1 then
            begin
            updatenewvars(stack[sp - 1].p);
            if spare6 in sharedPtr^.genset then { temp}
              if simplify(stack[sp - 1].p) then;
            end;
          updatecontext;
          buildproperptr(stack[sp], contextsp);
          buildexpr := stack[sp].p;
          increfcount(stack[sp].p, deadcode, 1);
          end
        else buildexpr := 0;
        getintfile;
      end {buildexpr} ;
    {>>>}

    {<<<}
    { Statement Building Routines - -
      These are the routines which are used by buildstmt to build the
      individual statement nodes.
    }
    {>>>}
    {<<<}
    procedure setupstmt (stmtkind: stmthdrtype {statement being built} );
    { This procedure handles the common part of those statement types which
      require an expression as part of the heading.  It creates a new
      statement of the specified type in the global "thisstmt" and
      builds an expression tree rooted in "expr1" of that statement node.
    }

      var
        exprroot: nodeindex;
        ptr: nodeptr;


      begin
        newstmt(thisstmt, stmtkind);
        getintfile;
        exprroot := buildexpr;
        ptr := ref(bignodetable[thisstmt]);
        ptr^.expr1 := exprroot;
      end {setupstmt} ;
    {>>>}
    {<<<}
    procedure buildifstmt;
    { Build an if statement, possibly followed by an else part.  The context
      is saved and restored on each branch so that both branches start out
      with the same common expressions.  Finally the contexts are joined
      to invalidate those expressions which were invalidated on either
      branch of the if.
    }

      var
        startblock: basicblockptr; { currentblock at start }
        thenblock: basicblockptr; { id of then block }
        elseblock: basicblockptr; { id of else block }
        endthenblock: basicblockptr; {the end of the "then" portion}
        ifstmthdr: nodeindex; { index to ifhdr stmt }
        ptr: nodeptr;
        removing: boolean; { true if we have constant if and eliminating dead
                            code }
        start_deadcount: natural; {starting value of deadcount}
        deadthen: boolean; { true if removing and then is dead }
        deadelse: boolean; { true if removing and else is dead }
        constvalue: integer; { value if constant }
        saveminfon, { fon before stmtlist }
         savemaxfon: fonrange; { fon after stmtlist }


      begin

        shorteval := true;
        setupstmt(ifhdr);
        ifstmthdr := thisstmt;
        start_deadcount := deadcount;
        ptr := ref(bignodetable[ifstmthdr]);
        checkconst(ptr^.expr1, removing, constvalue);
        shorteval := false;
        startblock := currentblock;
        removing := removing and (removedeadcode in sharedPtr^.genset);
        elseblock := nil;
        deadthen := removing and (constvalue = 0);
        deadelse := removing and (constvalue = 1);
        { starting a new basic block }
        if deadthen then incr_deadcount;
        { always enter a new context unless removing and we take then path}
        { not deadelse == not removing or ( constvalue = 0 )) }
        newblock(thenblock, startblock, false);
        if not removing or (deadcode and (removedeadcode in sharedPtr^.genset)) then
          begin
          savecontext;
          thenblock^.saveop := true;
          end;
        saveminfon := foncount;
        buildstmtlist(endthen, nil);
        savemaxfon := foncount;
        foncount := saveminfon;
        if not removing or (deadcode and (removedeadcode in sharedPtr^.genset)) then
          restorecontext;
        if deadthen then decr_deadcount;
        dead_exit(start_deadcount);
        endthenblock := currentblock;
        if interSharedPtr^.interFile^.block[nextintcode].s = begelse then
          begin
          getintfile;
          { starting a new basic block }
          if deadelse then incr_deadcount;
          newblock(elseblock, startblock, false);
          elseblock^.restoreop := thenblock^.saveop;
          if not removing or (deadcode and (removedeadcode in sharedPtr^.genset)) then
            begin
            savecontext;
            elseblock^.saveop := true;
            end;
          buildstmtlist(endelse, nil);
          if not removing or (deadcode and (removedeadcode in sharedPtr^.genset)) then
            restorecontext;
          if deadelse then decr_deadcount;
          dead_exit(start_deadcount);
          end;

        newblock(currentblock, currentblock, false);
        addpredsuccs(endthenblock, currentblock);
        if elseblock = nil then
          begin
          addpredsuccs(startblock, currentblock);
          elseblock := currentblock;
          currentblock^.restoreop := thenblock^.saveop;
          end
        else currentblock^.restoreop := elseblock^.saveop;
        if thenblock^.saveop or elseblock^.saveop then
          begin
          joincontext;
          currentblock^.joinop := true;
          end;

        ptr := ref(bignodetable[ifstmthdr]);
        if deadthen or deadelse then ptr^.stmtkind := nohdr
        else
          begin
          ptr^.trueblock := thenblock;
          ptr^.falseblock := elseblock;
          end;

        foncount := max(savemaxfon, foncount) + 1;
        currentblock^.dominates := context[contextsp].dominates;

      end {buildifstmt} ;
    {>>>}

    {<<<}
    { Case statements -
      Yet another case where the general lack of structure in C makes it
      hard to generate good code.  The Pascal case statement is nicely
      structured, and requires that the cases be immediately contained
      within the statement.  It also transfers to the exit label after
      each case, making a nice generalization of a multi-way "if".
      The C switch statement, on the other hand, is much closer to a
      computed goto, where control can be transfered anywhere within the
      compound statement following the switch, including within nested
      statements.  Also, control transfers to the exit only when the
      user includes a "break", making a hash of attempts to keep track
      of CSE's.

      The following set of routines maintain a stack of case descriptors
      which contain the data about all currently active case statements.
      They are called in a disciplined, sensible way when processing
      Pascal, and in a messy way when processing C.

        start_case          Define the top of a case statement
        start_label_group   Start of a new block with labels
        insert_caselab      Insert a case label in a group
        insert_casedef      Insert a default label in a group
        end_label_group     End of a group of labels
        case_break          Insert a break statement
        finish_case         Terminate a case statement
    }
    {>>>}
    {<<<}
    procedure start_case;
    {<<<}
    { Allocate and initialize a new case descriptor, then get the
      case expression and set up a case statement.  This mainly initialized
      a lot of things.
    }
    {>>>}

      var
        this_descr: case_descriptor;


      begin
        new(this_descr);
        with this_descr^ do
          begin
          outer := this_case;
          entry_dead := deadcode and (removedeadcode in sharedPtr^.genset);
          start_deadcount := deadcount;
          firstorder := 0;
          lastorder := 0;
          lastlab := 0;
          firstsplit := 0;
          splitcount := 0;
          casetopblock := currentblock;
          newstmt(casetopstmt, casehdr);
          getintfile;
          caseexpr := buildexpr;
          checkconst(caseexpr, removing, constvalue);
          removing := removing and (removedeadcode in sharedPtr^.genset);
          ptr := ref(bignodetable[casetopstmt]);
          ptr^.selector := caseexpr;
          newblock(tailblock, nil, false);
          currentblock := casetopblock;
          {***This is a total hack to avoid having walk explicitly emit
              a "savelabel(0)", which disappears when code is dead, dead,
              dead.
          }
          newblock(currentblock, currentblock, false);
          currentblock^.saveop := not removing;
          tailblock^.joinop := not removing;
          tailblock^.restoreop := not removing;
          found := false;
          saveminfon := foncount;
          savemaxfon := foncount;
          if not removing then savecontext;
          contextlev := contextsp + overflowdepth;
          loopd := loopdepth;
          old_swbreak_found := swbreak_found;
          old_caselab_found := caselab_found;
          caselab_found := false;
          casedef_found := false;
          last_dead := false;
          found := false;
          ever_found := false;
          otherflow := false;
          swbreak_found := true;
          lab_found := false;
          incr_deadcount;
          gotodead := gotodead + 1;
          end;
        this_case := this_descr;
      end; {start_case}
    {>>>}
    {<<<}
    procedure start_label_group (var block: basicblockptr);
    { Called when we first begin a set of case labels which can be expected
      to have code following it.

      If we have dead code (probably from a switch break), then this is the
      only way control can come and we do a restore-context.  However, if
      someone has placed this label inside of a statement we can't restore
      and it's his tough luck.  Sneakness will not win out.

      We also initialize some variables for searching for a match.
    }

      var
        basecontext: boolean; {we are at the base level for the switch}
        restored: boolean; {context must be restored}
        oldblock: basicblockptr; {block which preceeds this one}
        j: reghashindex; { unsigned var for quicker mod }


      begin
        with this_case^ do
          begin
          basecontext := (contextlev = contextsp + overflowdepth) and
                         (loopd = loopdepth);
          otherflow := not deadcode;
          if basecontext then
            begin
            restored := deadcode and not removing and not lab_found;
            if swbreak_found then
              begin
              decr_deadcount;
              gotodead := gotodead - 1;
              end;
            swbreak_found := false;
            caselab_found := false;
            if foncount > savemaxfon then savemaxfon := foncount;
            if restored then foncount := saveminfon;
            end
          else
            begin
            restored := false;
            deadcode := deadcode and entry_dead;
            clearcontext;
            for j := 1 to regtablelimit do
              if regvars[j].worth >= 0 then
                begin
                regvars[j].varlife.lonmax := tnodetablesize;
                regvars[j].varlife.fonmax := shortmaxint;
                end;
            loopkill(0, maxlevel);
            if loopdepth > 0 then irreducible := true;
            {STH -- was   irreducible := true; }

            caselab_found := swbreak_found;
            end;

          if last_dead then decr_deadcount;
          last_dead := false;
          dead_exit(start_deadcount);

          if block = nil then
            begin
            oldblock := currentblock;
            if restored then
              begin
              restorecontext;
              savecontext;
              end
            else clearcontext;
            newblock(block, oldblock, false);
            if restored then
              begin
              currentblock^.restoreop := true;
              currentblock^.saveop := true;
              end;
            end;
          found := false;
          casedef_found := false;
          addpredsuccs(casetopblock, block);
          end;

        currentblock^.dominates := false;

        { Make certain block is labelled, and if it wasn't before, force
          walk to use the label on this block rather than skipping to
          a non-empty successor block.  This fixes an obscure bug involving
          Duff's device in which an unlabelled block was emitted then later
          labelled and referenced.
         }

        if currentblock^.blocklabel = 0 then
          begin
          currentblock^.forcelabel := true;
          currentblock^.blocklabel := newlabel;
          end;
      end; {start_label_group}
    {>>>}
    {<<<}
    procedure insert_caselab (lowval, highval: integer {label values} );
    { Read in and insert a case label.  If "block" is not nil, use it, otherwise
      create a new basic block and add it to the successors of the
      header block.
    }

      var
        currentlow, currenthigh: integer; {the current label values}
        p1, p2: nodeindex; {for sorting label into a list}
        ptr, ptr2: nodeptr; {for access to nodes}


      begin
        with this_case^ do
          begin
          if lastnode = tnodetablesize then abort(manynodes)
          else lastnode := lastnode + 1;
          if lastnode > maxnodes then maxnodes := lastnode;
          ptr := ref(bignodetable[lastnode]);
          with ptr^ do
            begin
            { link all the labels in text order }
            nextstmt := lastlab;
            lastlab := lastnode;
            nodeform := stmtnode;
            stmtkind := caselabhdr;
            stmtblock := currentblock;
            stmtlabel := currentblock^.blocklabel;
            orderedlink := 0;
            currentlow := lowval;
            currenthigh := highval;
            if removing and (constvalue >= currentlow) and
               (constvalue <= currenthigh) then
              begin
              found := true;
              ever_found := true;
              end;

            caselabellow := currentlow;
            caselabelhigh := currenthigh;
            end;

          { Sort into ordered chain }
          if firstorder = 0 then
            begin
            firstorder := lastnode;
            lastorder := lastnode;
            highlabel := currenthigh;
            lowlabel := currentlow;
            end
          else if lowlabel >= currentlow then
            begin
            ptr := ref(bignodetable[lastnode]);
            ptr^.orderedlink := firstorder;
            firstorder := lastnode;
            lowlabel := currentlow;
            end
          else if highlabel < currenthigh then
            begin
            ptr := ref(bignodetable[lastorder]);
            ptr^.orderedlink := lastnode;
            lastorder := lastnode;
            highlabel := currenthigh;
            end
          else
            begin
            p1 := firstorder;
            ptr := ref(bignodetable[firstorder]);
            p2 := ptr^.orderedlink;
            ptr2 := ref(bignodetable[p2]);
            while ptr2^.caselabelhigh < currentlow do
              begin
              p1 := p2;
              p2 := ptr2^.orderedlink;
              ptr2 := ref(bignodetable[p2]);
              end;
            ptr := ref(bignodetable[lastnode]);
            ptr^.orderedlink := p2;
            ptr2 := ref(bignodetable[p1]);
            ptr2^.orderedlink := lastnode;
            end;
          end;
      end; {insert_caselab}
    {>>>}
    {<<<}
    procedure insert_casedef;
    { Take a case default label. }

      var
        p: nodeptr; {for access to case top}


      begin
        with this_case^ do
          begin
          p := ref(bignodetable[casetopstmt]);
          p^.casedefptr := currentblock;
          casedef_found := true;
          end;
      end; {insert_casedef}
    {>>>}
    {<<<}
    procedure end_label_group (otherlab: boolean {we had other labels} );
    { We have all of this group of labels, so we can decide if the code is
      dead.  "otherlab" is set if there were non-case labels on this statement.
    }


      begin
        with this_case^ do
          begin
          if otherlab then otherflow := true;
          last_dead := removing and not otherlab and not found and
                       not (casedef_found and not ever_found);
          if last_dead then
            begin
            incr_deadcount;
            currentblock^.isdead := true;
            end;
          if casedef_found then ever_found := true;
          end;
      end; {end_label_group}
    {>>>}
    {<<<}
    procedure case_break (shdr: stmthdrtype { to C or not to C } );
    { Take and log a case break statement, which transfers control to the
      terminating statement of a case.
    }

      var
        s: nodeindex; {for break statement}
        p: nodeptr; {for access to statement}


      begin
        with this_case^ do
          begin
          newstmt(s, shdr);
          p := ref(bignodetable[s]);
          p^.targblock := tailblock;
          addpredsuccs(currentblock, tailblock);
          if not swbreak_found then
            begin
            swbreak_found := true;
            incr_deadcount;
            gotodead := gotodead + 1;
            end;
          end;
      end; {case_break}
    {>>>}
    {<<<}
    procedure split (first, last: nodeindex {limits of label list} );
    { Splits an ordered group of case labels into more economical groups.
      The starting point is to assume a jump table implementation.  Each
      split results in a pair of jump tables with a conditional jump to
      choose between them.  The result is a tree of jumps each ending
      in a jump table or single case label.  The tree is represented as
      an ordered list of entries.

      The strategy is to examine each possible split to see if it improves
      the overall size.  Once a split is made, teh procedure is called
      recursively to split the pieces.  Actually, since one of the pieces
      is the rest of the label list, tail recursion can be (and is) replaced
      by iteration.

      In this case, the only criterion for splitting is code size.  Speed
      could be taken into account if desired by adding a suitable weight
      and a raft of new constants.  Since a binary comparison tree is quite
      fast anyway, we are content with size.  Fudging constants can produce
      a good approximation to speed sensitivity anyway.
    }

      var
        start: nodeindex; {start of current group}
        basecost: addressrange; {cost of implementation in bytes}
        this: nodeindex; {used to scan the labels}
        next: nodeindex; {next node in the scan}
        p: nodeptr; {for access to this}
        op: nodeptr; {access to orderedlink}
        thisisordered: boolean; {current group is contig ordered.}
        skipdone: boolean; {done skipping labels}

      {<<<}
      procedure incref(n: nodeindex; {node to increment} inc: integer {amount to increment} );
      { Chain down a list of copies incrementing ref and copy counts appropriately. }

        var
          p: nodeptr; {for access to the node}
          first: boolean; {first node encountered}


        begin
          first := true;
          p := ref(bignodetable[n]);
          while p^.action = copy do
            with p^ do
              begin
              refcount := refcount + inc;
              if not first then copycount := copycount + inc;
              first := false;
              n := p^.oldlink;
              p := ref(bignodetable[n]);
              end;

          { We now have a "visit" node with an operation}
          if (p^.op < intop) and (p^.op > newunsvarop) then
            while p^.slink <> 0 do
              begin
              n := p^.slink;
              p := ref(bignodetable[n]);
              end;

          p := ref(bignodetable[n]);
          p^.refcount := p^.refcount + inc;
          if not first then p^.copycount := p^.copycount + inc;
          if p^.op = commaop then incref(p^.oprnds[2], inc);
        end; {incref}
      {>>>}
      {<<<}
      function orderedgroup(first, last: nodeindex): boolean;
      { Check if the group defined by first and last has contiguous labels all refering to the same statement }

        var
          stillordered: boolean; {set as long as ordered so far}
          thislab: nodeindex; {used to trace list}
          tp, op: nodeptr; {for access to nodes}


        begin
          tp := ref(bignodetable[first]);
          op := ref(bignodetable[tp^.orderedlink]);

          stillordered := (first <> last) and (op^.orderedlink <> last);
          thislab := first;
          while stillordered and (thislab <> last) do
            begin
            tp := ref(bignodetable[thislab]);
            op := ref(bignodetable[tp^.orderedlink]);
            stillordered := (tp^.caselabelhigh = op^.caselabellow - 1) and
                            (tp^.stmtlabel = op^.stmtlabel);
            thislab := tp^.orderedlink;
            end;
          orderedgroup := stillordered;
        end; {orderedgroup}
      {>>>}
      {<<<}
      function cost(first, last: nodeindex): addressrange;
      {<<<}
      { compute and return the cost in bytes of a jump table implementation
        to handle labels first through last.  The only special case is
        a single label.
      }
      {>>>}

        var
          fp, lp: nodeptr; {for access to node data}
          defaultcost: integer; {cost of a default}


        begin
          if this_case^.casedef_found then defaultcost := casedefaultcost
          else defaultcost := errdefaultcost;
          fp := ref(bignodetable[first]);
          lp := ref(bignodetable[last]);
          if fp^.caselabellow = lp^.caselabelhigh then
            cost := splitcost + defaultcost
          else
            begin
            if (fp^.orderedlink = last) and
               (fp^.caselabellow = fp^.caselabelhigh) and
               (lp^.caselabellow = lp^.caselabelhigh) or orderedgroup(first,
               last) then
              cost := splitcost div 2 + splitcost + defaultcost
            else
              begin
              if maxint div caselabcost <=
                 lp^.caselabelhigh - fp^.caselabellow + 1 then
                cost := maxint { overflow causes humungous case tables !! }
              else
                cost := casetablecost + (lp^.caselabelhigh -
                        fp^.caselabellow + 1) * caselabcost;
              end;
            end;
        end; {cost}
      {>>>}


      begin {split}
        with this_case^ do
          begin
          start := first;
          this := first;
          basecost := cost(first, last);
          thisisordered := false;
          p := ref(bignodetable[caseexpr]);
          if not p^.relation then
            begin
            while this <> last do
              begin
              p := ref(bignodetable[this]);
              next := p^.orderedlink;
              if (basecost = maxint) {humungous case statement} or
                 (cost(start, this) + cost(p^.orderedlink,
                 last) + splitcost < basecost) then
                begin {a split is an improvement}
                split(start, this); {split the first part}
                incref(caseexpr, 2); {to compensate for extra refs}
                start := next;
                basecost := cost(start, last);
                end;
              repeat
                this := next;
                p := ref(bignodetable[this]);
                next := p^.orderedlink;
                if this = last then skipdone := true
                else
                  begin
                  op := ref(bignodetable[next]);
                  skipdone := (p^.stmtlabel <> op^.stmtlabel) or
                              (p^.caselabelhigh <> op^.caselabellow - 1);
                  end;
              until skipdone;
              end; {while}

            p := ref(bignodetable[start]);

            { Now define the final split found.  Note that treatment of
              label ranges is imperfect, but shouldn't be far off.
            }
            thisisordered := orderedgroup(start, last) or (start = last) and
                             (p^.caselabellow <> p^.caselabelhigh) and
                             (basecost > splitcost + casedefaultcost);

            op := ref(bignodetable[p^.orderedlink]);

            if (p^.orderedlink = last) and
               (p^.caselabellow = p^.caselabelhigh) and
               (op^.caselabellow = op^.caselabelhigh) or thisisordered then
              incref(caseexpr, 1);
            end;

          if lastnode = tnodetablesize then abort(manynodes)
          else
            begin
            lastnode := lastnode + 1;
            if lastnode > maxnodes then maxnodes := lastnode;
            p := ref(bignodetable[lastnode]);
            with p^ do
              begin
              stmtkind := casegroup;
              ordered := thisisordered;
              nextstmt := firstsplit;
              firstsplit := lastnode;
              textline := 0;
              lowestlabel := start;
              highestlabel := last;
              splitcount := splitcount + 1;
              groupno := splitcount;
              end;
            end;
          end;
      end; {split}
    {>>>}
    {<<<}
    procedure finish_case;
    { Finish a case statement.  All of the branches join here, and we may have
      to clean up some dead code garbage.  Finally we pop the case descriptor
      and get rid of it
    }

      var
        tc: case_descriptor; {temp for disposal}
        p: nodeptr; {for access to node}


      begin {finish_case}
        with this_case^ do
          begin
          if swbreak_found then
            begin
            decr_deadcount;
            gotodead := gotodead - 1;
            end;
          if last_dead then decr_deadcount;
          dead_exit(start_deadcount);
          addpredsuccs(currentblock, tailblock);
          addpredsuccs(casetopblock, tailblock);
          if foncount > savemaxfon then savemaxfon := foncount;
          if not removing then
            begin
            restorecontext;
            joincontext;
            end;
          p := ref(bignodetable[casetopstmt]);
          if removing then
            if (sharedPtr^.switchcounters[rangecheck] <= 0) or casedef_found or
               ever_found then
              p^.stmtkind := nohdr
            else p^.stmtkind := caseerrhdr
          else
            begin
            p^.elements := firstorder;
            p^.joinblock := tailblock;
            if firstorder = 0 then
              increfcount(p^.selector, deadcode, - ord(true))
            else
              split(firstorder, lastorder);
            p := ref(bignodetable[casetopstmt]);
            p^.firstgroup := firstsplit;
            p^.groupcount := splitcount;
            end;
          currentblock := tailblock;
          currentblock^.dominates := context[contextsp].dominates;

          { The tailblock might actually be a dead block if a return
            or goto statement terminated the last branch of the switch
            statement.  Newblock normally sets isdead, but the tail
            was created at the top, rather than bottom of the structure,
            i.e. out of context.
          }

          currentblock^.isdead := deadcode and (removedeadcode in sharedPtr^.genset);

          foncount := savemaxfon;
          caselab_found := old_caselab_found;
          swbreak_found := old_swbreak_found;
          end;
        tc := this_case;
        this_case := tc^.outer;
        dispose(tc);
      end; {finish_case}
    {>>>}
    {<<<}
    procedure buildcasestmt;
    {<<<}
    { Build a case statement.  This is the most complicated of the
      statements.  The main statement is represented as a "casehdr"
      which holds limit and default data and points to a list of
      case elements in textual order.

      Each case element is represented by a "caselabhdr", which has
      contains the low and high values of one case range (with these
      values being equal for a simple case label).  Individual
      case label ranges are linked by the "nextstmt" field, and
      the selected statement is built in "stmt1".  "Stmt2" is used
      to point to the next case element.

      In addition to being linked in textual order, case labels are
      linked in numerical order through the "orderedlink" field, with
      the chain starting in the "firstlabel" field of the casehdr.
      Labels are sorted into this ordered chain as they are read in.
      Also, each case label has a link to the parent lab header.
      As each case element is built, the context is saved and restored
      for each branch of the case.  Finally, the context is joined at the
      end of the entire case.
    }
    {>>>}

      var
        caseblock: basicblockptr; {the block for each case piece}
        lowlabel: integer; {lower of the two labels from intermediate file}
        simplecaselab: boolean; { the simple, single value case }


      begin
        start_case;

        while interSharedPtr^.interFile^.block[nextintcode].s in [caselab, caselabrange] do
          begin {read each case element}
          caseblock := nil;
          start_label_group(caseblock);

          while interSharedPtr^.interFile^.block[nextintcode].s in [caselab, caselabrange] do
            begin {Read all labels for this element}
            simplecaselab := interSharedPtr^.interFile^.block[nextintcode].s = caselab;
            getintfile;
            lowlabel := getintfileint;
            if simplecaselab then insert_caselab(lowlabel, lowlabel)
            else
              begin
              getintfile;
              insert_caselab(lowlabel, getintfileint);
              end;
            getintfile;
            end;

          end_label_group(false);
          buildstmtlist(endcaseelt, nil);
          case_break(swbrkhdr);
          end;

        if interSharedPtr^.interFile^.block[nextintcode].s = casedef then
          begin
          getintfile;
          caseblock := nil;
          start_label_group(caseblock);
          insert_casedef;
          end_label_group(false);
          buildstmtlist(endcase, nil);
          case_break(swbrkhdr);
          end
        else
          begin
          this_case^.tailblock^.blocklabel := newlabel;
          getintfile;
          end;

        finish_case;
      end {buildcasestmt} ;
    {>>>}
    {<<<}
    procedure buildcforstmt;
    { Build a C for statement node.  The context is cleared prior to evaluation
      of the boolean expression, since control may come from one of two
      places.  A savecontext and restorecontext around the controlled
      statement make common expressions from the boolean available on exit.
      Of course, the presence of a "break" in the loop makes such statements
      invalid.

      When the head of the loop is dead we still need to build it since
      we may enter the loop with a goto.  We can remove such code if we
      are still dead at the end of the loop.
    }

      var
        hdrblock: basicblockptr; { index to for hdr block }
        tailblock: basicblockptr; { index to for bottom block }
        controlled: basicblockptr; { index to controlled block }
        exit_block: basicblockptr; { the exit from the loop }
        start_deadcount: natural; {the starting value of deadcount}
        start_dead: boolean; {dead at the start}
        ptr: nodeptr; { for access to nodes }
        cforhdrstmt: nodeindex; { index to while hdr }
        removing: boolean; { true if constant whileloop and deadcode goes }
        constvalue: integer; { value of control expression }
        p: nodeindex; { whilebotstmt index }


      begin

        start_deadcount := deadcount;
        start_dead := deadcode;
        if gotodead = deadcount then deadcode := false;

        clearcontext;
        newblock(hdrblock, currentblock, true);
        hdrblock^.blocklabel := newlabel;
        enterloop(hdrblock);
        newblock(tailblock, nil, false);
        newblock(exit_block, nil, false);
        currentblock := hdrblock;
        hdrblock^.clearop := not start_dead; ;

        shorteval := true;
        setupstmt(cforhdr);
        cforhdrstmt := thisstmt;
        ptr := ref(bignodetable[cforhdrstmt]);
        checkconst(ptr^.expr1, removing, constvalue);
        removing := removing and (removedeadcode in sharedPtr^.genset);
        shorteval := false;
        newblock(controlled, hdrblock, false);
        if start_dead then controlled^.blocklabel := newlabel;

        if removing and (constvalue = 0) then incr_deadcount;

        context[contextsp].dominates := true;
        ptr := ref(bignodetable[cforhdrstmt]);
        ptr^.trueblock := controlled;
        ptr^.falseblock := exit_block;
        hdrblock^.loophdr := true;

        pushloop(tailblock, exit_block);
        buildstmtlist(endcfor, nil);

        dead_exit(start_deadcount);
        addpredsuccs(currentblock, tailblock);
        currentblock := tailblock;
        currentblock^.dominates := context[contextsp].dominates;

        newstmt(p, cforbothdr);
        temp := buildexpr;
        increfcount(temp, deadcode, - 1);

        ptr := ref(bignodetable[p]);
        ptr^.expr1 := temp;
        ptr^.trueblock := hdrblock;
        ptr^.falseblock := exit_block;
        { the bottom of the loop needs to know where the top is }
        ptr^.looptop := hdrblock;
        ptr^.has_break := this_loop^.break_found;

        addpredsuccs(currentblock, hdrblock);
        clearcontext;
        exitloop;

        if removing and (constvalue = 0) then
          begin
          removing := removing and deadcode;
          decr_deadcount;
          end;
        currentblock := exit_block;
        addpredsuccs(hdrblock, currentblock);
        currentblock^.dominates := context[contextsp].dominates;

        ptr := ref(bignodetable[cforhdrstmt]);
        if removing then
          begin
          ptr^.stmtkind := nohdr;
          if (constvalue = 0) or start_dead then hdrblock^.loophdr := false
          else hdrblock^.willexecute := true;
          end;
        poploop;
      end; {buildcforstmt}
    {>>>}
    {<<<}
    procedure buildfor;
    {<<<}
    { Build a for statement node.  The forstack is used to relate the
      for index variable to the for statement.  It is incremented at
      the start of the statement, and the variable level and displacement
      stored when the "def...forindex" operation is found in the expression.
      As this is a looping construct, the context must be cleared at the
      beginning of the controlled statements.
    }
    {>>>}

      var
        ptr: nodeptr; {Used to access controlled var/stmt nodes}
        fortopblock, { index to forloop top block }
         forbotblock, { index to forloop bottom block }
         forstmts: basicblockptr; { index to basic block containing body }
        forhdrstmt: nodeindex; { index to forhdr }
        p: nodeindex; { for acces to bottom stmt }
        saveexpr1, saveexpr2, controlledvar: nodeindex; { copies to expressions at top of loop }
        fixed: boolean; { true if constant for loop }
        overflow: boolean; { true if runcount is short }
        start_deadcount: natural; {starting value of deadcount}
        runcount: unsignedint; { number of times for loop executes }
        exitlabel: labelrange; { label assigne for loop exit }
        indexaddr: addressrange; { offset of for induction var }
        savedloopfactor: shortint; {saved value of current loop weight}

      begin
        start_deadcount := deadcount;
        newblock(fortopblock, currentblock, true);
        forsp := forsp + 1;

        setupstmt(foruphdr);

        { point hdr to for..indxop}
        ptr := ref(bignodetable[thisstmt]);
        forhdrstmt := thisstmt;
        ptr^.expr2 := stack[sp - 1].p;
        saveexpr1 := ptr^.expr1;
        saveexpr2 := ptr^.expr2;
        increfcount(ptr^.expr2, deadcode, 1);

        if interSharedPtr^.interFile^.block[nextintcode].s = fordn then
          begin
          ptr := ref(bignodetable[forhdrstmt]);
          ptr^.stmtkind := fordnhdr;
          end;
        getintfile;

        ptr^.forstepsize := getintfileint;
        getintfile;

        ptr := ref (bignodetable[saveexpr2]);
        controlledvar := ptr^.oprnds[2];

        estimateloop (forhdrstmt, fixed, overflow, runcount);

        if fixed and (runcount = 0) and (removedeadcode in sharedPtr^.genset) then
          begin
          ptr := ref(bignodetable[forhdrstmt]);
          ptr^.stmtkind := nohdr; { kill it!}
          incr_deadcount;
          { need a dead block to hang these stmts on }
          newblock(forstmts, currentblock, false);
          buildstmtlist(endfor, nil);
          getintfile; { who cares about jump out}
          decr_deadcount;
          newblock(currentblock, forstmts, false);
          end
        else { true "loop" }
          begin
          clearcontext;
          fortopblock^.loophdr := true;
          fortopblock^.willexecute := fixed and (runcount > 0);
          enterloop(fortopblock);
          if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
            begin
            { now add the definition to the bitmap }
            dodefine(controlledvar);
            end;
          context[contextsp].dominates := true;

          { don't do a clearop since codegen does it free }
          newblock(forstmts, fortopblock, false);

          { dominate is harmless here, no code is present }
          newblock(forbotblock, nil, false);
          currentblock := forstmts;
          buildstmtlist(endfor, forbotblock);
          if getintfileint <> 0 then {there's a goto out of the loop}
            begin {clear the "local access only" flag}
            ptr := ref(bignodetable[saveexpr2]);
            ptr^.oprnds[1] := 0;
            end;

          getintfile;
          clearcontext;
          if (currentblock = forstmts) and false then
            begin
            { never generated any new blocks so merging block not needed }
            { dispose forbotblock }
            end
          else
            currentblock := forbotblock;
          newstmt(p, forbothdr);
          addpredsuccs(currentblock, fortopblock);

          { now add the implied var reference to the lifetimes }
          if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
            doreference(controlledvar);

          { don't do a clearop since codegen does it free }
          newblock (currentblock, fortopblock, false);

          { the bottom of the loop needs to know where the top is }
          ptr := ref (bignodetable[p]);
          ptr^.looptop := fortopblock;
          ptr := ref (bignodetable[forhdrstmt]);
          ptr^.falseblock := currentblock;
          ptr^.trueblock := forstmts;
          exitloop;

          { update for any goto's within the loop }
          with currentblock^ do
            dominates := context[contextsp].dominates;
          end;

        dead_exit (start_deadcount);
        forsp := forsp - 1;
      end;
    {>>>}
    {<<<}
    procedure buildwhilestmt;
    {<<<}
    { Build a while statement node.  The context is cleared prior to evaluation
      of the boolean expression, since control may come from one of two
      places.  A savecontext and restorecontext around the controlled
      statement make common expressions from the boolean available on exit.

      The presence of a "break" statement within the loop invalidates these
      statements.

      We also have to allocate the exit block at the start of the loop,
      since break statements need to make themselves predecessors to it.
    }
    {>>>}

      var
        hdrblock: basicblockptr; { index to while hdr block }
        tailblock: basicblockptr; { index to while bottom block }
        controlled: basicblockptr; { index to controlled block }
        exit_block: basicblockptr; { the exit block }
        start_deadcount: natural; {starting value for deadcount}
        start_dead: boolean; {we started out dead}
        ptr: nodeptr; { for access to nodes }
        whilehdrstmt: nodeindex; { index to while hdr }
        removing: boolean; { true if constant whileloop and deadcode goes}
        constvalue: integer; { value of control expression }
        p: nodeindex; { whilebotstmt index }


      begin {buildwhilestmt}

        start_deadcount := deadcount;
        start_dead := deadcode and (removedeadcode in sharedPtr^.genset);
        if gotodead = deadcount then deadcode := false;

        clearcontext;
        newblock(hdrblock, currentblock, true);
        newblock(exit_block, nil, false);
        currentblock := hdrblock;
        { must enterloop always so that refs in control stmt are linked}
        enterloop(hdrblock);
        hdrblock^.clearop := not start_dead;

        shorteval := true;
        setupstmt(whilehdr);
        whilehdrstmt := thisstmt;
        ptr := ref(bignodetable[whilehdrstmt]);
        checkconst(ptr^.expr1, removing, constvalue);
        removing := removing and (removedeadcode in sharedPtr^.genset);
        shorteval := false;

        savecontext;
        if removing and (constvalue = 0) then incr_deadcount;
        context[contextsp].dominates := true;
        newblock(tailblock, nil, false);
        newblock(controlled, hdrblock, false);
        if start_dead then controlled^.blocklabel := newlabel;
        hdrblock^.loophdr := true;

        ptr := ref(bignodetable[whilehdrstmt]);
        ptr^.trueblock := controlled;
        ptr^.falseblock := exit_block;

        pushloop(hdrblock, exit_block);
        buildstmtlist(endwhile, tailblock);

        { need a place to hang the restore loop pseudoop }

        currentblock := tailblock;

        currentblock^.dominates := context[contextsp].dominates;

        newstmt(p, whilebothdr);
        { tell bottom of loop where top is ( minus precode ) }
        ptr := ref(bignodetable[p]);
        ptr^.looptop := hdrblock;

        addpredsuccs(currentblock, hdrblock);
        exitloop;

        if this_loop^.break_found then popcontext
        else restorecontext;

        ptr^.has_break := this_loop^.break_found;

        currentblock^.restoreop := true;
        controlled^.saveop := true;

        if removing and (constvalue = 0) then decr_deadcount;
        currentblock := exit_block;
        addpredsuccs(hdrblock, exit_block);
        currentblock^.dominates := context[contextsp].dominates;

        ptr := ref(bignodetable[whilehdrstmt]);
        if removing then
          begin
          ptr^.stmtkind := nohdr;
          if (constvalue = 0) or start_dead then hdrblock^.loophdr := false
          else hdrblock^.willexecute := true;
          end;

        dead_exit(start_deadcount);
        poploop;
      end; {buildwhilestmt}
    {>>>}
    {<<<}
    procedure buildloopstmt;
    {<<<}
    { Build a loop statement node.  The context is cleared prior to the
      controlled statements, and afterwards as well, as there may well
      be multiple exits from inside the loop.
    }
    {>>>}

      var
        ptr: nodeptr; {to access stmt node}
        p: nodeindex; {hold fn result till usable}
        start_deadcount: natural; {deadcount at top of loop}
        prevblock, {block preceding loop body}
         exitblock, {block after loop body}
         tailblock, {block trailing loop body}
         loopbody: basicblockptr; {block containing loop body}


      begin {buildloopstmt}

        start_deadcount := deadcount;
        if gotodead = deadcount then deadcode := false;

        newblock(loopbody, currentblock, true);
        with loopbody^ do
          begin
          clearop := true;
          willexecute := true;
          end;
        clearcontext;
        newblock(tailblock, loopbody, false);
        newblock(exitblock, nil, false);
        tailblock^.clearop := true;
        currentblock := loopbody;

        newstmt(thisstmt, loophdr);
        getintfile;

        enterloop(loopbody);
        pushloop(loopbody, exitblock);
        this_loop^.looploop := true;
        buildstmtlist(endloop, tailblock);
        currentblock := tailblock;
        { update control block dominate value to proper value }
        currentblock^.dominates := context[contextsp].dominates;
        addpredsuccs(currentblock, loopbody);
        loopbody^.loophdr := true;
        loopbody^.blocklabel := newlabel;
        clearcontext;
        newstmt(p, loopbothdr);
        { tell bottom of loop where top is ( minus precode ) }
        ptr := ref(bignodetable[p]);
        ptr^.looptop := loopbody;

        exitloop;
        dead_exit(start_deadcount);

        ptr^.has_break := this_loop^.break_found;

        addpredsuccs(currentblock, exitblock);
        currentblock := exitblock;
        currentblock^.dominates := context[contextsp].dominates;
        poploop;

      end {buildloopstmt} ;
    {>>>}
    {<<<}
    procedure buildrptstmt;
    {<<<}
    { Build a repeat statement node.  The context is cleared prior to the
      controlled statements, but need not be cleared on exit, making
      expressions from within available.

      We create a dummy statement at the end of the loop to provide for
      copy-nodes needed to evaluate the controlling expression.  The "prestmt"
      field for this context level may have disappeared due to a clearcontext
      operation, in which case the insertnode mechanism has no place to build
      the needed copy-nodes.  So we provide a fake place, and explicitly walk
      the copy-nodes hung on this statement (if any) in "walkrpt".

      We need access to the exit block while building the loop body, so
      we use the "falseblock" field in the until header to hold it.
      Context is cleared befor the control expression if we have a "continue",
      and before the exit block if we have a "break".
    }
    {>>>}

      var
        ptr: nodeptr; { to access stmt node }
        temp: nodeindex; { hold fn result till usable }
        loopbody: basicblockptr; { block containing loop body }
        control: basicblockptr; { block containing loop control }
        exit_block: basicblockptr; {the exit block}
        start_deadcount: natural; {starting value of deadcount}
        constvalue: integer; { value of control expression }
        removing: boolean; { true if control expr is constant and dead goes}
        untilstmt: nodeindex; { index of untilhdr }
        exitdead: boolean; {the exit block is dead}
        startdead: boolean; {we were dead at entry}


      begin
        start_deadcount := deadcount;
        startdead := deadcode;
        if gotodead = deadcount then deadcode := false;
        newblock(loopbody, currentblock, true);
        with loopbody^ do
          begin
          clearop := not startdead;
          willexecute := true;
          end;
        newblock(control, nil, false);
        newblock(exit_block, nil, false);
        clearcontext;
        currentblock := loopbody;

        newstmt(thisstmt, rpthdr);
        getintfile;

        enterloop(loopbody);
        pushloop(control, exit_block);
        buildstmtlist(endrpt, control);
        if this_loop^.cont_found then dead_exit(start_deadcount);
        exitdead := deadcode and (removedeadcode in sharedPtr^.genset);
        shorteval := true;

        currentblock := control;

        if irreducible then loopbody^.clearop := false;

        currentblock^.dominates := context[contextsp].dominates;
        newstmt(untilstmt, untilhdr);

        if this_loop^.cont_found then clearcontext;

        temp := buildexpr;
        checkconst(temp, removing, constvalue);
        if exitdead and not removing then
          begin
          removing := (removedeadcode in sharedPtr^.genset);
          constvalue := 1;
          end
        else removing := removing and (removedeadcode in sharedPtr^.genset);

        { loopbody follows control ( unless dead control ) }

        if exitdead then
          begin
          addpredsuccs(exit_block, exit_block);
          exit_block^.isdead := removedeadcode in sharedPtr^.genset;
          end;
        addpredsuccs(control, exit_block);

        if not removing or (constvalue = 0) then
          begin
          addpredsuccs(control, loopbody);
          loopbody^.loophdr := true;
          loopbody^.blocklabel := newlabel;
          end;

        shorteval := false;
        exitloop;

        if this_loop^.break_found then clearcontext;

        ptr := ref(bignodetable[untilstmt]);
        if removing and (constvalue = 1) then ptr^.stmtkind := nohdr
        else
          begin
          { kill the expression on an "infinite" loop }
          if removing then ptr^.expr1 := 0
          else ptr^.expr1 := temp;
          ptr^.falseblock := loopbody;
          ptr^.trueblock := exit_block;
          ptr^.has_break := this_loop^.break_found;
          end;

        if not this_loop^.cont_found then dead_exit(start_deadcount);

        currentblock := exit_block;
        currentblock^.dominates := context[contextsp].dominates;
        poploop;
      end {buildrptstmt} ;
    {>>>}
    {<<<}
    procedure buildwithstmt;
    {<<<}
    { Build a with statement node.  The with stack is used to keep track
      of the with temporary pointer.
    }
    {>>>}

      var
        ptr: nodeptr; {used to access stmt node}
        tempthisstmt: nodeindex; { simulate time machine }
        withvar: nodeindex; { index of the varop being "withed"}
        temp: nodeindex; { hold fn result till usable }
        endblock, { index to block at with end }
         withstmts: basicblockptr; { block containing with stmts }
        savedominate: boolean; { value of context's dominates field before
                                savecontext }
        i: reghashindex;


      begin {buildwithstmt}

        withsp := withsp + 1;
        with withstack[withsp] do
          begin
          withlevel := contextsp;
          withfonmin := foncount;
          setupstmt(withhdr);
          withfoncount := foncount;
          ptr := ref(bignodetable[thisstmt]);
          withref := ptr^.expr1;
          increfcount(withref, deadcode, - 1);
          { must remove as register candidate}
          if not deadcode then
            begin
              { first we must find the var, if the
                with is like with p^ then p is ok as register
                var ( on machines with ptrreg ).
              }
            ptr := ref(bignodetable[withref]);
            { now have the indxop, get the varop }
            if ptr^.op <> indxop then
              begin
              writeln('in buildwith, expr not a indxop is ', ord(ptr^.op): 1);
              abort(inconsistent);
              end;
            withvar := ptr^.oprnds[1];
            ptr := ref(bignodetable[withvar]);
            if not (ptr^.op in [varop, newvarop, unsvarop, newunsvarop]) then
              begin
              writeln('in buildwith, var not a varop is ', ord(ptr^.op): 1);
              abort(inconsistent);
              end;
            { pointer dereference will have level of zero, which is ok }
            if ptr^.oprnds[1] = level then killasreg(withvar);
            end;
          end;

        { with block dominates if current context dominates }
        savedominate := context[contextsp].dominates;
        savecontext;
        newblock(withstmts, currentblock, false);
        { set the proper value of dominate }
        currentblock^.dominates := savedominate;
        context[contextsp].dominates := savedominate;
        with withstmts^ do
          begin
          saveop := true;
          end;
        newblock(endblock, nil, false);
        with endblock^ do
          begin
          joinop := true;
          restoreop := true;
          end;
        currentblock := withstmts;
        { do we need to reset firstblock here, not really a new block ?? }
        buildstmtlist(endwith, endblock);
        restorecontext;

        { Extend the lifetime of any variable mentioned in the with expr }

        for i := 0 to regtablelimit do
        begin
        with regvars[i], varlife do
          begin
          if (worth > 0) and ((fonmin >= withstack[withsp].withfonmin) or
             (fonmax >= withstack[withsp].withfonmin)) and
             (fonmin <= withstack[withsp].withfoncount) then
            begin
            lonmax := lastnode;
            { never let fonmax decrease!}
            if foncount > fonmax then fonmax := foncount;
            end;
          end;
        end;

        withsp := withsp - 1;
        joincontext;
        currentblock := endblock;

      end {buildwithstmt} ;
    {>>>}
    {<<<}
    procedure builddeflabel(var lblock: basicblockptr);
    {<<<}
    { Build a label node.  This is treated as a statement in itself.
      The context is cleared because it is impossible to tell from
      where the jump may have come.
      Lblock is set to the resulting block.
    }
    {>>>}

      var
        ptr: nodeptr; { to access stmt node }
        mylabel: integer; { value of this label }
        lptr: locallabelptr; { for walking label chains }
        found: boolean; { true if label found }
        j: reghashindex; { induction var}
        cp: case_descriptor;


      begin {builddeflabel}
        if (gotodead = deadcount) then
          deadcode := false;{could be from outside}
        clearcontext;
        getintfile;
        mylabel := getintfileint;
        { define the label and allocate a new block, unless already defined }
        lptr := locallabels;
        found := false;
        while (lptr <> nil) and not found do
          if lptr^.labelno = mylabel then found := true
          else lptr := lptr^.link;
        if found then
          begin
          addpredsuccs(currentblock, lptr^.block);
          currentblock := lptr^.block;
          currentblock^.isdead := (deadcode and (removedeadcode in sharedPtr^.genset));
          end
        else
          begin
          new(lptr);
          lptr^.link := locallabels;
          lptr^.labelno := mylabel;
          { define the start of a new block }
          { no need to do clearop, genblk will do it free }
          if lblock = nil then newblock(currentblock, currentblock, false)
          else currentblock := lblock;
          lptr^.block := currentblock;
          locallabels := lptr;
          end;
        lblock := currentblock;
        if lblock^.blocklabel = 0 then lblock^.blocklabel := newlabel;

        newstmt(thisstmt, labelhdr);
        ptr := ref(bignodetable[thisstmt]);
        ptr^.labelno := mylabel;
        getintfile;
        ptr^.labellevel := getintfileint;
        getintfile;
        ptr^.nonlocalref := (getintfileint = 1);
        { using simple minded approach, lifetime analysis is invalid,
          defeat multiple vars to single register assignment
        }
        for j := 0 to regtablelimit do
          if regvars[j].worth >= 0 then
            begin
            { set lifetime region to encompass entire block }
            regvars[j].varlife.lonmax := tnodetablesize;
            regvars[j].varlife.fonmax := shortmaxint;
            end;
        { again using the simple minded approach, kill hoisting in
          any loop with a label in it.
        }
        loopkill(0, maxlevel);
        if loopdepth > 0 then irreducible := true;
        {STH -- was   irreducible := true; }
        getintfile;

      end {builddeflabel} ;
    {>>>}
    {<<<}
    procedure buildgotostmt;
    { Build a goto statement node.  If it is a local goto must fix the
      pred/succ chains.
    }

      var
        ptr: nodeptr; { for access to node }
        mylabel: labelrange; { target of goto }
        mylevel: levelindex; { level of goto label }
        lptr: locallabelptr; { for walking label chains }
        found: boolean; { true if label found }
        gotoblock: basicblockptr; { block with goto stmt }
        unreach: basicblockptr; {for unreachable code}
        i: contextindex; { induction var }


      begin {buildgoto}

        if deadcode and (removedeadcode in sharedPtr^.genset) then
          begin
          { ignore this stmt}
          newstmt(thisstmt, gotohdr);
          getintfile;
          mylabel := getintfileint;
          getintfile;
          mylevel := getintfileint;
          getintfile;
          end
        else
          begin
          { no longer can calculate dominators }
          for i := 2 to contextsp do context[i].dominates := false;
          newstmt(thisstmt, gotohdr);
          getintfile;
          ptr := ref(bignodetable[thisstmt]);
          mylabel := getintfileint;
          ptr^.labelno := mylabel;
          getintfile;
          mylevel := getintfileint;
          ptr^.labellevel := mylevel;
          getintfile;
          gotoblock := currentblock;
          {this used to be below, not here:}
          newblock(unreach, gotoblock, false);
          addpredsuccs(unreach, unreach);
          unreach^.isdead := removedeadcode in sharedPtr^.genset;

          if level = mylevel then
            begin
            lptr := locallabels;
            found := false;
            while (lptr <> nil) and not found do
              if lptr^.labelno = mylabel then found := true
              else lptr := lptr^.link;
            if found then
             {  If the label has already been defined, we may wish to
                add it as a successor of the goto block, as later activity
                might change the order of execution, perhaps into something
                more efficient.  However, we don't want to reorder blocks
                which have context operators associated with them!  Pascal
                and Modula-2 (real computer languages) place restrictions
                on goto targets which guarantee that this situation won't
                occur, however, C (fake computer language) allows gotos
                to go to anywhere, thus them C hackers are s.o.l.
              }
              with lptr^, block^ do
                addpredsuccs(gotoblock, block)
            end;

          currentblock := unreach;
          { This code used to be here, not above:
          newblock(unreach, gotoblock, false);
          addpredsuccs(unreach, unreach);
          unreach^.isdead := removedeadcode in sharedPtr^.genset;
          }
          if deadcount = gotodead then
            begin
            incr_deadcount; {code following is dead}
            gotodead := gotodead + 1;
            end;
          end;
      end {buildgoto} ;
    {>>>}
    {<<<}
    procedure buildsimplestmt(s: stmthdrtype {simple or hidden?} );
    { Build a node for an assignment or procedure call.  These are lumped
      together because all of the real work is done as an expression
      and there is no control flow to worry about.  The reference count of
      the (optional) expression is decremented, as this is one use of the
      expression complete.
    }

      var
        ptr: nodeptr; {used to access node}


      begin {buildsimplestmt}
        setupstmt(s);
        ptr := ref(bignodetable[thisstmt]);
        if ptr^.expr1 <> 0 then increfcount(ptr^.expr1, deadcode, - 1);
      end {buildsimplestmt} ;
    {>>>}
    {<<<}
    procedure buildreturn;
    { Build a return statement, which is very similar to a simple statement
      except that it transfers control to "tail"
    }

      var
        ptr: nodeptr; {for access to label}
        i: contextindex; {induction var}
        deadblock: basicblockptr;


      begin
        setupstmt(returnhdr);
        ptr := ref(bignodetable[thisstmt]);
        if ptr^.expr1 <> 0 then increfcount(ptr^.expr1, deadcode, - 1);
        ptr^.trueblock := retblock;
        addpredsuccs(currentblock, retblock);
        if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
          for i := 2 to contextsp do context[i].dominates := false;

        newblock(deadblock, currentblock, false);
        addpredsuccs(deadblock, deadblock);
        deadblock^.isdead := removedeadcode in sharedPtr^.genset;
        if deadcount = gotodead then
          begin
          incr_deadcount;
          gotodead := gotodead + 1;
          end;
      end; {buildreturn}
    {>>>}
    {<<<}
    procedure finishswitch;


      begin
        finish_case;
        getintfile;
      end;
    {>>>}
    {<<<}
    procedure buildlabel;
    {<<<}
    { Build a sequence of labels.  Since we may well have many labels on
      a particular block, we want to create only one block and attach
      labels to it.  Of these labels, only a "deflabel" with an out
      of block goto may have any associated code.  "deflabel" instructions
      may already have an associated block, so we can't just create one
      out of hand.  We keep a "label_block" which is the block to which
      labels are to be attached.  A routine may disregard the existing
      block and append a new one if it needs to.  In such a case, the
      new block will be used for further labels.
    }
    {>>>}

      var
        label_block: basicblockptr; {the label block}
        s: stmttype;
        lab: integer; {case label, if any}
        swlab: boolean; {we found at least on switch label}
        full_lab: boolean; {we have a fully general label}


      begin
        label_block := nil; {none to begin with}
        s := interSharedPtr^.interFile^.block[nextintcode].s;
        swlab := false;
        full_lab := false;
        while s in [deflab, caselab, casedef] do
          begin
          if (s = caselab) or (s = casedef) then
            begin
            if not swlab then start_label_group(label_block);
            swlab := true;
            getintfile;
            if s = caselab then
              begin
              lab := getintfileint;
              insert_caselab(lab, lab);
              getintfile;
              end
            else insert_casedef;
            end
          else
            begin
            full_lab := true;
            builddeflabel(label_block);
            end;
          s := interSharedPtr^.interFile^.block[nextintcode].s;
          end;
        if swlab then end_label_group(full_lab);
      end; {buildlabel}
    {>>>}
    {<<<}
    procedure buildsyscallstmt;
    { Build a system call statement.  This is another simple statement, but
      is handled separately as it has an additional argument to choose the
      kind of system call.
    }

      var
        ptr: nodeptr; {for access to node}
        temp: nodeindex; {hold fn result to usable}
        tempthisstmt: nodeindex; {simulate time machine}


      {<<<}
      procedure clobberinput;
          {
            Find the variable "input" and make it unavailable.
          }

        var
          nindex: nodeindex; { for walking chains }
          ptr: nodeptr; {used for access to nodes}
          i: integer; { induction var }


        begin {clobberinput}
          for i := context[contextsp].searchlevel to contextsp do
            begin
            nindex := context[i].opmap[0];
            while nindex <> 0 do
              begin
              ptr := ref(bignodetable[nindex]);
              with ptr^ do
                begin
                if (oprnds[1] = 1) and (oprnds[2] = sharedPtr^.inputoffset) and
                   ((op = varop) or (op = unsvarop)) then
                  begin
                  valid := false;
                  if deepestvalid > contextsp then
                    begin
                    deepestvalid := contextsp;
                    end;
                  end;
                nindex := slink;
                end;
              end; {while}
            end; {for}
        end {clobberinput} ;
      {>>>}


      begin {buildsyscallstmt}
        newstmt(thisstmt, syscallhdr);
        getintfile;
        ptr := ref(bignodetable[thisstmt]);
        ptr^.expr2 := getintfileint;
        {
          We must produce the effect of doing a newvar on input if read
          or readln were seen without a filevar present.
        }
        killinput := (ptr^.expr2 = ord(readid)) or
                     (ptr^.expr2 = ord(readlnid));
        getintfile;
        temp := buildexpr;
        ptr := ref(bignodetable[thisstmt]);
        ptr^.expr1 := temp;
        if killinput then clobberinput;
      end {buildsyscallstmt} ;
    {>>>}
    {<<<}
    procedure buildlbreak(onlyloop: boolean {only exit "loop" loop} );
    { Build a loop break statement.  This statement transfers control directly
      to the end of the loop, thus it doesn't disturb dominator calculations.
      The header contains a link to the loop header so we can find the exit
      block when walking the tree.  We have to create a block for any
      unreachable code which may follow the break.

      If "onlyloop" is true we search for the nearest enclosing "loop" statement,
      rather than any vanilla loop construct.  This corresponds to Modula-2's
      "exit" statement.  However, the code is generalized to minimize the language
      dependency of travrs.
    }

      var
        p: nodeptr; {for access to a node}
        breakloop: loop_descriptor; {the loop we will actually "break" from}


      begin
        newstmt(thisstmt, loopbrkhdr);
        getintfile;
        p := ref(bignodetable[thisstmt]);
        breakloop := this_loop;
        while onlyloop and not breakloop^.looploop do
          breakloop := breakloop^.outer;
        p^.targblock := breakloop^.break_block;
        with breakloop^.break_block^ do
          if blocklabel = 0 then blocklabel := newlabel;
        breakloop^.break_found := true;
        addpredsuccs(currentblock, breakloop^.break_block);
        newblock(currentblock, currentblock, false);
        addpredsuccs(currentblock, currentblock);
        currentblock^.isdead := removedeadcode in sharedPtr^.genset;
        incr_deadcount;
        gotodead := gotodead + 1;
      end; {buildlbreak}
    {>>>}
    {<<<}
    procedure buildlcont;
    {<<<}
    { This is very similar to break except that it causes a transfer to the
      loop repetition code.  Since it always does a transfer to the increment
      and testing code, which dominates the exit, domination calculations are
      unchanged.
    }
    {>>>}
      var
        p: nodeptr; {for access to a node}


      begin
        newstmt(thisstmt, loopconthdr);
        getintfile;
        p := ref(bignodetable[thisstmt]);
        p^.targblock := this_loop^.cont_block;
        with this_loop^.cont_block^ do
          if blocklabel = 0 then blocklabel := newlabel;
        this_loop^.cont_found := true;
        addpredsuccs(currentblock, this_loop^.cont_block);
        newblock(currentblock, currentblock, false);
        addpredsuccs(currentblock, currentblock);
        currentblock^.isdead := removedeadcode in sharedPtr^.genset;
        incr_deadcount;
        gotodead := gotodead + 1;
      end; {buildlcont}
    {>>>}
    {<<<}
    procedure buildsbreak;


      begin
        case_break(cswbrkhdr);
        getintfile;
      end;
    {>>>}

    begin
      case interSharedPtr^.interFile^.block[nextintcode].s of
        begif: buildifstmt;
        begcase: buildcasestmt;
        begcfor: buildcforstmt;
        begfor: buildfor;
        begwhile: buildwhilestmt;
        begloop: buildloopstmt;
        begrpt: buildrptstmt;
        begwith: buildwithstmt;
        begreturn: buildreturn;
        begswitch: start_case;
        caselab: buildlabel;
        casedef: buildlabel;
        endswitch: finishswitch;
        deflab: buildlabel;
        gotolab: buildgotostmt;
        simple: buildsimplestmt(simplehdr);
        hiddenstmt: buildsimplestmt(nohdr);
        syscall: buildsyscallstmt;
        loopbreak: buildlbreak(false);
        begexit: buildlbreak(true);
        loopcont: buildlcont;
        switchbreak: buildsbreak;
        begdata: passdata;
        blksize:
          begin
          while deadcode do decr_deadcount;
          getintfile;
          final_block_size := getintfileint;
          getintfile;
          end;
        otherwise
          begin
          writeln ('travrs: unhandled stmt operator #', ord(interSharedPtr^.interFile^.block[nextintcode].s): 0);
          abort (builderror);
          end;
        end;
    end;
    {>>>}

  begin
    if not (deadcode and (removedeadcode in sharedPtr^.genset)) then
      foncount := foncount + 1;

    while interSharedPtr^.interFile^.block[nextintcode].s <> lasts do
      buildstmt;

    addpredsuccs (currentblock, successorblock);
    getintfile;
  end;
  {>>>}

  {<<<}
  procedure buildrdfo (current, previous: basicblockptr);
  { link the block together in reverse of the dfo list }

  begin
    current^.visited := visitstate;
    current^.rdfolist := previous;
    if current^.dfolist <> nil then
      buildrdfo (current^.dfolist, current);
  end;
  {>>>}
  {<<<}
  procedure searchdfo (rootnode: basicblockptr; var prevblock: basicblockptr);
  { Walk the list of basic block in depth first order }

  var
    succnode: linkptr;

  begin
    rootnode^.visited := visitstate;
    succnode := rootnode^.successor;
    while succnode <> nil do
      begin
      if succnode^.suc^.visited <> visitstate then
        searchdfo (succnode^.suc, prevblock);
      succnode := succnode^.snext;
      end;
    rootnode^.dfolist := prevblock;
    prevblock := rootnode;
  end;
  {>>>}

  {<<<}
  procedure enterloop (blkid: basicblockptr);
  { Set up to calculate loop dominators and monitor reads and writes in the loop }

  var
    i: levelindex;

  begin
    loopfactor := loopfactor + 5;

    if loopdepth = maxloopdepth then
      begin
      loopoverflow := loopoverflow + 1;
      blkid^.deadloop := true;
      end
    else
      begin
      loopdepth := loopdepth + 1;
      with loopstack[loopdepth] do
        begin
        loopblock := blkid;
        reads := 0;
        writes := 0;
        lastwrite := 0;
        for i := 0 to maxlevel do
          deadlevels[i] := false;
        fonmin := foncount;
        end;
      end;
  end;
  {>>>}
  {<<<}
  procedure exitloop;
  { Set up to calculate loop dominators, adjust local var's lifetimes and join write chain to any outer loop Inputs:
    Adjusts the lifetime of any var mentioned in the loop to encompass the entire loop.
    Actually by making every var reach the bottom their lifetimes will conflict producing the desired result.
    Any write's taking place in this loop are tacked onto the end of the write's of the enclosing (if any) loop }

  var
    ptr: nodeptr; { for access to nodes }
    bptr: basicblockptr; { copy of loopblock ptr }
    i: reghashindex; { induction var }

  begin
    { fix the lifetimes of vars mentioned in the loop }
    for i := 0 to regtablelimit do
      begin
      with regvars[i], varlife do
        begin
        if (worth > 0) and ((fonmin >= loopstack[loopdepth].fonmin) or
           (fonmax >= loopstack[loopdepth].fonmin)) then
          begin
          lonmax := lastnode;
          { never let fonmax decrease!}
          if foncount > fonmax then fonmax := foncount;
          end;
        end;
      end;

    loopfactor := loopfactor - 5;
    if loopoverflow > 0 then
      loopoverflow := loopoverflow - 1;
    else
      begin
      with loopstack[loopdepth] do
        begin
        bptr := loopblock;
        bptr^.reads := reads;
        bptr^.writes := writes;
        bptr^.lastwrite := lastwrite;
        bptr^.deadlevels := deadlevels;
        end;
      loopdepth := loopdepth - 1;

      { now hook inner loops writes to this loop }
      if (loopdepth > 0) and (bptr^.lastwrite <> 0) then
        begin
        ptr := ref(bignodetable[bptr^.lastwrite]);
        with loopstack[loopdepth] do
          begin
          ptr^.looplink := writes;
          writes := bptr^.writes;
          if lastwrite = 0 then lastwrite := bptr^.lastwrite;
          end;
        end;
      end;
  end;
  {>>>}

begin
  getintfile;
  initbuild;

  { tail is allocated large since it is handed out when newblock
    sees that we are building a deadblock therefore it must be full size }
  newblock(tail, nil, true);
  newblock(retblock, nil, false);
  retblock^.blocklabel := newlabel;
  newblock(root, nil, false);
  newstmt(temp, blkhdr);
  buildstmtlist(endblk, retblock);
  addpredsuccs(retblock, tail);

  { kill any stmts from deadcode hooked to tail }
  with tail^ do
    begin
    isdead := true;
    precode := 0;
    beginstmt := 0;
    joinop := false;
    saveop := false;
    restoreop := false;
    clearop := false;
    loophdr := false;
    looplabel := 0;
    reads := 0;
    writes := 0;
    lastwrite := 0;
    end;

  symbolrecord := getintfileint;
  getintfile;
  lastblock := nil;

  { reverse the state of visited blocks }
  visitstate := not visitstate; { true}
  retblock^.visited := visitstate;
  searchdfo(root, lastblock);
  tail^.visited := visitstate;
  retblock^.dfolist := tail;
  b := root;
  while b^.dfolist <> nil do b := b^.dfolist;
  b^.dfolist := retblock;

  { reverse the state of visited blocks }
  visitstate := not visitstate; { false}
  buildrdfo (root, nil);

  { now dispose of any local label garbage }
  while locallabels <> nil do
    begin
    templink := locallabels;
    locallabels := locallabels^.link;
    dispose(templink);
    end;
end;
{>>>}

{<<<}
procedure traverse;

  {<<<}
  procedure init;
  { Initialize structured constants (tables) and counters }

  var
    i: integer; {induction var for initializing virtual memory}
    j: 0..nodesperblock; { induction var so building ptrs }
    o: operator; {induction var for initializing map}
    t, t1: types; {induction vars for initializing maps}
    p: proctableindex; {induction for initializing referenced field}

    {<<<}
      procedure map1;

    { Initialize the map which takes input operators and types onto pseudocode.
      This is split into three routines to reduce the size of the code for
      each routine.
    }


        begin {[s=2] Format two assignments per line}
          map[indxchkop, ints] := indxchk;     map[rangechkop, ints] := rangechk;
          map[cindxchkop, ints] := indxchk;    map[ownop, ints] := doown;
          map[congruchkop, ints] := congruchk; map[levop, ints] := dolevel;
          map[intop, ints] := doint;           map[originop, ints] := doorigin;
          map[ptrop, ints] := doptr;           map[realop, ints] := doreal;
          map[structop, ints] := dostruct;     map[moveop, ints] := movint;
          map[moveop, reals] := movreal;       map[moveop, bools] := movint;
          map[moveop, chars] := movint;        map[moveop, ptrs] := movptr;
          map[moveop, scalars] := movint;      map[moveop, arrays] := movstruct;
          map[moveop, fields] := movstruct;    map[moveop, sets] := movset;
          map[moveop, strings] := movstr;      map[moveop, fptrs] := movptr;
          map[moveop, words] := movint;        map[moveop, opaques] := movptr;
          map[moveop, bytes] := movint;
          map[moveop, stringliterals] := movstruct;
          map[moveop, procs] := movptr;        map[cmoveop, arrays] := movcstruct;
          map[movelit, words] := movlitint;    map[movelit, opaques] := movlitptr;
          map[movelit, ints] := movlitint;     map[movelit, chars] := movlitint;
          map[movelit, bools] := movlitint;    map[movelit, ptrs] := movlitptr;
          map[movelit, scalars] := movlitint;  map[movelit, reals] := movlitreal;
          map[movelit, fptrs] := movlitptr;    map[movelit, procs] := movlitptr;
          map[movelit, bytes] := movlitint;    map[chrstrop, strings] := chrstr;
          map[chrstrop, stringliterals] := chrstr;
          map[arraystrop, strings] := arraystr;
          map[arraystrop, stringliterals] := arraystr;
          map[chrstrop, chars] := chrstr;      map[arraystrop, arrays] := arraystr;
          map[chrstrop1, stringliterals] := chrstr;
          map[arraystrop1, stringliterals] := arraystr;
          map[chrstrop1, strings] := chrstr;
          map[arraystrop1, strings] := arraystr;
          map[plusop, ints] := addint;         map[plusop, ptrs] := addptr;
          map[plusop, strings] := addstr;      map[plusop, reals] := addreal;
          map[plusop, sets] := addset;         map[plusop, scalars] := addint;
          map[minusop, ints] := subint;        map[minusop, scalars] := subint;
          map[minusop, ptrs] := subptr;        map[minusop, reals] := subreal;
          map[minusop, sets] := subset;        map[notop, bools] := compbool;
          map[notop, ints] := compint;         map[notop, scalars] := compint;
          map[inop, sets] := inset;            map[andop, ints] := andint;
          map[andop, bools] := andint;         map[andop, scalars] := andint;
          map[andop, ptrs] := andint;          map[orop, ints] := orint;
          map[orop, bools] := orint;           map[orop, scalars] := orint;
          map[orop, ptrs] := orint;            map[incop, ints] := incint;
          map[decop, ints] := decint;          map[indxop, ints] := indx;
          map[indrop, ints] := indxindr;       map[openarrayop, ints] := openarray;
          map[filebufindrop, ints] := indxindr;
          map[aindxop, ints] := aindx;         map[mulop, ints] := mulint;
          map[mulop, reals] := mulreal;        map[mulop, sets] := mulset;
          map[mulop, scalars] := mulint;       map[divop, scalars] := divint;
          map[divop, ints] := divint;          map[stddivop, ints] := stddivint;
          map[slashop, sets] := divset;        map[slashop, reals] := divreal;
          map[quoop, ints] := getquo;          map[remop, ints] := getrem;
          map[shiftlop, ints] := shiftlint;    map[pindxop, ints] := pindx;
          map[paindxop, ints] := paindx;       map[eqop, procs] := eqptr;
          map[eqop, strings] := eqstr;         map[eqop, ints] := eqint;
          map[eqop, chars] := eqint;           map[eqop, bools] := eqint;
          map[eqop, ptrs] := eqptr;            map[eqop, fptrs] := eqfptr;
          map[eqop, scalars] := eqint;         map[eqop, reals] := eqreal;
          map[eqop, sets] := eqset;            map[eqop, arrays] := eqstruct;
          map[eqop, words] := eqint;           map[eqop, opaques] := eqptr;
          map[eqop, bytes] := eqint;           map[neqop, words] := neqint;
          map[neqop, opaques] := neqptr;       map[neqop, procs] := neqptr;
          map[neqop, strings] := neqstr;       map[neqop, ints] := neqint;
          map[neqop, chars] := neqint;         map[neqop, bools] := neqint;
          map[neqop, ptrs] := neqptr;          map[neqop, fptrs] := neqfptr;
          map[ptrchkop, ints] := ptrchk;       map[neqop, bytes] := neqint;
          { new for 32k }                      map[kwoop, ints] := kwoint;
          map[modop, ints] := modint;          map[stdmodop, ints] := stdmodint;

        end; {[s=1] map1}
    {>>>}
    {<<<}
      procedure map2;

    { More map initialization.
    }


        begin {[s=2] Format two assignments per line}
          map[neqop, scalars] := neqint;       map[neqop, reals] := neqreal;
          map[neqop, sets] := neqset;          map[neqop, arrays] := neqstruct;
          map[lssop, strings] := lssstr;       map[lssop, ints] := lssint;
          map[lssop, chars] := lssint;         map[lssop, bools] := lssint;
          map[lssop, ptrs] := lssptr;          map[lssop, scalars] := lssint;
          map[lssop, reals] := lssreal;        map[lssop, arrays] := lssstruct;
          map[gtrop, ints] := gtrint;          map[gtrop, strings] := gtrstr;
          map[gtrop, chars] := gtrint;         map[gtrop, bools] := gtrint;
          map[gtrop, ptrs] := gtrptr;          map[gtrop, scalars] := gtrint;
          map[gtrop, reals] := gtrreal;        map[gtrop, arrays] := gtrstruct;
          map[geqop, strings] := geqstr;       map[geqop, ints] := geqint;
          map[geqop, chars] := geqint;         map[geqop, bools] := geqint;
          map[geqop, ptrs] := geqptr;          map[geqop, scalars] := geqint;
          map[geqop, reals] := geqreal;        map[geqop, sets] := geqset;
          map[geqop, arrays] := geqstruct;     map[leqop, strings] := leqstr;
          map[leqop, ints] := leqint;          map[leqop, chars] := leqint;
          map[leqop, bools] := leqint;         map[leqop, ptrs] := leqptr;
          map[leqop, scalars] := leqint;       map[leqop, reals] := leqreal;
          map[leqop, sets] := leqset;          map[leqop, arrays] := leqstruct;
          map[eqlit, procs] := eqlitptr;       map[eqlit, ints] := eqlitint;
          map[eqlit, reals] := eqlitreal;      map[eqlit, chars] := eqlitint;
          map[eqlit, ptrs] := eqlitptr;        map[eqlit, scalars] := eqlitint;
          map[eqlit, bools] := eqlitint;       map[eqlit, fptrs] := eqlitfptr;
          map[eqlit, words] := eqlitint;       map[eqlit, opaques] := eqlitptr;
          map[eqlit, bytes] := eqlitint;       map[neqlit, words] := neqlitint;
          map[neqlit, opaques] := neqlitptr;   map[neqlit, ints] := neqlitint;
          map[neqlit, procs] := neqlitptr;     map[neqlit, reals] := neqlitreal;
          map[neqlit, chars] := neqlitint;     map[neqlit, ptrs] := neqlitptr;
          map[neqlit, scalars] := neqlitint;   map[neqlit, bools] := neqlitint;
          map[neqlit, fptrs] := neqlitfptr;    map[neqlit, bytes] := neqlitint;
          map[lsslit, ints] := lsslitint;      map[lsslit, reals] := lsslitreal;
          map[lsslit, chars] := lsslitint;     map[lsslit, ptrs] := lsslitptr;
          map[lsslit, scalars] := lsslitint;   map[lsslit, bools] := lsslitint;
          map[gtrlit, ints] := gtrlitint;      map[gtrlit, reals] := gtrlitreal;
          map[gtrlit, chars] := gtrlitint;     map[gtrlit, ptrs] := gtrlitptr;
          map[gtrlit, scalars] := gtrlitint;   map[gtrlit, bools] := gtrlitint;
          map[leqlit, ints] := leqlitint;      map[leqlit, reals] := leqlitreal;
          map[leqlit, chars] := leqlitint;     map[leqlit, ptrs] := leqlitptr;
          map[leqlit, scalars] := leqlitint;   map[leqlit, bools] := leqlitint;
        end; {[s=1] map2}
    {>>>}
    {<<<}
      procedure map3;

    { Yet more map initialization.
    }

        var
          i: types; {induction var}


        begin {[s=2] Format two assignments per line}
          map[wr, files] := wrbin;             map[rd, files] := rdbin;
          map[geqlit, ints] := geqlitint;      map[geqlit, reals] := geqlitreal;
          map[geqlit, chars] := geqlitint;     map[geqlit, ptrs] := geqlitptr;
          map[geqlit, scalars] := geqlitint;   map[geqlit, bools] := geqlitint;
          map[pushaddr, none] := pshaddr;      map[pushproc, none] := pshproc;
          map[pushaddr, strings] := pshaddr;   map[pushaddr, ints] := pshaddr;
          map[pushaddr, arrays] := pshaddr;    map[pushaddr, ptrs] := pshaddr;
          map[pushaddr, fields] := pshaddr;    map[pushaddr, chars] := pshaddr;
          map[pushaddr, reals] := pshaddr;     map[pushaddr, scalars] := pshaddr;
          map[pushaddr, bools] := pshaddr;     map[pushaddr, sets] := pshaddr;
          map[pushaddr, files] := pshaddr;     map[pushaddr, opaques] := pshaddr;
          map[pushaddr, words] := pshaddr;     map[pushaddr, bytes] := pshaddr;
          map[pushaddr, conformantarrays] := pshaddr;
          map[pushaddr, stringliterals] := pshaddr;
          map[pushaddr, procs] := pshaddr;     map[pushaddr, flexarrays] := pshaddr;
          map[pushstraddr, strings] := pshstraddr;
          map[pushlitvalue, procs] := pshlitptr;
          map[pushlitvalue, bools] := pshlitint;
          map[pushlitvalue, chars] := pshlitint;
          map[pushlitvalue, scalars] := pshlitint;
          map[pushlitvalue, ptrs] := pshlitptr;
          map[pushlitvalue, fptrs] := pshlitfptr;
          map[pushlitvalue, ints] := pshlitint;
          map[pushlitvalue, bytes] := pshlitint;
          map[pushlitvalue, reals] := pshlitreal;
          map[defforindexop, ints] := defforindex;
          map[defforlitindexop, ints] := defforlitindex;
          map[defunsforindexop, ints] := defunsforindex;
          map[defunsforlitindexop, ints] := defunsforlitindex;
          map[forupchkop, ints] := forupchk;   map[fordnchkop, ints] := fordnchk;
          map[forerrchkop, ints] := forerrchk; map[pushfinal, ints] := pshint;
          map[pushvalue, stringliterals] := pshstruct;
          map[pushvalue, procs] := pshptr;     map[pushvalue, opaques] := pshptr;
          map[pushvalue, ints] := pshint;      map[pushvalue, reals] := pshreal;
          map[pushvalue, chars] := pshint;     map[pushvalue, ptrs] := pshptr;
          map[pushvalue, scalars] := pshint;   map[pushvalue, arrays] := pshstruct;
          map[pushvalue, fields] := pshstruct; map[pushvalue, sets] := pshset;
          map[pushvalue, bools] := pshint;     map[pushvalue, strings] := pshstr;
          map[pushvalue, fptrs] := pshptr;     map[pushvalue, bytes] := pshint;
          map[pushvalue, words] := pshint;     map[pushvalue, doubles] := pshreal;

          map[pushcvalue, stringliterals] := pshstruct;
          map[pushcvalue, procs] := pshptr;    map[pushcvalue, opaques] := pshptr;
          map[pushcvalue, ints] := pshint;     map[pushcvalue, reals] := pshreal;
          map[pushcvalue, chars] := pshint;    map[pushcvalue, ptrs] := pshptr;
          map[pushcvalue, scalars] := pshint;  map[pushcvalue, arrays] := pshstruct;
          map[pushcvalue, fields] := pshstruct;
          map[pushcvalue, sets] := pshset;     map[pushcvalue, bools] := pshint;
          map[pushcvalue, strings] := pshstr;  map[pushcvalue, fptrs] := pshptr;
          map[pushcvalue, bytes] := pshint;    map[pushcvalue, words] := pshint;
          map[pushcvalue, doubles] := pshreal;

          map[bldfmt, none] := fmt;            map[wr, ints] := wrint;
          map[wr, reals] := wrreal;            map[wr, chars] := wrchar;
          map[wr, arrays] := wrst;             map[wr, bools] := wrbool;
          map[wr, strings] := wrxstr;          map[rd, ints] := rdint;
          map[rd, reals] := rdreal;            map[rd, chars] := rdchar;
          map[rd, arrays] := rdst;             map[rd, strings] := rdxstr;
          map[addrop, opaques] := addr;        map[addrop, words] := addr;
          map[addrop, bytes] := addr;          map[addrop, ptrs] := addr;
          map[addrop, fptrs] := addr;          map[addrop, procs] := addr;
          map[negop, scalars] := negint;       map[negop, ints] := negint;
          map[negop, ptrs] := negint;          map[negop, reals] := negreal;
          map[sysfn, ints] := sysfnint;        map[sysfn, chars] := sysfnint;
          map[sysfn, bools] := sysfnint;       map[sysfn, scalars] := sysfnint;
          map[sysfn, reals] := sysfnreal;      map[sysfn, ptrs] := sysfnint;
          map[sysfn, strings] := sysfnstring;  map[float, ints] := flt;
          map[float1, ints] := flt;            map[float_double, ints] := flt;
          map[real_to_dbl, reals] := cvtrd;    map[dbl_to_real, doubles] := cvtdr;
          map[definelazyop, files] := definelazy;
          map[setbinfileop, files] := setbinfile;
          map[setfileop, none] := setfile;
          map[closerangeop, none] := closerange;

          { Map entries for doubles }

          map[moveop, doubles] := movreal;     map[movelit, doubles] := movlitreal;
          map[plusop, doubles] := addreal;     map[minusop, doubles] := subreal;
          map[mulop, doubles] := mulreal;      map[slashop, doubles] := divreal;
          map[eqop, doubles] := eqreal;        map[neqop, doubles] := neqreal;
          map[lssop, doubles] := lssreal;      map[gtrop, doubles] := gtrreal;
          map[geqop, doubles] := geqreal;      map[leqop, doubles] := leqreal;
          map[eqlit, doubles] := eqlitreal;    map[neqlit, doubles] := neqlitreal;
          map[lsslit, doubles] := lsslitreal;  map[gtrlit, doubles] := gtrlitreal;
          map[leqlit, doubles] := leqlitreal;  map[geqlit, doubles] := geqlitreal;
          map[pushaddr, doubles] := pshaddr;
          map[pushlitvalue, doubles] := pshlitreal;
          map[wr, doubles] := wrreal;          map[rd, doubles] := rdreal;
          map[negop, doubles] := negreal;      map[sysfn, doubles] := sysfnreal;

          for i := subranges to none do map[loopholeop, i] := loopholefn;
          for i := subranges to none do map[dummyargop, i] := dummyarg;
          for i := subranges to none do map[dummyarg2op, i] := dummyarg2;
        end; {[s=1] map3}
    {>>>}
    {<<<}
      procedure map4;

    { Initialize operators used for C
    }

        var
          i: types; {induction var}


        begin {[s=2] Format two assignments per line}
          map[addeqop, ints] := addint;        map[addeqop, reals] := addreal;
          map[addeqop, ptrs] := addptr;        map[andeqop, ints] := andint;
          map[addeqop, scalars] := addint;     map[castfptrop, ints] := castintfptr;
          map[castfptrop, ptrs] := castintfptr; {***hmmm...***}
          map[castintop, ptrs] := castptrint;  map[castintop, ints] := castint;
          map[castintop, fptrs] := castfptrint;
          map[castintop, reals] := castrealint;
          map[castptrop, ints] := castintptr;  map[castptrop, ptrs] := castptr;
          map[castrealop, ints] := flt;        map[castrealop, reals] := castreal;
          map[compop, ints] := compint;        map[daddop, none] := dataadd;
          map[daddrop, none] := dataaddr;      map[dendop, none] := dataend;
          map[dfaddrop, none] := datafaddr;    map[dfieldop, none] := datafield;
          map[dfillop, none] := datafill;      map[dintop, none] := dataint;
          map[diveqop, ints] := getquo;        map[diveqop, reals] := divreal;
          map[diveqop, scalars] := getquo;     map[drealop, none] := datareal;
          map[dstartop, none] := datastart;    map[dstoreop, none] := datastore;
          map[dstructop, none] := datastruct;  map[dsubop, none] := datasub;
          map[extop, none] := bad;             map[fptrop, ints] := dofptr;
          map[modeqop, ints] := getrem;        map[modeqop, scalars] := getrem;
          map[muleqop, ints] := mulint;        map[muleqop, reals] := mulreal;
          map[muleqop, scalars] := mulint;     map[oreqop, scalars] := orint;
          map[oreqop, ints] := orint;          map[postincop, ints] := postint;
          map[postincop, scalars] := postint;  map[postincop, reals] := postreal;
          map[postincop, ptrs] := postptr;     map[preincop, ptrs] := preincptr;
          map[pushfptr, fptrs] := pshfptr;     map[pushret, ptrs] := pshretptr;
          map[jumpvfuncop, none] := jumpvfunc; map[jumpvfuncop, ints] := jumpvfunc;
          map[returnop, ints] := returnint;    map[returnop, reals] := returnreal;
          map[returnop, ptrs] := returnptr;    map[returnop, fptrs] := returnfptr;
          map[returnop, fields] := returnstruct;
          map[returnop, stringliterals] := returnstruct;
          map[returnop, chars] := returnint;   map[returnop, bools] := returnint;
          map[returnop, scalars] := returnint;
          map[returnop, strings] := returnstruct;
          map[returnop, words] := returnint;   map[returnop, bytes] := returnint;
          map[returnop, procs] := returnfptr;  map[returnop, doubles] := returnreal;
          map[returnop, arrays] := returnstruct;
          map[returnop, sets] := returnstruct; map[returnop, opaques] := returnptr;
          map[shiftleqop, scalars] := shiftlint;
          map[shiftleqop, ints] := shiftlint;  map[shiftreqop, ints] := shiftrint;
          map[shiftreqop, scalars] := shiftrint;
          map[shiftrop, scalars] := shiftrint; map[shiftrop, ints] := shiftrint;
          map[subeqop, ints] := subint;        map[subeqop, scalars] := subint;
          map[subeqop, reals] := subreal;      map[subeqop, ptrs] := subptr;
          map[tempop, ints] := regtemp;        map[tempop, scalars] := regtemp;
          map[tempop, ptrs] := ptrtemp;        map[tempop, reals] := realtemp;
          map[tempop, fptrs] := ptrtemp;       map[xoreqop, scalars] := xorint;
          map[xoreqop, ints] := xorint;        map[xorop, ints] := xorint;
          map[xorop, scalars] := xorint;
        end; {[s=1] map4}
    {>>>}
    {<<<}
      procedure cmap;

    { Initialize the cast map
    }


        begin
          castmap[ints, ints] := castint;
          castmap[ints, ptrs] := castptrint;
          castmap[ints, fptrs] := castfptrint;
          castmap[ints, reals] := castrealint;
          castmap[ptrs, ints] := castintptr;
          castmap[fptrs, ints] := castintfptr;
          castmap[reals, ints] := flt;
          castmap[reals, reals] := castreal;
        end;
    {>>>}

  begin
    { This code checks certain configuration parameters and reports any potential problems. }
    { End of special configuration checks}
    lasttravrslabel := 1;

    for o := endexpr to xorop do
      for t := subranges to none do 
        map[o, t] := bad;

    for t := subranges to none do
      for t1 := subranges to none do 
        castmap[t, t1] := bad;

    map1;
    map2;
    map3;
    map4;
    cmap;

    nextpseudofile := 0;
    nextintcode := 0;
    laststmt := 1;
    walkdepth := 0;
    hoistone := 0;
    hoisttwo := 0;
    maxnodes := 0;

    for p := 1 to sharedPtr^.proctabletop do
      if newtravrsinterface then
        sharedPtr^.new_proctable[p div (pts + 1)]^[p mod (pts + 1)].referenced := false
      else 
        sharedPtr^.proctable[p].referenced := false;

    sharedPtr^.anynonlocalgotos := false;
    emitpseudo := false;
  end;
  {>>>}

begin
  sharedPtr := getSharedPtr;
  interSharedPtr := getInterSharedPtr;
  pseudoSharedPtr := getPseudoSharedPtr;

  init;

  { open local file }
  reset (sharedPtr^.localFile);

  { open dump file }
  if dumpFiles then
    rewrite (dumpFile, 'output.tree');

  while interSharedPtr^.interFile^.block[nextintcode].s <> endall do
    begin
    while interSharedPtr^.interFile^.block[nextintcode].s = begdata do
      passdata;

    if interSharedPtr^.interFile^.block[nextintcode].s <> endall then
      begin
      build;
      if dumpFiles then
        dumptree;
      improve;
      if dumpFiles then
        dumptree;
      walk;
      end;
    end;

  if dumpPseudo then
    {<<<  close pseudo file}
    begin
    pseudoSharedPtr^.pseudoFile^.block[nextpseudofile].op := endpseudocode;
    putpseudofile;
    if nextpseudofile <> 0 then
      put (pseudoSharedPtr^.pseudoFile);
    end;
    {>>>}

  if dumpFiles then
    {<<<  close tree file}
    begin
    if hoistone <> 0 then
      writeln (hoistone: 1, ' invariants hoisted');
    if hoisttwo <> 0 then
      writeln (hoisttwo: 1, ' second level hoists');
    writeln ((maxnodes * size(node)): 1, ' bytes of node storage used.');

    close (dumpFile);
    end
    {>>>}
  else if sharedPtr^.switchcounters[tswitch0] > 0 then
    writeln ('travrs, last node was ', maxnodes: 1);

  close (sharedPtr^.localFile);
end;
{>>>}
