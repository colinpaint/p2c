{ debug.def - external procedure defs }

{ ??? }
{procedure getpos (var f: text; var block, byte: integer); external; }

type
  dbgstringblock = packed array [0..diskbufsize] of char;

{ pdbfiles.pas }
{<<<}
{ Position stmtfile to current line in listing file for PDB }
procedure positionstmtfile (linecount: integer; var stmtno: integer); external;
{>>>}
{<<<}
{ Update statement file with getpos/setpos data pointing to current line in listing file }
procedure updatestmtfile (linecount, temppos1, temppos2: integer); external;
{>>>}
{<<<}
{ Dump the PDB symbol table }
procedure dumpsymboltable (level: levelindex; {level of block to dump}
                           regok: boolean {ok to allocate global reg variables} ) ; external;
{>>>}

{<<<}
{ Modify the symbol file to reflect the allocation of the variable at index.
  Used by travrs when assigning variables to registers }
procedure dbg_alloc (index: p_symbolindex; {a variable name's index (0 ignored)}
                     new_alloc: allockind; {kind of allocation}
                     new_offset: integer {where allocated} ); external;
{>>>}
{<<<}
{ Modify the symbol file to reflect the actual register usage for a procedure.
  Used by code after register usage is known.  pc_index, if non-zero, is
  the location in the map file to place the function starting pc. }
procedure dbg_regs (index: p_symbolindex; {procedure name to be updated}
                    var reg: array [lo..hi: integer] of boolean;
                    var pc_index: integer {map file index for pc} ); external;
{>>>}

{ hash names for debugger }
function debughash (len: integer; function nextchar: char): integer; external;
function opendebugfile (var filename: FilenameBuf; ext: packed array [elower..eupper: integer] of char): boolean; external;
procedure closedebugfile (function nextblock (var blk: dbgstringblock): boolean {is there more} ); external;
function p_debughash (len: integer; function nextchar: char): integer; external;

{<<<}
procedure create_paramdesc (procformidx: unsignedword; {proc this param belongs to}
                            xparamtype: p_symbolindex; {pointer to param type}
                            xparamkind: nametype) {kind of param (var, value?)} ; external;
{>>>}
{<<<}
function create_filename (xstringoff: unsignedword; {offset in string table}
                          hashvalue: integer; {returned by the "hash" function for this id}
                          xfirstchar: char; {first character in name}
                          xident_len: unsignedword {length of the name}
                          ): p_symbolindex; external;
{>>>}
{<<<}
function create_typename (xstringoff: unsignedword; {offset in string table}
                          hashvalue: integer; {returned by the "hash" function for this id}
                          xfirstchar: char; {first character in name}
                          xident_len: unsignedword; {length of the name}
                          visibtylink: p_symbolindex; {visibility link, points to
                                                       enclosing record, procedure or module or pervasives}
                          xsymboltype: p_symbolindex; {index of form descriptor for this type}
                          xfilename: unsignedword; {index of source file name}
                          xstartpos: unsignedint; {position in source of this name declaration}
                          xdeclare_len: unsignedword {number of lines for name declaration}
                          ): p_symbolindex; external;
{>>>}
{<<<}
function create_varname (xstringoff: unsignedword; {offset in string table}
                         hashvalue: integer; {returned by the hash function for this id}
                         xfirstchar: char; {first character in name}
                         xident_len: unsignedword; {length of the name; 0 => formal param of a proc type}
                         visibtylink: p_symbolindex; {visibility link, points to enclosing procedure,
                                                      module or pervasives; 0 => formal param of a proc type}
                         xsymboltype: p_symbolindex; {index of form descriptor for this type}
                         xfilename: unsignedword; {index of source file name}
                         xstartpos: unsignedint; {position in source of this name declaration}
                         xdeclare_len: unsignedword; {number of lines for name declaration}
                         xnamekind: nametype; {varname, param, varparam, procparam, funcparam, confparam,
                                              varconfparam, flexparam, varflexparam, boundid }
                         xoffset: addressrange; {runtime addr}
                         xlength: addressrange; {data length in units}
                         xvaralloc: allockind {how this variable is allocated}
                         ): p_symbolindex; external;
{>>>}
{<<<}
function create_variantlabel (xnextlabel: p_symbolindex;
                              xvalue: targetint): p_symbolindex; external;
{>>>}
{<<<}
function create_strucconst (xstringoff: unsignedword; {offset in string table}
                            hashvalue: integer; {returned by the hash function for this id}
                            xfirstchar: char; {first character in name}
                            xident_len: unsignedword; {length of the name; 0 => formal param of a proc type}
                            visibtylink: unsignedword;  {visibility link, points to enclosing record, procedure or module or pervasives;
                                                         0 => formal param of a proc type}
                            xsymboltype: unsignedword;  {index of form descriptor for this type}
                            xfilename: unsignedword;  {index of source file name}
                            xstartpos: unsignedint; {position in source of this name declaration}
                            xdeclare_len: unsignedword;  {number of lines for name declaration}
                            xconsttype: types;  {constant type - sets or stringliterals}
                            xconstoffset: targetint;  {offset from constant data area}
                            xconstlength: targetint  {length of constant}
                            ): unsignedword; external;
{>>>}
{<<<}
function create_intvalconst (xstringoff: unsignedword; {offset in string table}
                             hashvalue: integer; {returned by the hash function for this id}
                             xfirstchar: char; {first character in name}
                             xident_len: unsignedword; {length of the name; 0 => formal param of a proc type}
                             visibtylink: unsignedword;  {visibility link, points to enclosing record, procedure or module or pervasives;
                                                          0 => formal param of a proc type}
                             xsymboltype: unsignedword;  {index of form descriptor for this type}
                             xfilename: unsignedword;  {index of source file name}
                             xstartpos: unsignedint; {position in source of this name declaration}
                             xdeclare_len: unsignedword;  {number of lines for name declaration}
                             xconsttype: types;  {constant type - ints, bools, scalars}
                             xvalue: targetint;  {integer value of constant}
                             unsigned: boolean  {true if value is interpreted as unsigned}
                             ): unsignedword; external;
{>>>}
{<<<}
function create_realvalconst (xstringoff: unsignedword; {offset in string table}
                              hashvalue: integer; {returned by the hash function for this id}
                              xfirstchar: char; {first character in name}
                              xident_len: unsignedword; {length of the name; 0 => formal param of a proc type}
                              visibtylink: unsignedword;  {visibility link, points to enclosing record, procedure or module or pervasives;
                                                           0 => formal param of a proc type}
                              xsymboltype: unsignedword;  {index of form descriptor for this type}
                              xfilename: unsignedword;  {index of source file name}
                              xstartpos: unsignedint; {position in source of this name declaration}
                              xdeclare_len: unsignedword;  {number of lines for name declaration}

                              xconsttype: types;  {constant type reals, doubles}
                              xvalue: realarray  {value of real/double}
                              ): unsignedword; external;
{>>>}
{<<<}
function create_procname (xstringoff: unsignedword; {offset in string table}
                          hashvalue: integer; {returned by the hash function for this id}
                          xfirstchar: char; {first character in name}
                          xident_len: unsignedword; {length of the name}
                          visibtylink: p_symbolindex; {visibility link, points to enclosing record,
                                                       procedure or module or pervasives}
                          xfilename: unsignedword; {index of source file name}
                          xstartpos: unsignedint; {position in source of this name declaration}
                          xlevel: targetint {static nesting level}
                          ): p_symbolindex; external;
{>>>}
{<<<}
procedure update_procname (index: p_symbolindex;
                           xdeclare_len: unsignedword; {number of lines for name declaration}
                           xblocksize: addressrange; {size (in units) of local storage}
                           xfirststmt: integer; {value returned by stf_stmt()}
                           xlaststmt: integer; {ditto, for last stmt.}
                           xsymboltype: p_symbolindex {index of form descriptor for this type}
                           ); external;
{>>>}

{<<<}
function create_simpleform (size: addressrange; {size in units}
                            typ: types; {type of simple form}
                            unsigned: boolean {true if extended representation}
                            ): p_symbolindex; external;

{>>>}
function create_scalarform: p_symbolindex; external;
{<<<}
procedure update_scalarform (index: p_symbolindex; {record to be updated}
                             xsize: addressrange); {size in units} external;

{>>>}
{<<<}
function create_setform (xsize: addressrange; {size in units}
                         xpackedflag: boolean; {true if user specified 'packed'}
                         xbitaddress: boolean; {true if item is bit, not unit accessed}
                         xbasetype: p_symbolindex {points to base type}
                         ): p_symbolindex; external;
{>>>}
{<<<}
function create_arrayform (xtyp: types; {of type arrays or flexarrays}
                           xsize: addressrange; {size in units; 0 => flex array}
                           xpackedflag: boolean; {true if user specified 'packed'}
                           xbitaddress: boolean; {true if item is bit, not unit accessed}
                           xindextype: p_symbolindex; {pointer to index type}
                           xelementtype: p_symbolindex; {pointer to element type}
                           xelementsize: addressrange {size of an element}
                           ): p_symbolindex; external;
{>>>}
{<<<}
function create_subrangeform (xsize: addressrange; {size in units or bits}
                              xunsigned: boolean; {true if extended representation}
                              xlowerord, xupperord: targetint; {was declared lowerord..upperord}
                              xparenttype: p_symbolindex {points to base type}
                              ): p_symbolindex; external;
{>>>}

{<<<}
{ Create form entry for a new piece of a record.  "newscope" is necessary
  because each "record ... end" creates only one scope, though potentially
  many "fields" entries in both the compiler and debugger symbol table.
  If true, a new hash record is built. }
function create_fieldform (newscope: boolean; {create a new scope hash record?}
                           xsize: addressrange; {size in units}
                           xpackedflag: boolean; {true if user specified 'packed'}
                           xbitaddress: boolean; {true if item is bit, not unit accessed}
                           xfieldid: integer; {scope id for symbol table search}
                           xnextvariant: p_symbolindex; {next variant record at this level}
                           xfirstlabel: p_symbolindex; {head of label chain describing this variant}
                           xfirstvariant: p_symbolindex; {first subvariant defined by case at level}
                           xtagfield: p_symbolindex; {name entry of tagfield, 0 if none}
                           xfirstfield: p_symbolindex; {index of first field in symbol table}
                           xlastfield: p_symbolindex {index of last field in record}
                           ): p_symbolindex; external;

{>>>}
{<<<}
{ Called only at outermost record level, i.e. "record ... end", not
  variant subfields.  These two entries were unknown a creation time.
  Records declare a new scope, thus compiler must initialize the outermost
  field before it is parsed so that we'll have a place to hook idents.
  Normally, subfields are handled to a call to "create_type" after
  all this info has been gathered, like other types }
procedure update_fieldform (index: p_symbolindex; {which field to update}
                            xlastfield: p_symbolindex; {update to exclude subfields}
                            xfirstvariant: p_symbolindex; {first outermost variant}
                            xtagfield: p_symbolindex); external;
{>>>}
function create_pointerform: p_symbolindex; external;
{<<<}
procedure update_pointerform (index: p_symbolindex; { record to be updated }
                              xsize: addressrange; {size in units}
                              xptrtype: p_symbolindex); {'POINTER TO <xptrtype>'} external;
{>>>}
function create_fileform: p_symbolindex; external;
{<<<}
procedure update_fileform (index: p_symbolindex; { record to be updated }
                           xsize: addressrange; {size in units}
                           xfilebasetype: p_symbolindex); {'POINTER TO <xptrtype>'} external;
{>>>}

procedure closed; external; {close the debug file}
