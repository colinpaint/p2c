{ shared.def }

type
  { athdr file types }
  {<<<}
  stmtType = (begblk, endblk, begwhile, endwhile, begrpt, endrpt, begfor,
              forup, fordn, endfor, begif, endelse, begelse, endthen, gotolab,
              deflab, begwith, endwith, begcase, caselab, casedef, endcaseelt,
              caselabrange, endcase, begcfor, endcfor, begreturn, begloop,
              endloop, begexit, blksize, hiddenstmt, begswitch, endswitch,
              inits, loopbreak, loopcont, switchbreak, syscall, simple,
              begdata, endall);
  {>>>}
  {<<<}
  { expression operators emitted by analys, read by travrs }
  { DO NOT ALPHABETIZE OR OTHERWISE SCREW AROUND WITH THE ORDERING }
  {operators before intop are linked by travrs sequentially and are never CSEs}
  operator = (endexpr, newvarop, newunsvarop, globalop, localop, lit,
              defforlitindexop, defforindexop, forindexop,
              defunsforlitindexop, defunsforindexop, forupchkop, fordnchkop,
              forerrchkop, moveop, cmoveop, movelit, lssop, leqop, neqop,
              eqop, gtrop, geqop, lsslit, leqlit, eqlit, neqlit, gtrlit,
              geqlit, withop, setfileop, setfileaddrop, setinput, newset,
              bldset, setelt, setpair, bldnil, bldfmt, inop, addrop, pushaddr,
              pushstraddr, pushvalue, pushcvalue, pushfinal, pushlitvalue,
              pushret, pushfptr, retop, call, jumpvfuncop,
              unscall, callparam, unscallparam, copystackop, reserve,
              pushproc, rd, wr, switchstack, structop, closerangeop,
              dummyargop, filebufindrop, intop, ptrop, realop, doubleop,
              varop, unsvarop, definelazyop, ownop, segop, extop, levop,
              tempop, originop, float1, float, float_double, real_to_dbl,
              dbl_to_real, plusop, dummyarg2op, minusop, mulop, divop,
              stddivop, remop, quoop, kwoop, modop, stdmodop, negop, slashop,
              setbinfileop, shiftlop, incop, decop, indrop, indxop, aindxop,
              pindxop, paindxop, chrstrop, chrstrop1, arraystrop, arraystrop1,
              sysfn, andop, orop, notop, loopholeop, indxchkop, ptrchkop,
              congruchkop, cindxchkop, rangechkop, openarrayop, fptrop,
              returnop, uretop, shiftrop, addeqop, andeqop, begscope,
              castintop, castptrop, castfptrop, castrealop, commaop, compop,
              daddop, daddrop, dendop, dfaddrop, dfieldop, dfillop, dintop,
              diveqop, drealop, dstartop, dstoreop, dstructop, dsubop,
              endscope, groupop, modeqop, muleqop, oreqop, preincop,
              postincop, questop, shiftleqop, shiftreqop, subeqop, varkind,
              xoreqop, xorop, vindxop, parmop, clearnewop, saveop, restop,
              deleteop);
  {>>>}
  {<<<}
  types = (subranges, fields, variantlabs, arrays, conformantarrays, strings,
           sets, files, ptrs, scalars, ints, bools, chars, reals,
           doubles, fptrs, funcs, procs, stringliterals, flexarrays, opaques,
           bytes, words, none);
  {>>>}
  intCodeType = (stmt, op, literal, form);

  atFileComponentType = packed record
    case intCodeType of
      stmt:    (s: stmtType);
      op:      (o: operator);
      literal: (b: 0..255);
      form:    (f: types)
    end;

  atFileType = file of packed record
                 block:  packed array [0..511] of atFileComponentType;
                 end;

  { other types }
  {<<<}
  { Pascal tokens -- identified by scanner }
  tokentype = (programsym, labelsym, constsym, typesym, varsym, sharedsym,
               proceduresym, functionsym, uparrow, arraysym, filesym,
               setsym, recordsym, stringsym, univsym, packedsym,
               originsym, usesym, definesym, beginsym, ifsym, casesym,
               whilesym, repeatsym, forsym, withsym,
               gotosym, eql, lss, gtr, neq, leq, geq, insym, plus, minus,
               orsym, star, slash, divsym, modsym, andsym, ofsym, endsym,
               elsesym, thensym, otherwisesym, dosym, untilsym, tosym,
               downtosym, notsym, at, nilsym, colon, dot, dotdot, comma,
               semicolon, becomes, lpar, rpar, lbrack, rbrack, intconst,
               realconst, dblrealconst, charconst, stringconst, ident, eofsym,
               lineinc, lineadd, newfile);
  {>>>}

  { packs as bytes
  scanFileComponentType = 0..255;
  scanFileComponentType = packed record
    byte: 0..255;
    end;
  }

  { no pack, 4 bytes each, tokentype becomes an unsigned in struct union }
  scanFileComponentType = packed record
    { byte: 0..255; } { pack as bytes }
    case boolean of   { no pack, 4 bytes each, tokentype is unsigned, widens struct union }
      true:  (byte: 0..255);
      false: (token: tokentype);
      end;

  scanFileType = file of packed record
                   block:  packed array [0..511] of scanFileComponentType;
                   end;

  sharedType = record
                 value1: Integer;
                 value2: Integer;
                 scanFile: scanFileType;
                 atFile: atFileType;
                 end;

  sharedPtrType = ^sharedType;

{ procedures }
function initShared : sharedPtrType; external;
function getSharedPtr : sharedPtrType; external;
